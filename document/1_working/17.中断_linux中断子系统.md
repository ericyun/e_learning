# 部门研发制度规定

## 0 修订记录1
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2018/04/10 | 员清观 |  |

## 1 中断子系统一些基本概念

可以查看linux系统中中断统计信息：　`cat /proc/interrupts`

**一些基本概念：**
- 硬中断（外部中断）：通过外部设备接口，向CPU的中断请求引脚INT和NMI发中断请求产生
- 软中断（内部中断）：CPU内部执行中断指令，或由运算溢出，TF（Trap Falg，每执行一条指令，自动产生一个内部中断去执行一个中断服务程序）标志而产生
- 可屏蔽中断（INT）
- 不可屏蔽中断（NMI）
- 向量中断：不同的中断分配不同的中断号，有不同的入口地址，硬件提供
- 非向量中断：多个中断共享一个入口地址，再通过中断标志识别具体哪个中断，软件提供

中断处理程序是在关掉其他所有中断的情况下进行，执行于硬件相关的处理要求快，而有些驱动在中断处理程序中又需要完成大量的工作，这就矛盾了。这需要在这两者间找到一个平衡点，所以分解为两个部分。
- 顶半部（tophalf） 顶半部的功能是“登记中断”。顶半部尽可能快的完成比较急的功能，往往只是简单的读取寄存器中的中断状态并清除中断标志后进行“登记中断”即中断例程的底半部挂到该设备的底半部执行队列中去。这样顶半部执行的速度很快，能服务更多的中断请求. 申请和释放中断函数request_irq() 和 free_irq();
- 底半部(bottom half)  底半部来完成中断事件的绝大多数使命。顶半部与底半部最大的不同是，底半部是可中断的，顶半部不可中断。

### 1.1 中断的申请和释放
```cpp
static inline int __must_check　devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler, unsigned long irqflags, const char *devname, void *dev_id)
  |--> return devm_request_threaded_irq(dev, irq, handler, NULL, irqflags, devname, dev_id);
  //非线程化中断
  //int  devm_request_threaded_irq(struct device *dev, unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id)
    struct irq_devres *dr = devres_alloc(devm_irq_release, sizeof(struct irq_devres), GFP_KERNEL);
    rc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname, dev_id);
    dr->irq = irq;  dr->dev_id = dev_id;
    devres_add(dev, dr);
```
`request_irq()`这个函数是对`request_thread_irq()`的封装，它给`request_thread_irq()`的`thread_fn`参数传进了一个NULL，也就是只申请中断处理函数，不要`thread_fn`; `devm_request_threaded_irq`这个函数增加了对申请irq的dev的管理．

```cpp
//顶半部机制
//申请和释放中断函数request_irq() 和 free_irq()
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long irqflags, const char * devname, void *dev_id);
//irq是要申请的硬件中断号。handler是向系统登记的中断处理函数。这是一个回调函数，中断发生时，系统调用这个函数，传入的参数包括硬件中断号，device id，寄存器值。dev_id就是下面的request_irq时传递给系统的参数dev_id。irqflags是中断处理的一些属性。比较重要的有标明中断处理程序是快速处理程序(设置IRQF_DISABLED)还是慢速处理程序(不设置IRQF_DISABLED)。快速处理程序被调用时屏蔽所有中断。慢速处理程序不屏蔽。还有一个IRQF_SHARED属性，设置了以后运行多个设备共享中断。dev_id在中断共享时会用到。一般设置为这个设备的 device结构本身或者NULL。中断处理程序可以用dev_id找到相应的控制这个中断的设备，或者用irq2dev_map找到中断对应的设备。
void free_irq(unsigned int irq,void *dev_id);

//使能和屏蔽中断
void disable_irq(int irq)
void disable_irq_nosync(int irq)
void enable_irq(int irq)
//disable_irq()和disable_irq_nosync()的区别在于，后者立即返回，而且前者等待目前的中断处理完成。如果enable_irq()函数会引起系统死锁，这种情况下，只能使用disable_irq_nosync()
local_irq_save(flags)
local_irq_restore(flags)
//注意：保存的是数值，不是指针，因为flags是unsigned long类型，所以这对中断函数要在同一个函数中使用
```

HI_SOFTIRQ用于高优先级的tasklet，TASKLET_SOFTIRQ用于普通的tasklet.

linux kernel的中断子系统分成4个部分：
1. 硬件无关的代码，我们称之Linux kernel通用中断处理模块。无论是哪种CPU，哪种controller，其中断处理的过程都有一些相同的内容，这些相同的内容被抽象出来，和HW无关。此外，各个外设的驱动代码中，也希望能用一个统一的接口实现irq相关的管理（不和具体的中断硬件系统以及CPU体系结构相关）这些“通用”的代码组成了linux kernel interrupt subsystem的核心部分。
2. CPU architecture相关的中断处理。 和系统使用的具体的CPU architecture相关。
3. Interrupt controller驱动代码 。和系统使用的Interrupt controller相关。
4. 普通外设的驱动。这些驱动将使用Linux kernel通用中断处理模块的API来实现自己的驱动逻辑。

当外设触发一次中断后，一个大概的处理过程是：
1. 具体CPU architecture相关的模块会进行现场保护，然后调用machine driver对应的中断处理handler.--> ARM的IRQ异常,保护现场,调用中断handler
2、machine driver对应的中断处理handler中会根据硬件的信息获取HW interrupt ID，并且通过irq domain模块翻译成IRQ number.
3、调用该IRQ number对应的high level irq event handler，在这个high level的handler中，会通过和interupt controller交互，进行中断处理的flow control（处理中断的嵌套、抢占等），当然最终会遍历该中断描述符的IRQ action list，调用外设的specific handler来处理该中断
//中断控制器相关的处理.
4、具体CPU architecture相关的模块会进行现场恢复。

对于中断处理而言，linux将其分成了两个部分，一个叫做中断handler（top half），属于不那么紧急需要处理的事情被推迟执行，我们称之deferable task，或者叫做bottom half，。具体如何推迟执行分成下面几种情况：
1、推迟到top half执行完毕, 包括softirq机制和tasklet机制
2、推迟到某个指定的时间片（例如40ms）之后执行, softirq机制的一种应用场景（timer类型的softirq）
3、推迟到某个内核线程被调度的时候执行,包括threaded irq handler以及通用的workqueue机制和驱动专属kernel thread（不推荐使用）

软中断不会抢占另外一个软中断，唯一可以抢占软中断的是中断处理程序。软中断可以在不同CPU上并发执行(哪怕是同一个软中断)

## 2 中断处理过程
### 2.1 中断初始化相关
```cpp
void __init start_kernel(void)
  local_irq_disable();
  setup_arch(&command_line);
    setup_processor();-->cpu_init();//初始化cpu stack
    paging_init(mdesc);
      |--> devicemaps_init(mdesc); //static void __init devicemaps_init(struct machine_desc *mdesc) 加载中断向量表
        vectors = early_alloc(PAGE_SIZE);
        early_trap_init(vectors);
        map.virtual = 0xffff0000; create_mapping(&map, false);
        fill_pmd_gaps(); local_flush_tlb_all(); flush_cache_all();
  early_irq_init(); //
  init_IRQ();
    |-->machine_desc->init_irq();-->void __init q3f_init_irq(void)-->gic_init(0, 29, IO_ADDRESS(IMAP_GIC_DIST_BASE), IO_ADDRESS(IMAP_GIC_CPU_BASE));
      gic_init_bases(nr, start, dist, cpu, 0, NULL);
        gic->domain = irq_domain_add_legacy(node, gic_irqs, irq_base,hwirq_base, &gic_irq_domain_ops, gic);
        set_handle_irq(gic_handle_irq); --> handle_arch_irq = handle_irq;
        gic_dist_init(gic); gic_cpu_init(gic); gic_pm_init(gic);

  local_irq_enable();

//kernel/arch/arm/mach-q3f.c文件中
MACHINE_START(IMAPX15, "iMAPx15")
	.nr				= 0x8f9,
	.atag_offset    = 0x100,
	.smp			= smp_ops(q3f_smp_ops),
	.init_early		= q3f_init_early,
	.init_irq		= q3f_init_irq, // 中断初始化函数指针定义
	.map_io			= q3f_map_io,
	.init_machine   = q3f_machine_init,
	.init_time		= q3f_init_time,
	.init_late		= q3f_init_late,
	.restart		= q3f_restart,
	.reserve		= q3f_reserve,
MACHINE_END

```

### 2.2 中断入口汇编解析

在ARM V4及V4T以后的大部分处理器中，异常向量表的位置可以有两个位置：一个是0，另一个是0xffff0000。可以通过CP15协处理器c1寄存器中V位(bit[13])控制。V和中断向量表的对应关系如下：V=0 ～0x00000000~0x0000001C; V=1 ～ 0xffff0000~0xffff001C。Linux中选择的是设置0xffff0000为异常向量表的位置。`early_trap_init()`函数对异常向量表进行了初始化操作

**当中断被触发之后，处理器行为：**
```cpp
//Cpu进入irq状态
  R14_irq = 下一条指令 + 4 的地址
  SPSR_irq = CPSR
  CPSR(4:0) = 0b10010 CPSR(5) = 0 CPSR(8) = 1  CPSR(9) = CP15_reg1_EEbit CPSR(7) = 1  //disable normal interrupt
  If VE=0
    If high vectors configured then
      PC = 0xffff0018
    Else
      PC = 0x00000018
  Else
    PC = 不可预测
```
**linux中断向量表定义：**
```cpp
//traps.c文件中，设置linux中断向量表的代码
void __init early_trap_init(void *vectors_base) {
	unsigned long vectors = (unsigned long)vectors_base;
	extern char __stubs_start[], __stubs_end[];
	extern char __vectors_start[], __vectors_end[];
	extern char __kuser_helper_start[], __kuser_helper_end[];
	int kuser_sz = __kuser_helper_end - __kuser_helper_start;

	vectors_page = vectors_base;

	/*
	 * Copy the vectors, stubs and kuser helpers (in entry-armv.S)
	 * into the vector page, mapped at 0xffff0000, and ensure these
	 * are visible to the instruction stream.
	 */
	memcpy((void *)vectors, __vectors_start, __vectors_end - __vectors_start);
	memcpy((void *)vectors + 0x200, __stubs_start, __stubs_end - __stubs_start);
	memcpy((void *)vectors + 0x1000 - kuser_sz, __kuser_helper_start, kuser_sz);

	/*
	 * Do processor specific fixups for the kuser helpers
	 */
	kuser_get_tls_init(vectors);

	/*
	 * Copy signal return handlers into the vector page, and
	 * set sigreturn to be a pointer to these.
	 */
	memcpy((void *)(vectors + KERN_SIGRETURN_CODE - CONFIG_VECTORS_BASE),
	       sigreturn_codes, sizeof(sigreturn_codes));

	flush_icache_range(vectors, vectors + PAGE_SIZE);
	modify_domain(DOMAIN_USER, DOMAIN_CLIENT);
}

//kernel/arch/arm/entry-armv.S文件中，定义了中断向量表
	.equ	stubs_offset, __vectors_start + 0x200 - __stubs_start

	.globl	__vectors_start
__vectors_start:
 ARM(	swi	SYS_ERROR0	)
 THUMB(	svc	#0		)
 THUMB(	nop			)
	W(b)	vector_und + stubs_offset
	W(ldr)	pc, .LCvswi + stubs_offset
	W(b)	vector_pabt + stubs_offset
	W(b)	vector_dabt + stubs_offset
	W(b)	vector_addrexcptn + stubs_offset
	W(b)	vector_irq + stubs_offset
	W(b)	vector_fiq + stubs_offset

	.globl	__vectors_end
__vectors_end:

//阅读下面宏，看看上面的 vector_irq 等，是如何从 vector_\name 解析的
/*
 * Vector stubs.
 *
 * This code is copied to 0xffff0200 so we can use branches in the
 * vectors, rather than ldr's.  Note that this code must not
 * exceed 0x300 bytes.
 *
 * Common stub entry macro:
 *   Enter in IRQ mode, spsr = SVC/USR CPSR, lr = SVC/USR PC
 *
 * SP points to a minimal amount of processor-private memory, the address
 * of which is copied into r0 for the mode specific abort handler.
 */
	.macro	vector_stub, name, mode, correction=0
	.align	5

vector_\name:
	.if \correction
	sub	lr, lr, #\correction
	.endif

	@
	@ Save r0, lr_<exception> (parent PC) and spsr_<exception>
	@ (parent CPSR)
	@
	stmia	sp, {r0, lr}		@ save r0, lr
	mrs	lr, spsr
	str	lr, [sp, #8]		@ save spsr

	@
	@ Prepare for SVC32 mode.  IRQs remain disabled.
	@
	mrs	r0, cpsr
	eor	r0, r0, #(\mode ^ SVC_MODE | PSR_ISETSTATE)
	msr	spsr_cxsf, r0

	@
	@ the branch table must immediately follow this code
	@
	and	lr, lr, #0x0f
 THUMB(	adr	r0, 1f			)
 THUMB(	ldr	lr, [r0, lr, lsl #2]	)
	mov	r0, sp
 ARM(	ldr	lr, [pc, lr, lsl #2]	)
	movs	pc, lr			@ branch to handler in SVC mode
ENDPROC(vector_\name)

	.align	2
	@ handler addresses follow this label
1:
	.endm

	.macro	irq_handler //irq跳转过程中一环
	ldr	r1, =handle_arch_irq //在init_IRQ()函数中设置，接着，在中断
	mov	r0, sp
	adr	lr, BSYM(9997f)
	ldr	pc, [r1]
9997:
	.endm

__irq_svc://irq跳转过程中一环
	svc_entry //Svc_entry主要将cpu相应的寄存器保存到堆栈，并将irq状态中保存的spsr_riq lr_irq等也保存到svc状态下的栈中。
	irq_handler
  //#ifdef CONFIG_PREEMPT
	get_thread_info tsk //取得thread_info结构体，增加preempt计数
	ldr	r8, [tsk, #TI_PREEMPT]		@ get preempt count
	ldr	r0, [tsk, #TI_FLAGS]		@ get flags
	teq	r8, #0				@ if preempt count != 0
	movne	r0, #0				@ force flags to 0
	tst	r0, #_TIF_NEED_RESCHED
	blne	svc_preempt //检查是否能够抢占，如果是，调用 svc_preempt
  //#endif
	svc_exit r5, irq = 1			@ return from exception
 UNWIND(.fnend		)
ENDPROC(__irq_svc)

	.globl	__stubs_start
__stubs_start:
/*
 * Interrupt dispatcher
 */
	vector_stub	irq, IRQ_MODE, 4
  .long	__irq_usr			@  0  (USR_26 / USR_32)
	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)
	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)
	.long	__irq_svc			@  3  (SVC_26 / SVC_32)
  ... //12个 __irq_invalid 类型的
/*
 * Data abort dispatcher
 * Enter in ABT mode, spsr = USR CPSR, lr = USR PC
 */
	vector_stub	dabt, ABT_MODE, 8

	.long	__dabt_usr			@  0  (USR_26 / USR_32)
	.long	__dabt_invalid			@  1  (FIQ_26 / FIQ_32)
	.long	__dabt_invalid			@  2  (IRQ_26 / IRQ_32)
	.long	__dabt_svc			@  3  (SVC_26 / SVC_32)
  ... //12个 __irq_invalid 类型的

/*
 * Prefetch abort dispatcher
 * Enter in ABT mode, spsr = USR CPSR, lr = USR PC
 */
	vector_stub	pabt, ABT_MODE, 4
	.long	__pabt_usr			@  0 (USR_26 / USR_32)
	.long	__pabt_invalid			@  1 (FIQ_26 / FIQ_32)
	.long	__pabt_invalid			@  2 (IRQ_26 / IRQ_32)
	.long	__pabt_svc			@  3 (SVC_26 / SVC_32)
  ... //12个 __irq_invalid 类型的

/*
 * Undef instr entry dispatcher
 * Enter in UND mode, spsr = SVC/USR CPSR, lr = SVC/USR PC
 */
	vector_stub	und, UND_MODE
	.long	__und_usr			@  0 (USR_26 / USR_32)
	.long	__und_invalid			@  1 (FIQ_26 / FIQ_32)
	.long	__und_invalid			@  2 (IRQ_26 / IRQ_32)
	.long	__und_svc			@  3 (SVC_26 / SVC_32)
  ... //12个 __irq_invalid 类型的

/*
 * Undef instr entry dispatcher
 * Enter in UND mode, spsr = SVC/USR CPSR, lr = SVC/USR PC
 */
	vector_stub	und, UND_MODE

	.long	__und_usr			@  0 (USR_26 / USR_32)
	.long	__und_invalid			@  1 (FIQ_26 / FIQ_32)
	.long	__und_invalid			@  2 (IRQ_26 / IRQ_32)
	.long	__und_svc			@  3 (SVC_26 / SVC_32)
  ... //12个 __irq_invalid 类型的

```

### 2.3 中断处理流程
中断的处理流程如下：
1）发生中断时，CPU执行异常向量vector_irq的代码。
2）在vector_irq里面，最终会调用中断处理的总入口函数 asm_do_IRQ
3）asm_do_IRQ()根据中断号调用`irq_desc[]`数组项中的handle_irq。
4）handle_irq会使用chip成员中的函数来设置硬件，比如清楚中断，禁止中断，重新使能中断等。
5）handle_irq逐个调用用户在action链表中注册的处理函数。

```cpp
struct irq_desc {
	struct irq_data		irq_data;
	unsigned int __percpu	*kstat_irqs;
	irq_flow_handler_t	handle_irq;
	struct irqaction	*action;	/* IRQ action list */
	unsigned int		status_use_accessors;
	unsigned int		core_internal_state__do_not_mess_with_it;
	unsigned int		depth;		/* nested irq disables */
	unsigned int		wake_depth;	/* nested wake enables */
	unsigned int		irq_count;	/* For detecting broken IRQs */
	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
	unsigned int		irqs_unhandled;
	raw_spinlock_t		lock;
	struct cpumask		*percpu_enabled;

	unsigned long		threads_oneshot;
	atomic_t		threads_active;
	wait_queue_head_t       wait_for_threads;
	struct proc_dir_entry	*dir;
	int			parent_irq;
	struct module		*owner;
	const char		*name;
} ____cacheline_internodealigned_in_smp;

struct irqaction {
	irq_handler_t		handler; //中断处理函数，注册时提供
	void			*dev_id;//设备id,用来区分中断源
	void __percpu		*percpu_dev_id;
	struct irqaction	*next; //链接共享一个中断的几个action
	irq_handler_t		thread_fn;
	struct task_struct	*thread;
	unsigned int		irq;
	unsigned int		flags;
	unsigned long		thread_flags;
	unsigned long		thread_mask;
	const char		*name;
	struct proc_dir_entry	*dir;
} ____cacheline_internodealigned_in_smp;

//#define preempt_count()	(current_thread_info()->preempt_count) //可以表示是否处于中断处理或者软件中断处理过程中

//对应上面 handle_arch_irq 函数指针
void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)//int_IRQ()函数中配置了gic_handle_irq()为中断服务程序
  struct gic_chip_data *gic = &gic_data[0];
  void __iomem *cpu_base = gic_data_cpu_base(gic);
  while(1) {
    u32 irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);
    u32 irqnr = irqstat & ~0x1c00;
    irqnr = irq_find_mapping(gic->domain, irqnr);
		handle_IRQ(irqnr, regs);
  }

void handle_IRQ(unsigned int irq, struct pt_regs *regs)
  struct pt_regs *old_regs = set_irq_regs(regs);
  irq_enter();
  if (unlikely(irq >= nr_irqs)) {
		if (printk_ratelimit())
			printk(KERN_WARNING "Bad IRQ%u\n", irq);
		ack_bad_irq(irq);
	} else {
		|--> generic_handle_irq(irq);//int generic_handle_irq(unsigned int irq)
      struct irq_desc *desc = irq_to_desc(irq);
      generic_handle_irq_desc(irq, desc); // --> desc->handle_irq(irq, desc);
	}
	|--> irq_exit(); //void irq_exit(void) //中断处理函数退出的时候可能触发tick或者软中断
    account_irq_exit_time(current);
  	sub_preempt_count(HARDIRQ_OFFSET);
  	if (!in_interrupt() && local_softirq_pending())
  		|--> invoke_softirq(); //void invoke_softirq(void)
        if (!force_irqthreads)
          |--> __do_softirq(); //void __do_softirq(void)
            pending = local_softirq_pending();  account_irq_enter_time(current);
            __local_bh_disable((unsigned long)__builtin_return_address(0), SOFTIRQ_OFFSET);
            lockdep_softirq_enter();    cpu = smp_processor_id();
            set_softirq_pending(0);
            local_irq_enable();
            h = softirq_vec;
            do {
                if (pending & 1) {
                  int prev_count = preempt_count(); kstat_incr_softirqs_this_cpu(vec_nr);
                  h->action(h);
                  rcu_bh_qs(cpu);
                }
                h++;    pending >>= 1;
            }while(pending);
  	    else  		wakeup_softirqd();
  	tick_irq_exit();
  	rcu_irq_exit();

	set_irq_regs(old_regs);
```

**每个cpu启动一个ksoftirqd进程**

```cpp
void __init softirq_init(void) {
	int cpu, i;
	for_each_possible_cpu(cpu) {
		per_cpu(tasklet_vec, cpu).tail =
			&per_cpu(tasklet_vec, cpu).head;
		per_cpu(tasklet_hi_vec, cpu).tail =
			&per_cpu(tasklet_hi_vec, cpu).head;
		for (i = 0; i < NR_SOFTIRQS; i++)
			INIT_LIST_HEAD(&per_cpu(softirq_work_list[i], cpu));
	}
	register_hotcpu_notifier(&remote_softirq_cpu_notifier);
	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
}

static void run_ksoftirqd(unsigned int cpu) {
	local_irq_disable();
	if (local_softirq_pending()) {
		__do_softirq();
		rcu_note_context_switch(cpu);
		local_irq_enable();
		cond_resched();
		return;
	}
	local_irq_enable();
}
static struct smp_hotplug_thread softirq_threads = {
	.store			= &ksoftirqd,
	.thread_should_run	= ksoftirqd_should_run,
	.thread_fn		= run_ksoftirqd,
	.thread_comm		= "ksoftirqd/%u",
};
static __init int spawn_ksoftirqd(void) {
	register_cpu_notifier(&cpu_nfb);
	BUG_ON(smpboot_register_percpu_thread(&softirq_threads));
	return 0;
}
early_initcall(spawn_ksoftirqd);
```

## 3 中断 范例

### 3.1 gpio中断
```cpp
//#include <linux/interrupt.h>
//#include <linux/gpio.h>

static int spidev_irq_index = 21;

struct spidev_data {
  //...
  struct semaphore sem;
  int     irq;
};

static irqreturn_t spidev_irq(int irq, void *dev_id)
{
    struct spidev_data	*spidev = dev_id;
    disable_irq_nosync(spidev->irq);
    up(&spidev->sem);

    return IRQ_HANDLED;
}

static int spidev_probe(struct spi_device *spi)
{
  //...
  int rc = 0;
  spidev_irq_index = 21;
  if (gpio_is_valid(spidev_irq_index)) {
		rc = gpio_request(spidev_irq_index, "ts_int");
		if (rc) {
			pr_err("failed request gpio for ts_int\n");
			return -1;
		}
	}
  sem_init(&spidev->sem);
  spidev->irq = gpio_to_irq(spidev_irq_index);
  //INIT_WORK(&spidev->work, gsl_ts_xy_worker);
  rc = request_irq(spidev->irq, spidev_irq, IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, "test", spidev);
  //...
}
```

### 3.2 按键中断

```cpp
//#include <linux/module.h>
//#include <linux/kernel.h>
//#include <linux/fs.h>
//#include <linux/init.h>
//#include <linux/delay.h>
//#include <asm/irq.h>
//#include <linux/interrupt.h>
//#include <asm/uaccess.h>
//#include <asm/arch/regs-gpio.h>
//#include <asm/hardware.h>

//#define DEVICE_NAME "buttons" /* 加载模式后，执行”cat /proc/devices”命令看到的设备名称 */
//#define BUTTON_MAJOR 232 /* 主设备号 */

struct button_irq_desc {
    int irq;
    unsigned long flags;
    char *name;
};

/* 用来指定按键所用的外部中断引脚及中断触发方式, 名字 */
static struct button_irq_desc button_irqs [] = {
    {IRQ_EINT19, IRQF_TRIGGER_FALLING, "KEY1"}, /* K1 */
    {IRQ_EINT11, IRQF_TRIGGER_FALLING, "KEY2"}, /* K2 */
    {IRQ_EINT2, IRQF_TRIGGER_FALLING, "KEY3"}, /* K3 */
    {IRQ_EINT0, IRQF_TRIGGER_FALLING, "KEY4"}, /* K4 */
};

/* 按键被按下的次数(准确地说，是发生中断的次数) */
static volatile int press_cnt [] = {0, 0, 0, 0};

/* 等待队列:
 * 当没有按键被按下时，如果有进程调用s3c24xx_buttons_read函数，
 * 它将休眠
 */
static DECLARE_WAIT_QUEUE_HEAD(button_waitq);

/* 中断事件标志, 中断服务程序将它置1，s3c24xx_buttons_read将它清0 */
static volatile int ev_press = 0;


static irqreturn_t buttons_interrupt(int irq, void *dev_id)
{
    volatile int *press_cnt = (volatile int *)dev_id;

    *press_cnt = *press_cnt + 1; /* 按键计数加1 */
    ev_press = 1; /* 表示中断发生了 */
    wake_up_interruptible(&button_waitq); /* 唤醒休眠的进程 */

    return IRQ_RETVAL(IRQ_HANDLED);
}


/* 应用程序对设备文件/dev/buttons执行open(...)时，
 * 就会调用s3c24xx_buttons_open函数
 */
static int s3c24xx_buttons_open(struct inode *inode, struct file *file)
{
    int i;
    int err;

    for (i = 0; i < sizeof(button_irqs)/sizeof(button_irqs[0]); i++) {
        // 注册中断处理函数
        err = request_irq(button_irqs[i].irq, buttons_interrupt, button_irqs[i].flags,
                          button_irqs[i].name, (void *)&press_cnt[i]);
        if (err)
            break;
    }

    if (err) {
        // 释放已经注册的中断
        i--;
        for (; i >= 0; i--)
            free_irq(button_irqs[i].irq, (void *)&press_cnt[i]);
        return -EBUSY;
    }

    return 0;
}


/* 应用程序对设备文件/dev/buttons执行close(...)时，
 * 就会调用s3c24xx_buttons_close函数
 */
static int s3c24xx_buttons_close(struct inode *inode, struct file *file)
{
    int i;

    for (i = 0; i < sizeof(button_irqs)/sizeof(button_irqs[0]); i++) {
        // 释放已经注册的中断
        free_irq(button_irqs[i].irq, (void *)&press_cnt[i]);
    }

    return 0;
}


/* 应用程序对设备文件/dev/buttons执行read(...)时，
 * 就会调用s3c24xx_buttons_read函数
 */
static int s3c24xx_buttons_read(struct file *filp, char __user *buff,
                                         size_t count, loff_t *offp)
{
    unsigned long err;

    /* 如果ev_press等于0，休眠 */
    wait_event_interruptible(button_waitq, ev_press);

    /* 执行到这里时，ev_press等于1，将它清0 */
    ev_press = 0;

    /* 将按键状态复制给用户，并清0 */
    err = copy_to_user(buff, (const void *)press_cnt, min(sizeof(press_cnt), count));
    memset((void *)press_cnt, 0, sizeof(press_cnt));

    return err ? -EFAULT : 0;
}

/* 这个结构是字符设备驱动程序的核心
 * 当应用程序操作设备文件时所调用的open、read、write等函数，
 * 最终会调用这个结构中的对应函数
 */
static struct file_operations s3c24xx_buttons_fops = {
    .owner = THIS_MODULE, /* 这是一个宏，指向编译模块时自动创建的__this_module变量 */
    .open = s3c24xx_buttons_open,
    .release = s3c24xx_buttons_close,
    .read = s3c24xx_buttons_read,
};

/*
 * 执行“insmod s3c24xx_buttons.ko”命令时就会调用这个函数
 */
static int __init s3c24xx_buttons_init(void)
{
    int ret;

    /* 注册字符设备驱动程序
     * 参数为主设备号、设备名字、file_operations结构；
     * 这样，主设备号就和具体的file_operations结构联系起来了，
     * 操作主设备为BUTTON_MAJOR的设备文件时，就会调用s3c24xx_buttons_fops中的相关成员函数
     * BUTTON_MAJOR可以设为0，表示由内核自动分配主设备号
     */
    ret = register_chrdev(BUTTON_MAJOR, DEVICE_NAME, &s3c24xx_buttons_fops);
    if (ret < 0) {
      printk(DEVICE_NAME " can't register major number\n");
      return ret;
    }

    printk(DEVICE_NAME " initialized\n");
    return 0;
}

/*
 * 执行”rmmod s3c24xx_buttons.ko”命令时就会调用这个函数
 */
static void __exit s3c24xx_buttons_exit(void)
{
    /* 卸载驱动程序 */
    unregister_chrdev(BUTTON_MAJOR, DEVICE_NAME);
}

/* 这两行指定驱动程序的初始化函数和卸载函数 */
module_init(s3c24xx_buttons_init);
module_exit(s3c24xx_buttons_exit);

/* 描述驱动程序的一些信息，不是必须的 */
MODULE_AUTHOR("http://www.100ask.net"); // 驱动程序的作者
MODULE_DESCRIPTION("S3C2410/S3C2440 BUTTON Driver"); // 一些描述信息
MODULE_LICENSE("GPL"); // 遵循的协议
```

### 3.3 设置中断向量表

```cpp
vPortInstallFreeRTOSVectorTable:
	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */
	mrc    p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register
	bic    r0, r0, #0x00002000		@ V = 0
	mcr    p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register

	 /* Set vector address in CP15 VBAR register */
	ldr    r0, =_start
	mcr    p15, 0, r0, c12, c0, 0	 @Set VBAR
	dsb
	isb
```

## 6 嵌入式汇编
### 6.1 基本语法

### 6.2 范例

**使能中断**
```cpp
static inline void arch_local_irq_enable(void)
{
	asm volatile(
		"	cpsie i			@ arch_local_irq_enable"
		:
		:
		: "memory", "cc");
}
static inline unsigned long arch_local_irq_save(void)
{
	unsigned long flags, temp;

	asm volatile(
		"	mrs	%0, cpsr	@ arch_local_irq_save\n"
		"	orr	%1, %0, #128\n"
		"	msr	cpsr_c, %1"
		: "=r" (flags), "=r" (temp)
		:
		: "memory", "cc");
	return flags;
}
```
