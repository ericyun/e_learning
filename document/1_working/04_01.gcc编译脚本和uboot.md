wo  ﻿# 基于BuildRoot集成开发环境

### 修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2017/09/14 | 员清观 | 常用操作索引，尽量简短方便使用 |

----
## 99 处理中问题

buildroot编译控制选项:
- Target options : 目标（也就是制作出来的工具给什么平台使用）
- Build options ：配置（也就是buildroot一些配置项，比如下载的文件放在哪里，编译生成的文件放在哪里等）
- Toolchain：编译器（可以配置生成交叉编译器或者引用已有的交叉编译），如果是配置生成交叉编译器则按照Target options生成对应的编译器。
- System configuration：系统配置（其实就是是否配置制作根文件系统）
- Kernel：存放Linux内核和Linux内核的配置
- Target packages：目标包，简单来说就是里面可以配置生成根文件系统的busybox和其他的一些第三方库，比如：是否支持qt、mplayer等。

哪里定义的：  $(TOPDIR)   $(CONFIG_DIR)   $(BASE_DIR)
当前build路径配置选项
  QSDK Options->App->Busybox lite -- ( ${TOPDIR}/output/product/configs/bblite_defconfig )
  Bootloader->Local source -- ( ${TOPDIR}/bootloader/apollo3 )
  Filesystem image->INITRD overlay directories -- ( ${TOPDIR}/output/product/root )
  Target packages->Busybox version -- ( ${TOPDIR}/output/product/configs/busybox_defconfig )
  Kernel->Local path of linux source -- ( ${TOPDIR}/kernel )
  Kernel->Configuration file path -- ( ${TOPDIR}/output/product/configs/linux_defconfig )
  System Configuration->Path to the permission tables -- ( ${TOPDIR}/output/product/device_table.txt )
  System Configuration->Path to the permission tables -- ( ${TOPDIR}/buildroot/system/ramdisk_device_table.txt )
  System Configuration->Root filesystem overlay directories -- ( $(TOPDIR)/output/product/system )

  System Configuration->Custom scripts to run before creating filesystem images -- ( ${TOPDIR}/tools/prepare-script.sh )
  System Configuration->Custom scripts to run after creating filesystem images -- ( ${TOPDIR}/tools/post-scripts.sh )
  Toolchain->Toolchain path -- ( ${TOPDIR}/buildroot/prebuilts/uclibc-4.7.3 )
  Toolchain->Toolchain prefix -- ( $(ARCH)-buildroot-linux-uclibcgnueabihf )

  Build options->Location to save buildroot config -- ( $(CONFIG_DIR)/defconfig )
  Build options->Download dir -- ( $(TOPDIR)/buildroot/download )
  Build options->Host dir -- ( $(BASE_DIR)/host )
  Build options->Compiler cache location -- ( $(TOPDIR)/.ccache )
  Build options->location of a package override file -- ( $(TOPDIR)/local.mk )

busybox配置：
     debugging, profiling and benchmark --> strace
     shell and utilities --> file
     system tools --> fsck

----
## 1.代码组织

./tools/setproduct.sh 中　make qsdk_defconfig
output/product/root initrd

output目录的介绍：
./product, 当前product的拷贝
./build，下载的软件包，或者本地软件包的拷贝，可能经过工具的修改；无法在此手动修改，编译时自动更新。已经在此接触过的模块有，dosfstools/eventhub/uboot-lite/uboot1-1.0.0/libiconv-1.14。所有源码的编译路径
host目录：存放交叉编译器，如果指定是外部编译器，会把外部编译器拷贝到此处。buildroot编译生成的也是存放在此。
    ~/work/ipc_dev/output/host/usr为交叉工具，可以在host上查询控制目标板上软件
images目录：存放根文件系统的打包好的各个格式，比如：ext，yaffs等…..
target目录：编译出来的根文件系统存放的路径（也就是待会生成根文件系统的路径，用nfs挂载即可）

带videobox的测试：　　./tools/setproduct.sh　，　并且选择apoll3_evb, sensor1 x, sensor0 mipi, jason x

----
## 2.GCC编译选项
**比较完整的选项介绍:**<br>
  https://blog.csdn.net/liuchao1986105/article/details/6674822

几种选项:
- CC 	C编译命令;;  CFLAGS C编译器参数;; CXX C++编译命令;; CXXFLAGS C++编译器参数;; LDFLAGS 链接器参数;; CPPFLAGS C/C++预处理器参数
- CPPFLAGS 这是用于预处理阶段的选项。不过能够用于此变量的选项，看不出有哪个与优化相关。如果你实在想设一个，那就使用下面这两个吧：
  - -DNDEBUG  "NDEBUG"是一个标准的 ANSI 宏，表示不进行调试编译。
  - -D_FILE_OFFSET_BITS=64    大多数包使用这个来提供大文件(>2G)支持。
- CFLAGS 表示用于 C 编译器的选项，CXXFLAGS 表示用于 C++ 编译器的选项。这两个变量实际上涵盖了编译和汇编两个步骤。
- LDFLAGS 链接选项，范例： LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib通知从哪里找库文件;应用方式： LDFLAGS=“$LDFLAGS -L/path/to/lib -L/path/to/lib” 或者 LDFLAGS += -L/path/to/lib -L/path/to/lib。常用选项：
  - -llibrary 	链接时在标准搜索目录中寻找库文件，搜索名为liblibrary.a 或 liblibrary.so
  - -Ldir 	用于把新目录添加到库搜索路径上，可以使用相对和绝对路径，“-L.”、“-L./include”、“-L/opt/include”
  - -Wl,option 	把选项 option 传递给连接器，如果 option 中含有逗号,就在逗号处分割成多个选项
  - -static 	使用静态库链接生成目标文件，避免使用共享库，生成目标文件会比使用动态链接库大
- LIBS 告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv，注意被依赖的库需要放在后头，否则会报告找不到.也可以使用ld的--start-group xxx --end-group来将所有相互依赖的静态库放到xxx位置，只有就能保证search多次了

LDFLAGS是告诉链接器从哪里寻找库文件，而LIBS是告诉链接器要链接哪些库文件。不过使用时链接阶段这两个参数都会加上，所以你即使将这两个的值互换，也没有问题。

LDFLAGS指定-L虽然能让链接器找到库进行链接，但是运行时链接器却找不到这个库，如果要让软件运行时库文件的路径也得到扩展，那么我们需要增加这两个库给"-Wl,R"。 如： LDFLAGS = -L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib。如果在执行./configure以前设置环境变量export LDFLAGS="-L/var/xxx/lib -L/opt/mysql/lib -Wl,R/var/xxx/lib -Wl,R/opt/mysql/lib" ，注意设置环境变量等号两边不可以有空格，而且要加上引号哦（shell的用法）。那么执行configure以后，Makefile将会设置这个选项， 链接时会有这个参数，编译出来的可执行程序的库文件搜索路径就得到扩展了。PS：-Wl,R在GraphicsMagick环境下，用为-R, 也就是LDFLAGS = -L/var/xxx/lib -R/var/xxx/lib。相关内容联系下文中静态库和共享库部分。

./configure可以自动侦测这些变量设置。但是你也可以强制设置这些值。例如： ./configure --prefix ~/usr CC=gcc-3 CPPFLAGS=-I$HOME/usr/include LDFLAGS=-L$HOME/usr/lib

大多数软件包遵守如下约定俗成的规范：
- 1,首先从源代码生成目标文件(预处理,编译,汇编)，"-c"选项表示不执行链接步骤：  $(CC) $(CPPFLAGS) $(CFLAGS) example.c   -c   -o example.o
- 2,然后将目标文件连接为最终的结果(连接)，"-o"选项用于指定输出文件的名字：  $(CC) $(LDFLAGS) example.o   -o example
- 有一些软件包一次完成四个步骤：   $(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) example.c   -o example

gcc and g++分别是gnu的c & c++编译器 gcc/g++在执行编译工作的时候，总共需要4步
- 1.预处理,生成.i的文件[预处理器cpp]
- 2.将预处理后的文件不转换成汇编语言,生成文件.s[编译器egcs]
- 3.有汇编变为目标代码(机器代码)生成.o的文件[汇编器as]
- 4.连接目标代码,生成可执行程序[链接器ld]

### 2.1 GCC常用选项
  -o FILE 生成指定的输出文件。用在生成可执行文件时
  -v 详细输出编译过程中所采用的每一个选项
  -Bstatic 表示部分链接，-Wl，-Bstatic这两个参数一起使用就是告诉ld后面是静态链接，-Wl，-Bdynamic这两个参数一起使用告诉ld后面是动态链接，在man手册中说，如果有必要，这两个参数组合可以写多次，告诉链接器对于不同的库采用不同的方法处理

  -static和-shared可以同时存在，这样会创建共享库，但该共享库引用的其他库会静态地链接到该共享库中

-nostdlib作用： 不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器。这个选项常用于编译内核、bootloader等程序，它们不需要启动文件、标准库文件。C语言程序执行的第一条指令。并不是main函数。生成一个C程序的可执行文件时编译器通常会在我们的代码上加上几个被称为启动文件的代crt1.o,crti.o,crtend.o,crtn.o等，他们是标准库文件。这些代码设置C程序的堆栈等，然后调用main函数。他们依赖于操作系统，在裸板上无法执行，所以我们自己写一个。所以，我们自己写的*.S汇编文件就是一个启动文件，它设置好堆栈后调用main函数。因此，我们不需要系统自带的启动文件

```shell
/home/yuan/work/bak_0_repo/output/host/usr/bin/arm-buildroot-linux-uclibcgnueabihf-ld -Bstatic -T /home/yuan/work/bak_0_repo/output/build/uboot-lite/out/uboot_lite.lds -Ttext 0x08000200 -L -lgcc div0.o  _divsi3.o _udivsi3.o start.o cpu_init.o lowlevel_init.o rballoc.o boot_main.o items.o rtcbit.o board.o imapx800_wdt.o iic.o pwm.o  gdma.o flash_nor_q3f.o flash_nand_q3f.o div64.o timer.o imapx800_sdhc.o mmc.o  iex_e1807be.o dramc.o \
	-Map /home/yuan/work/bak_0_repo/output/build/uboot-lite/out/uboot_lite-spl.map \
	-o /home/yuan/work/bak_0_repo/output/build/uboot-lite/out/uboot_lite-spl
/home/yuan/work/bak_0_repo/output/host/usr/bin/arm-buildroot-linux-uclibcgnueabihf-objcopy --gap-fill=0xff -O binary /home/yuan/work/bak_0_repo/output/build/uboot-lite/out/uboot_lite-spl /home/yuan/work/bak_0_repo/output/build/uboot-lite/out/uboot_lite-spl.bin
```
注意例子中`-Bstatic``-T``-Ttext``-Map`选项，注意`objcopy`命令的参数配置; `-Ttext`在链接的时候将程序入口地址从0重定向到设定的地址，这样，生成的image中指令跳转的地址也会相应变化。这个地址，和image最后加载的地址必须保持一致，保证编译地址和运行地址一致，否则会发生跳转指令执行错误。

**语音标准**<br>
  -ansi 只支持ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词
  -std=c99 -std=c89 一般来说 gcc 3.0 以上都是支持 C99 的但是编译的时候得加上选项
  -std=gnu89   -std=gnu99  -std=gnu9x
  -std=c++98
  -fgnu89-inline 对inline函数使用传统的 GNU 句法
**控制编译过程:**<br>
  -c 只编译并生成目标文件  例子: gcc -c hello.c 生成hello.o的obj文件,而不是可执行文件
  -s 去除可执行文件中的符号表和重定位信息。用于减小可执行文件的大小。
  -S 只激活预处理和编译，就是指把文件编译成为汇编代码。例子用法　gcc -S hello.c, 将生成.s的汇编代码，你可以用文本编辑器察看
  -C 告诉预处理器不要丢弃注释。配合`-E'选项使用.
  -E 只运行C预编译器; -C 在预处理的时候,不删除注释信息,一般和-E使用,有时候分析程序编译错误比较方便
    只激活预处理,这个不生成文件,直接打印,或者你重定向到输出文件. 例子用法:gcc -E hello.c > pianoapan.txt gcc -E hello.c | more
**调试信息**<br>
  -g 编译时生成调试信息。GNU 调试器可利用该信息
  -ggdb 为 GDB 产生调试信息,包含 GDB 的扩展
  -ggdb(level) 设定产生何种等级的调试信息, level 为 1-3, 1 最少,3 最多.
  -w 不生成任何警告信息;
  -Wall 生成所有警告信息
**调试和优化信息**<br>
  -O0 不进行优化处理; -O 或 -O1 优化生成代码; -O2 进一步优化; -O3 比 -O2 更进一步优化，包括 inline 函数
  -Os 专门优化目标文件大小,执行所有的不增加目标文件大小的-O2优化选项.并且执行专门减小目标文件大小的优化选项
  -p 指定生成信息以供prof使用
  -pipe 使用管道代替编译中临时文件,在使用非gnu汇编工具的时候,可能有些问题 ::　gcc -pipe -o hello.exe hello.c
    在编译过程的不同阶段之间使用管道而非临时文件进行通信，可以加快编译速度。建议使用
**库和头文件管理**<br>
  -shared 生成共享目标文件。通常用在建立共享库时,链接的时候要使用-share
  -static 连接禁止使用共享库
  -share  连接将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.
  -Idir 指定额外的头文件搜索路径DIRECTORY; -I- 就是取消前一个参数的功能,所以一般在-Idir之后使用
  -I- 　就是取消前一个参数的功能,所以一般在-Idir之后使用
  -idirafter dir 在-I的目录里面查找失败的话就到这个目录里面查找
  -Ldir 指定额外的函数库搜索路径DIRECTORY; -lLIBRARY 连接时搜索指定的函数库LIBRARY。 -l是链接器选项，必须要放到被编译文件的后面
  -iprefix prefix -iwithprefix dir
  　　一般一起使用,当-I的目录查找失败,会到prefix+dir下查找
  -include file 　包含某个代码,简单来说,就是便以某个文件,需要另一个文件的时候,就可以用它设定,功能就相当于在代码中使用#include
      例子用法: gcc hello.c -include /root/pianopan.h
**编译参数传递**<br>
  -Dmacro       相当于C语言中的#define macro　　
  -Dmacro=defn  相当于C语言中的#define macro=defn
  -Umacro       相当于C语言中的#undef macro
  -undef        取消对任何非标准宏的定义
**misc选项**<br>
  -m32 -m64 生成32位/64位机器上的代码。
  --sysroot=dir 将dir作为逻辑根目录
  -Wa,option 此选项传递option给汇编程序;如果option中间有逗号,就将option分成多个选项,然后传递给会汇编程序
  -Wl.option　此选项传递option给连接程序;如果option中间有逗号,就将option分成多个选项,然后传递给会连接程序
      例如:  LIBRARIES := -Wl,--whole-archive -lchip -Wl,--no-whole-archive -lota -limage, 只有-lchip享受到链接时--whole-archive这个option; 默认情况下，对于未使用到的符号（函数是一种符号），链接器不会将它们链接进共享库和可执行程序。可以启用链接参数“--whole-archive”来告诉链接器，将后面库中所有符号都链接进来，参数“-no-whole-archive”则是重置，以避免后面库的所有符号被链接进来。
  -x language filename 设定文件所使用的语言,使后缀名无效,对以后的多个有效
  -x none filename 关掉上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型
  　　上面两个选项的例子: 　　gcc -x c hello.pig -x none hello2.
  -ftime-reprot 统计编译消耗的时间并显示报告.
  -fmem-report 显示所有的静态内存分配.

**报警信息**<br>
- -ansi 	支持符合ANSI标准的C程序， 该选项强制Gcc生成标准语法所要求的告警信息，尽管这还并不能保证所有没有警告的程序都是符合ANSI C标准的
- -pedantic 	允许发出ANSI C标准所列的全部警告信息
- -pedantic-error 	允许发出ANSI C标准所列的全部错误信息
- -w 	关闭所有告警
- -Wall 	允许发出Gcc提供的所有有用的报警信息
- -werror 	把所有的告警信息转化为错误信息，并在告警发生时终止编译过程
- -Wshadow 	当一个局部变量遮盖住了另一个局部变量，或者全局变量时，给出警告。很有用的选项，建议打开。 -Wall 并不会打开此项。
- -Wpointer-arith 	对函数指针或者void *类型的指针进行算术操作时给出警告。也很有用。 -Wall 并不会打开此项。
- -Wcast-qual 	当强制转化丢掉了类型修饰符时给出警告。 -Wall 并不会打开此项。
- -Waggregate-return 	如果定义或调用了返回结构体或联合体的函数，编译器就发出警告。
- -Winline 	无论是声明为 inline 或者是指定了-finline-functions 选项，如果某函数不能内联，编译器都将发出警告。如果你的代码含有很多 inline 函数的话，这是很有用的选项。
- -Wunreachable-code 	如果编译器探测到永远不会执行到的代码，就给出警告。也是比较有用的选项。
- -Wcast-align 	一旦某个指针类型强制转换导致目标所需的地址对齐增加时，编译器就发出警告。
- -Wundef 	当一个没有定义的符号出现在 #if 中时，给出警告。
- -Wredundant-decls 	如果在同一个可见域内某定义多次声明，编译器就发出警告，即使这些重复声明有效并且毫无差别。

编译源文件时，-v选项会显示所有编译步骤的调试信息,这对于调试诊断或者学习编译过程会有帮助

尽管将源代码编译为二进制文件的四个步骤由不同的程序(cpp,gcc/g++,as,ld)完成，但是事实上 cpp, as, ld 都是由 gcc/g++ 进行间接调用的。换句话说，控制了 gcc/g++ 就等于控制了所有四个步骤。从 Makefile 规则中的编译命令可以看出，编译工具的行为全靠 CC/CXX CPPFLAGS CFLAGS/CXXFLAGS LDFLAGS 这几个变量在控制。当然理论上控制编译工具行为的还应当有 AS ASFLAGS ARFLAGS 等变量，但是实践中基本上没有软件包使用它们。那么我们如何控制这些变量呢？一种简易的做法是首先设置与这些 Makefile 变量同名的环境变量并将它们 export 为全局，然后运行 configure 脚本，大多数 configure 脚本会使用这同名的环境变量代替 Makefile 中的值。但是少数 configure 脚本并不这样做(比如GCC-3.4.6和Binutils-2.16.1的脚本就不传递LDFLAGS)，你必须手动编辑生成的 Makefile 文件，在其中寻找这些变量并修改它们的值，许多源码包在每个子文件夹中都有 Makefile 文件，真是一件很累人的事！

**如何包含库**<br>
放在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接了，但如果库文件没放在这三个目录里，而是放在其他目录里，这时我们只用-l参数的话，链接还是会出错，出错信息大概是：“/usr/bin/ld: cannot find -lxxx”，也就是链接程序ld在那3个目录里找不到libxxx.so，这时另外一个参数-L就派上用场了，比如常用的X11的库，它放在/usr/X11R6/lib目录下，我们编译时就要用-L/usr/X11R6/lib -lX11参数，-L参数跟着的是库文件所在的目录名。再比如我们把libtest.so放在/aaa/bbb/ccc目录下，那链接参数就是-L/aaa/bbb/ccc -ltest
手工来写链接参数总是很麻烦的，还好很多库开发包提供了生成链接参数的程序，名字一般叫xxxx-config，一般放在/usr/bin目录下，比如gtk1.2的链接参数生成程序是gtk-config，执行
`gtk-config –libs` 就能得到以下输出  `“-L/usr/lib -L/usr/X11R6/lib -lgtk -lgdk -rdynamic -lgmodule -lglib -ldl -lXi -lXext -lX11 -lm”`
这就是编译一个gtk1.2程序所需的gtk链接参数，xxx-config除了`–libs`参数外还有一个参数是`–cflags`用来生成头文件包含目录的，也就是-I参数，在下面我们将会讲到。你可以试试执行gtk-config –libs –cflags，看看输出结果。现在的问题就是怎样用这些输出结果了，最笨的方法就是复制粘贴或者照抄，聪明的办法是在编译命令行里加入这个xxxx-config --libs --cflags，比如编译一个gtk程序：gcc gtktest.c gtk-config --libs --cflags这样就差不多了。注意`不是单引号，而是1键左边那个键。

除了xxx-config以外，现在新的开发包一般都用`pkg-config`来生成链接参数，使用方法跟xxx-config类似，但xxx-config是针对特定的开发包，但`pkg-config`包含很多开发包的链接参数的生成，用`pkg-config –list-all`命令可以列出所支持的所有开发包，`pkg-config`的用法就是pkg-config pagName –libs –cflags，其中pagName是包名，是pkg-config -list-all里列出名单中的一个，比如gtk1.2的名字就是gtk+，`pkg-config gtk+ –libs –cflags`的作用跟gtk-config –libs –cflags是一样的。比如：gcc gtktest.c pkg-config gtk+ --libs --cflags。

**--whole-archive选项**
--whole-archive选项解决的是编译中常遇到的问题。在代码中定义的符号（如函数名）还未使用到之前，链接器并不会把它加入到连接表中。如下面这个例子：

```cpp
//a.cpp:
void func() {
  printf("I am in a.cpp.\n");
}
//main.cpp:
extern void func();
int main() {
  func(); printf("I am in main.cpp"); return 0;
}
//首先编译g++ -c a.cpp，再打包ar -r liba.a a.o; 如果这么链接g++ -L. -la main.cpp -o main，则链接器会报错，称func()未定义。其实改一下顺序既可以解决g++  main.cpp -L. -la -o main, 或者使用g++ -Wl,--whole-archive -L. -la -Wl,--no-whole-archive main.cpp -o main，将liba.a中的所有.o中的符号都链接进来
```

### 2.2 最简单通用方便的makefile范例

```cpp
cc = gcc
prom = kernimage
deps = $(shell find ./ -name "*.h")
src = $(shell find ./ -name "*.c")
obj = $(src:%.c=%.o)
obj_s = $(src:%.S=%.o)

$(prom): $(obj)
    $(cc) -o $(prom) $(obj)

%.o: %.c $(deps)
    $(cc) -c $< -o $@


.PHONY : clean
clean:
    rm -rf $(obj) $(prom)
```
在这里，我们用到了几个特殊的宏。首先是%.o:%.c，这是一个模式规则，表示所有的.o目标都依赖于与它同名的.c文件（当然还有deps中列出的头文件）。`$(src:%.c=%.o)`是一个字符替换函数，它会将src所有的.c字串替换成.o，实际上就等于列出了所有.c文件要编译的结果. 再来就是命令部分的$<和$@，其中$<代表的是依赖关系表中的第一项（如果我们想引用的是整个关系表，那么就应该使用$^），具体到我们这里就是%.c。而$@代表的是当前语句的目标，即%.o。这样一来，make命令就会自动将所有的.c源文件编译成同名的.o文件。

.PHONY意思表示clean是一个“伪目标” ; 而且,clean从来都是放在文件的最后

### 2.3.LDFLAGS选项


### 2.4.GCC分析工具
**本章全面解析下面内容:**<br>
  https://www.cnblogs.com/yangguang-it/category/942568.html
  https://www.cnblogs.com/cjjnjust/articles/1617086.html //包含有lds文件格式信息

```cpp
arm-buildroot-linux-uclibcgnueabihf-addr2line  arm-buildroot-linux-uclibcgnueabihf-g++        arm-buildroot-linux-uclibcgnueabihf-gprof     arm-buildroot-linux-uclibcgnueabihf-ranlib     arm-buildroot-linux-uclibcgnueabihf-ar         arm-buildroot-linux-uclibcgnueabihf-gcc         arm-buildroot-linux-uclibcgnueabihf-ld         arm-buildroot-linux-uclibcgnueabihf-readelf    arm-buildroot-linux-uclibcgnueabihf-as         arm-buildroot-linux-uclibcgnueabihf-gcc-4.7.3  arm-buildroot-linux-uclibcgnueabihf-ld.bfd     arm-buildroot-linux-uclibcgnueabihf-size
arm-buildroot-linux-uclibcgnueabihf-c++        arm-buildroot-linux-uclibcgnueabihf-gcc-ar     arm-buildroot-linux-uclibcgnueabihf-ldconfig  arm-buildroot-linux-uclibcgnueabihf-strings    arm-buildroot-linux-uclibcgnueabihf-cc         arm-buildroot-linux-uclibcgnueabihf-gcc-nm      arm-buildroot-linux-uclibcgnueabihf-ldd        arm-buildroot-linux-uclibcgnueabihf-strip      arm-buildroot-linux-uclibcgnueabihf-c++filt    arm-buildroot-linux-uclibcgnueabihf-gcc-ranlib arm-buildroot-linux-uclibcgnueabihf-nm         arm-buildroot-linux-uclibcgnueabihf-cpp        arm-buildroot-linux-uclibcgnueabihf-gcov       arm-buildroot-linux-uclibcgnueabihf-objcopy    arm-buildroot-linux-uclibcgnueabihf-elfedit    arm-buildroot-linux-uclibcgnueabihf-gdb        arm-buildroot-linux-uclibcgnueabihf-objdump
```
//## hexdump -C ./fsck.fat

**nm**<br>
nm用于列出程序文件中的符号. nm的第一列是指程序运行时符号在内存中的地址，它表示函数或变量的开始地址；第二列是指相应的符号放在哪个段，最后一列则是符号的名称。 nm列出的符号有很多， 常见的有三种：
- T类：是在库中定义的函数，用T表示，这是最常见的；
- U类：是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；
- W类：是所谓的“弱态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。

```  cpp
  nm boot_main.o //未链接,0地址开始,反映相对映射
  nm -rnl uboot_lite-spl // n按地址排序,否则按字母排序;r为反转排序;l尝试为每个符号找到文件和行号;

```
**addr2line**<br>
  addr2line 0x080008d4 -e uboot_lite-spl -a -f //a:结果中显示地址, f:结果中显示函数名, e:哪个目标文件
**ar**<br>
  ar crs libmy.a foo.o bar.o //c参数表示创建一个档案文件，而r参数指示将文件增加到所创建的库文件中，s参数就是为了生成库索引以提高库被链接时的效率
  ar t libmy.a //查看库的组成内容
**size查看各段大小**<br>
  size boot_main.o       size  -A uboot_lite-spl//显示更详细的信息
**strip uboot_lite-spl精简目标文件**<br>
**objdump**<br>
  objdump -f uboot_lite-spl //显示头信息
  objdump -a uboot_xx.a     //显示lib中包含那些obj
  objdump -x uboot_lite-spl //显示目标文件的所有头的信息，包括ELF文件头、程序头（Program Header）和节头（Section Header）。除了这些头之外，还包括动态节区（Dynamic Section）和符号表（Symbol Table）内的信息
  objdump -a boot_main.o //头部
  objdump -d boot_main.o //反汇编代码段, 需要编译时候指定-g
  objdump -D boot_main.o //反汇编全部
  objdump -S boot_main.o //源码+反汇编交叉,协助分析和学习
  objdump -s boot_main.o //二进制，同时显示对应的asc信息
  objdump -p boot_main.o //头部
  objdump -t boot_main.o //符号表
  objdump -T boot_main.o  //输出目标文件的动态符号表（Dynamic Symbol Table），即目标ELF文件中名字叫做.dynsym节内的内容
  objdump -h uboot_lite-spl //查看所有节点信息
  objdump -f uboot_lite-spl //显示文件头信息
  objdump -r dramc.o  //显示目标文件的静态重定位入口
  objdump -R dramc.o  //显示目标文件的动态重定位入口，这个参数仅仅对于动态目标文件有意义，比如动态库文件（.so）。
**objcopy**<br>
  objcopy -O binary uboot_lite.bin uboot_lite-spl
**string**<br>
  string boot_main.o      string uboot_lite-spl //显示所有的字符串和变量名，函数名等。
**readelf**<br>
  readelf -a uboot_lite-spl   //显示所有elf信息
  readelf -h uboot_lite-spl
  readelf -l uboot_lite-spl   //显示头表信息
  readelf -e uboot_lite-spl   //显示所有头信息
  readelf -S uboot_lite-spl   //显示Section Headers
  readelf -t uboot_lite-spl   //显示Section Headers
  readelf -s uboot_lite-spl   //显示symble
  readelf -r dramc.o  //显示目标文件的静态重定位入口
  readelf -R dramc.o  //显示目标文件的动态重定位入口，这个参数仅仅对于动态目标文件有意义，比如动态库文件（.so）
  ~/work/bak_f_repo/output/host/usr/bin/arm-buildroot-linux-uclibcgnueabihf-readelf -x .text uboot_lite-spl
**a**<br>

objdump -p ./fsck.fat

patch文件制作和使用场景：
cd buildroot-2009.11
patch -p1 < ../buildroot-2009.11.patch

redmine 的comment中，#4423 前后用空格区分开，可以显示bug的索引链接。


## 3 头文件和库

### 3.1 头文件
```cpp
//#include "stdio.h"
//#include <stdio.h>
//前者表示优先在当前程序目录中查找，后者是直接到标准路径中搜索。所以如果是自定义的头文件，应该使用双引号。
//一般linux中标准路径： /usr/include，/usr/local/include 等
//交叉编译环境下，应该包含了 arch/arm/include对应<asm/setup.h>等 include对应<linux/kernel.h>等 arch/arm/mm对应mm.h等
```
gcc寻找头文件的路径(按照1->2->3的顺序)：
- 1. 在gcc编译源文件的时候，通过参数-I指定头文件的搜索路径，如果指定路径有多个路径时，则按照指定路径的顺序搜索头文件。命令形式如：“gcc -I /path/where/theheadfile/in sourcefile.c“，这里源文件的路径可以是绝对路径，也可以是相对路径。eg：设当前路径为/root/test，include_test.c如果要包含头文件“include/include_test.h“，有两种方法：1) include_test.c中#include “include/include_test.h”或者#include "/root/test/include/include_test.h"，然后gcc include_test.c即可; 2) include_test.c中#include 或者#include ，然后gcc –I include include_test.c也可
- 2. 通过查找gcc的环境变量 C_INCLUDE_PATH / CPLUS_INCLUDE_PATH / OBJC_INCLUDE_PATH来搜索头文件位置。
- 3. 再找内定目录搜索，分别是 /usr/include  /usr/local/include /usr/lib/gcc-lib/i386-linux/2.95.2/include，最后一行是gcc程序的库文件地址，各个用户的系统上可能不一样。gcc在默认情况下，都会指定到/usr/include文件夹寻找头文件。gcc还有一个参数：-nostdinc，它使编译器不再系统缺省的头文件目录里面找头文件，一般和-I联合使用，明确限定头文件的位置。在编译驱动模块时，由于非凡的需求必须强制GCC不搜索系统默认路径，也就是不搜索/usr/include要用参数-nostdinc，还要自己用-I参数来指定内核头文件路径，这个时候必须在Makefile中指定。
- 4. 当#include使用相对路径的时候，gcc最终会根据上面这些路径，来最终构建出头文件的位置。如`#include <sys/types.h>` 就是包含文件`/usr/include/sys/types.h`

----
### 3.2. 静态库和共享库

默认情况下使用动态方式链接，这要求存在对应的.so动态库文件，如果不存在，则寻找相应的.a静态库文件。若在编译时向gcc传入-static选项，则使用静态方式链接，这要求所有库文件都必须有对应的*.a静态库。

编译选项：
- -v 链接阶段，可以向gcc加入-v选项来观察它向linker传递的库文件查找路径。gcc -v 命令可以看到完整的configure选项。例如我现在的机器上，使用gcc -v可以看到LIBRARY_PATH变量值为： LIBRARY_PATH=/usr/lib/gcc/i686-redhat-linux/4.5.1/:/usr/lib/。
-

理论上说，使用ELF格式的静态库函数生成的代码可以比使用共享函数库（或者动态函数库）的程序运行速度上快一些，大概1－5％。

**链接阶段动态库查找路径**<br>
在linux中，在链接阶段，动态库(又叫共享库)的查找路径如下：
- 任何由-rpath-link或-rpath选项指定的目录 ： -rpath-link与-rpath选项的区别在于，-rpath选项指定的目录被硬编码到可执行文件中，运行时不需要读取别的配置文件获取，-rpath-link选项指定的目录只在链接阶段生效。由于这两个选项都是链接器ld的选项，如何从gcc中向ld传递这两个选项？方法如下（更从细节参考gcc的-Wl选项）： gcc -Wl, -rpath=/usr/local/lib 这相当于向ld向传递了如下参数：ld -rpath /usr/local/lib
- LD_RUN_PATH （如果没有找到-rpath或-rpath-link选项）：如果没有设置-rpath或-rpath-link选项，则查找LD_RUN_PATH环境变量指定的目录，并把它当作-rpath选项来处理
- -Ldir1 -Ldir2 ... ： 是我们通过gcc的-L选项向其指定的库文件查找路径，查找顺序按照我们传递的-L参数从左到右进行搜索
- /usr/lib/gcc/ ： gcc自己的库目录， gcc自动传递给linker
- /usr/lib/ ： Linux系统默认的系统库文件的目录， gcc自动传递给linker
- 一个问题：gcc会把/usr/local/lib/目录也作为链接阶段的查找路径，这正是问题的根源——我们在链接过程中，使用到了/usr/local/lib/里面的一些库文件，但在运行时阶段，却说找不到该库文件。

现代连接器在处理动态库时将链接时路径（Link-time path）和运行时路径（Run-time path）分开，用户可以通过-L指定链接时库的路径，通过-R（或-rpath）指定程序运行时库的路径，大大提高了库应用的灵活性. 如果出现共享库链接失败，用ldd 命令可以查看可执行文件在执行时所依赖的所有动态库

**运行阶段动态库查找路径**
仅当可执行程序采用动态的方式链接库文件时，才会存在运行时库文件的查找问题。对于这种可执行程序，它本身只是记录动态库的名称。所以在运行该程序时，操作系统的加载程序（ld.so）需要根据库的名称，在必要时加载库文件到内存中。运行阶段，动态库(又叫共享库)的查找路径如下：
- 编译目标代码时指定的动态库搜索路径：在编译的时候指定-Wl,-rpath=路径 或者-Wl,-R路径： 可以通过readelf查看被硬编码到可执行文件中的rpath：$ readelf -d <可执行文件名>
- 环境变量LD_LIBRARY_PATH指定的动态库搜索路径 ： 通常我们不建议使用这个环境变量，因为修改这个变量意味着影响所有依赖于这个环境变量的程序
- 配置文件/etc/ld.so.conf中指定的动态库搜索路径
- /lib然后/usr/lib
- 系统默认的查找路径

**裁剪不必要的so**
linux从程序（program或对象）变成进程（process或进程），要经过哪些步骤呢，这里如果详细的说，估计要另开一篇文章。可以跟踪strace启动程序过程，分三步： 1、fork进程，在内核创建进程相关内核项，加载进程可执行文件； 2、查找依赖的so，一一加载映射虚拟地址 3、初始化程序变量。可以看到，第二步中dll依赖越多，进程启动越慢，并且发布程序的时候，这些链接但没有使用的so，同样要一起跟着发布，否则进程启动时候，会失败，找不到对应的so。所以我们不能像上面那样，把一些毫无意义的so链接进来，浪费资源。可以用两种办法去除不必要的so：1.使用 ldd -u demo 查看不需要链接的so，然后可以手动消灭；2.使用 -Wl,--as-needed 编译选项，如 `# g++ -Wl,--as-needed -o demo -lz -lm -lrt main.cpp`

创建一个静态函数库文件，或者往一个已经存在地静态函数库文件添加新的目标代码，可以用下面的命令： `ar rcs my_library.a file1.o file2.o` r：表示将.o目标文件加入到静态库中；c：表示创建静态库;s：表示生产索引；。这个例子中是把目标代码file1.o和file2.o加入到my_library.a这个函数库文件中，如果my_library.a不存在则创建一个新的文件。在用ar命令创建静态库函数的时候，还有其他一些可以选择的参数，可以参加ar的使用帮助。一旦你创建了一个静态函数库，你可以使用它了。你可以把它作为你编译和连接过程中的一部分用来生成你的可执行代码。如果你用gcc来编译产生可执行代码的话，你可以用“-l”参数来指定这个库函数。你也可以用ld来做，使用它的“-l”和“-L”参数选项。具体用法可以参考`info gcc`。

**动态加载程序**<br>

| 函数原型 |   说明 |
| --- |
| const char *dlerror(void)  | 当动态链接库操作函数执行失败时，dlerror可以返回出错信息，返回值为NULL时表示操作函数执行成功。  |
| void *dlopen(const char *filename, int flag)  | 用于打开指定名字（filename）的动态链接库，并返回操作句柄。调用失败时，将返回NULL值，否则返回的是操作句柄。  |
| void *dlsym(void *handle, char *symbol) |  根据动态链接库操作句柄（handle）与符号（symbol），返回符号对应的函数的执行代码地址。由此地址，可以带参数执行相应的函数。 |
|  int dlclose (void *handle) |  用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为0时，才会真正被系统卸载。2.2在程序中使用动态链接库函数。 |

**-fPIC**<br>
Linux下编译共享库时(`-shared`)，必须加上`-fPIC`参数，否则在链接时会有错误提示
```cpp
//#include <stdio.h>
int func1(int a) {
    printf("haha a=%d\n", 2);     a++;    return a;
}
编译命令:
  gcc -fPIC -shared test.c -o lib.so
  //或者:
  gcc -fPIC test.c -c -o test.o
  ld -shared -o lib.so test.o -I 头文件路径
  gcc -shared test.so test.o 指令可以生成动态连接库test.so
  规则定义： # 1) 生成与位置无关的代码(.o文件). gcc -fPIC -c *.c -I /头文件路径 # 生产与位置无关的.o文件. # 2) 将.o打包成共享库(动态库) gcc -shared -o lib*.so *.o -I 头文件路径名.

 使用共享库两种方法: 1：gcc main.c lib*.so -I 头文件路径 -o 可执行文件名. 2：gcc main.c -I 头文件路径 -L 库所在的目录 -l 库的名字(去掉lib和.so) -o 可执行文件名字.
编译静态库： 1： ar -v -q test.a test.o  指令可以生成静态链接库test.a 2： ar cvr test.a test.o
使用静态库： gcc -static test.a main.c -o mytest
    gcc -o 可执行文件 调用者的C源文件.c  -Ldir -l库文件名 //-Ldir：表示指定库文件所在的路径中，默认在库路径在/usr/lib目录下；-lname：表示库目录的库文件libname.a或libname.so。如果库文件不是以lib开头，如hello.a，只能用用hello.a，不能用-lhello。
```
fPIC的目的是什么？共享对象可能会被不同的进程加载到不同的位置上，如果共享对象中的指令使用了绝对地址、外部模块地址，那么在共享对象被加载时就必须根据相关模块的加载位置对这个地址做调整，也就是修改这些地址，让它在对应进程中能正确访问，而被修改到的段就不能实现多进程共享一份物理内存，它们在每个进程中都必须有一份物理内存的拷贝。fPIC指令就是为了让使用到同一个共享对象的多个进程能尽可能多的共享物理内存，它背后把那些涉及到绝对地址、外部模块地址访问的地方都抽离出来，保证代码段的内容可以多进程相同，实现共享

真正的问题在于，一个进程会在自己的进程空间中（虚拟地址空间）加载多个共享库，若未采用 -fPIC ，那么各个共享库内的地址（会采用绝对地址）就可能发生冲突，因为在编译共享库的时候，是不会假设还有其他共享库存在的。这个问题在传统共享库概念中是无法避免的。虚拟地址空间在这个问题上起不了作用。如果可执行程序不需要进行共享库的链接，那么我们总是可以将相同的虚拟地址赋予相同的 asm 指令，而不会导致任何问题。 但是，当想要链接共享库到可执行程序时，我们无法确定共享库（在进程空间）的起始地址，因为这取决于所链接的其他共享库。这也就是说，.so 内的 asm 指令将总是被赋予不同的虚拟地址，具体取决于可执行程序链接了哪些共享库（以及链接顺序）。

使用 gcc -shared test.c -o lib.so 编译将报错,但改成下面这样去掉printf, 或者增加-fPIC就能编译通过:

另外一个例子:
gcc -o libJava.so       \ #. 显示指定目标文件名. 否则就是a.out啦
   -shared -fPIC     \ #. 编译共享库的参数(组定搭档). 否则就没有“main”报错喽
   a.o b.o c.o          \ #. 由原代码a.c b.c c.c编译出来的一堆东东集中在一块
   ./libdemo.a          \ #. 依赖其它的一些lib库
   -ldl -lpthread      \ #. 依赖的系统共享库 对应libdl.so, libpthread.so (这里是举个例了，当然你的程序可能不需要哈)

上面几个文件中的函数才会被封装到库中，所以，hlibvideodebug链接找不到需要的audio函数是因为函数放在了错误的文件中，不要理解错误。
文档整理所有的编译相关的信息

**另外一个供参考的范例**<br>
```shell
CC = gcc
DEBUG = -g -Wall
LIB = -ldl
RUNSO = $(CC) -fPIC -shared -o $@ $^
RUN = $(CC) $(DEBUG) -o $@ $^

//#总的任务
all:libheoo.so libheootwo.so libheoothree.so main.out

//#简单lib%.so生成
libheoo.so:heoo.c
    $(RUNSO)
libheootwo.so:heootwo.c
    $(RUNSO)
libheoothree.so:heoothree.c
    $(RUNSO)

//#生成的主要内容
main.out:main.c
    $(RUN) $(LIB)

//# 简单的清除操作 make clean
.PHONY:clean
clean:
    rm -rf *.so *.s *.i *.o *.out *~ ; ls -hl
```

### 3.3 常见的iconv链接失败问题
  libiconv库链接问题一则:
    https://tonybai.com/2013/04/25/a-libiconv-linkage-problem/

这问题和头文件和库文件的搜索顺序有关，首先找到的是/usr/local/include/iconv.h的话，就需要链接libiconv.a；否则先找到/usr/include/iconv.h，就是用glibc的定义。这是因为前者包含下面定义：
```cpp
//#ifndef LIBICONV_PLUG
//#define iconv_open libiconv_open
//#endif
```
如果希望强制使用glibc的接口，那么需要预编译的时候定义 LIBICONV_PLUG 宏。

我们 通过执行下面命令可以知晓ld的默认搜索路径： ``
```
$> ld -verbose|grep SEARCH  //PC
SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu"); SEARCH_DIR("=/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/lib64"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib64"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib");

$> ./arm-buildroot-linux-uclibcgnueabihf-ld -verbose|grep SEARCH   //q3f EVB
SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib");
```

 #include "…" 搜索从这里开始：
 #include <…> 搜索从这里开始：
 /usr/local/include
 /usr/lib/gcc/x86_64-redhat-linux/4.1.2/include
 /usr/include

ldd 命令查看实际链接的so；gcc编译时候增加-v选项，打印链接详尽过程。

conv 方法在glibc和libiconv中都有实现，若安装了libiconv 则需要增加-liconv显式连接
或者makefile中预编译选项 CCFLAGS或CPPFLAGS 增加 LIBICONV_PLUG 会使用glibc
或者直接在找到的iconv.h头文件中增加 LIBICONV_PLUG 定义
或者强行卸载掉libiconv，使用glibc版本


----
## 4. ARM伪指令和伪操作

### 4.1 GNU汇编书写格式
注释符：`@和#`  语句分离符： `；`  立即数前缀： `#或$`<br>
段内标号的地址值在汇编时确定; 段外标号的地址值在连接时确定<br>

局部标号：主要在局部范围内使用而且局部标号可以重复出现。它由两部分组成，开头是一个直接的数字局部标号，如99，后面加`:`,如`66:`;在跳转时，根据所加后缀不一样，跳转方向不一样。
- f代码地址增加的方向;b代码地址减少的方向,例：`b 99f` `b 99b`
- 就近原则:
  `.`代表当前行。  例：`b .`相当于`while(1)`

### 4.2 ARM伪指令
- ADR    为小范围的地址读取伪指令
- ADRL   为中等范围的地址读取伪指令
- ‹LDR   为大范围的地址读取伪指令.
- ‹NOP   为空操作伪指令<br>
  注：ldr伪指令的实质：`LDR Rd，=const`, `const`如果是有效数，会翻译成`MOV Rd，mvn`; 如果const不是一个有效数，是把要放进寄存器的立即数存储到一个内存地址中，然后将ldr伪指令翻译成一条ldr指令，然后从该地址中读取这个立即数. `adr和adrl`伪指令的实质：是将基于PC的相对偏移地址值存放到寄存器中
```cpp
  ldr    r0，=myarry             @ 取标号所在的地址   绝对地址装载l；
  反汇编：ldr   r0, [pc, #64]     @pc+64地址里存放的时标号的地址
  ldr   r1,=0x666666
  反汇编：ldr   r1，[pc, #56]     @pc+56地址里存放0x666666
  ldr r0，myarry             @ 取标号所在地址的里面的值；注：这个不是伪指令
  反汇编：ldr   r0，[pc, #4]      @pc+4就是标号的地址，然后从标号的地址里取值

  adr r0，myarry             @ 取标号所在的地址   相对pc的偏移量
  反汇编：add   r0，pc，#6        @pc+6就是标号所在的地址
  adrl r0，myarry             @ 取标号所在的地址   相对pc的偏移量
  反汇编：add   r0，pc， #8       @pc+6就是标号所在的地址
```


### 4.3 GNU编译环境下的伪操作和宏指令
**常量编译控制伪操作 :**<br>
.byte                                 定义单字节数据

例：  .byte     0x12,'a',23

.hword/.short       定义双字节数据

例：  .short    0x1234,0x6666

.word/.long /.int     定义4字节数据

例：  .word    0x12345678

.quad                   定义8字节数据

例： .quad    0x1234567812345678

.float/.single        定义32bit 浮点数

例：.float     0f3.2

.double                定义64bit浮点数

例：

.ascii                     定义字符串以/0为结束符

例： .ascii    "hello\0"

.asciz /.string       定义字符串（非零结束符）

例： .string   "hello"

.fill                        分配一段字节内存单元，用size长度value填充repeat次

例：  .fill   10,2,6    将两个字节长度的6重复填充10次

.zero                    分配一段字节内存单元，并用0填充内存

例：  .zero  10   分配十个字节单元，并用0填充

.space/.skip        分配一段内存单元，用value将内存单元初始化

例：  .space  10,6  分配十个字节单元，并用6填充

**汇编程序代码控制伪操作**
.arm/.code32         定义以下代码使用ARM指令集
.thumb/.code16    定义以下代码使用Thumb指令集
.arch                        cpu的架构
例：.arch armv7-a
.fpu                          软件浮点
例：.fpu softvfp

.section                  定义一个段

例： .section    expr  ；expr可以是.text，.data，.bss

.text                         将定义符开始的代码编译到代码段

.data                       将定义符开始的数据编译到数据段

.bss                         将变量存放到.bss段

.align                      通过用零或或指定的数据进行填充来使当前位置满足一定的对齐方式，2的权次方对齐

例： .align 1  2个字节对齐
         .align 3  8个字节对齐

.type                       说明一个类型

例：.type   b，%object     #用来说明b的类型，%object是数据类型   %function 函数类型

.size                       占用内存的大小

例：.size   b，2                #字符占用内存的大小

.org指定从当前地址加上offset开始存放代码，并且从当前地址到当前地址加上offset之间的内存单元，用零或指定的数据进行填充

例：.org    offset

.global/.globl         用来定义一个全局的符号

例：.global    main

.include                   将一个源文件包含到当前源文件中

例：.include     "filename"

.end                        标记汇编文件的结束行，即标号后的代码不作处理

_start                     汇编程序的缺省入口是_start标号，用户也可以在链接脚本文件中用ENTRY标志指明其他入口点

**宏及条件编译控制伪操作**<br>
.macro .exitm及.endm     .macro伪操作标识宏定义的开始，.endm标识宏定义的结束。exitm伪操作用于提前退出宏。
例：
```cpp
  .macro 宏名 参数名列表     #伪指令.macro定义一个宏
    宏体
  .endm                    #.endm表示宏结束
```
如果宏使用参数,那么在宏体中使用该参数时添加前缀`\`。宏定义时的参数还可以使用默认值
```cpp
  .macro SHIFTLEFT a, b
  .if  \b < 0
  MOV  \a, \a, ASR #\b
  .exitm
  .endif
  MOV  \a, \a, LSL #\b
  .endm
```
ifdef，.else及.endif    当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。其中else可以缺省。
```cpp
.ifdef  condition
…
.else
…
.endif

.equ is,5
.if is
mov r2,r3
.endif

```
**其他伪操作**<br>
```cpp
.rept   重复定义伪操作
.rept 重复次数
  数据定义
.endr @结束重复定义

.rept 3
  .byte 0x23
.endr
//注：必须放在代码最后
```
.equ/.set:        赋值语句，把某一个符号名定义成一个值，该指令并不分配空间。有点像c语言的#define
例：.equ abc，3     #编译时，将abc替换为3
.title：            用来指定汇编列表的标题
例： .title “my program”
.list                 产生汇编列表（从 .list 到 .nolist）

.nolist             表示汇编列表结束处。

.req                用来给寄存器赋予别名

例：rr  .req  r0    定义寄存器r0的别名为rr

 .unreq          用来取消一个寄存器的别名
例：.unreq rr    取消定义的寄存器别名
注意被取消的别名必须事先定义过,否则编译器就会报错,这个伪操作也可以用来取消系统预制的别名, 例如r0, 但如果没有必要的话不推荐那样做。

.ltorg/.pool    用于声明一个数据缓冲池(literal pool)的开始,它可以分配很大的空间。
注：

    在使用LDR伪指令时,要在适当的地址加入 ltorg 声明 数据缓冲池 ,这样就会把要加载的数据保存在 数据缓冲池 内,再用ARM的加载指令读出数据.(若没有使用 .ltorg 声明文字池,则汇编器会在程序末尾自动声明.)
    如果把数据缓冲池放在两条无跳转指令之间，处理器会错误的把数据缓冲池中的数据当做指令执行，所以ltorg伪指令常放在无条件跳转指令之后，或者子程序返回指令之后，总之不能让程序执行到数据缓冲池的地址。这样处理器就不会错误地将数据缓冲池中的数据当作指令来执行
    根据所需数据缓冲的大小，.ltorg每次分配的数据缓冲区大小不一样

----
## 5.uboot基础

**两种uboot重定位方法**<br>
u-boot在启动过程中，会把自己拷贝到RAM的顶端去执行。这一拷贝带来的问题是执行地址的混乱。代码的执行地址通常都是在编译时有链接地址指定的，如何保证拷贝前后都可以执行呢？1.一个办法是使用拷贝到RAM后的地址作为编译时的链接地址，拷贝前所有函数与全局变量的调用都增加偏移量。（如我们当前的bootloader）尽量减少拷贝前需要执行的代码量。2.另一个办法是把image编译成与地址无关的程序，也就是PIC - Position independent code。编译器无法保证代码的独立性，它需要与加载器配合起来。U-boot自己加载自己，所以它自己就是加载器。PIC依赖于下面两种技术：1） 使用相对地址 2） 加载器可以自动更新涉及到绝对地址的指令。对于ARM架构，则是在编译时使用-mword-relocations，生成与位置无关代码，链接时使用-pie生成.rel.dyn段，该段中的每个条目被称为一个LABEL，用来存储绝对地址符号的地址。

### 5.1 uboot配置
**增加uboot1**<br>
```cpp
//item文件中增加:
part16					uboot1.512.boot
//gendisk.sh中增加:
r flash 10   ../images/uboot1.isi  到 debug.ixl中
```

**自动分区:**<be>
```cpp
sudo fdisk $1 << EOF > /dev/null 2>&1
d
1
d
2
d
3
d
4
n
p
1
262144
4488888
n
p
2
4500000
4622222
w
EOF
```


### 5.2 lds文件语法和范例
linker script中的语法是linker command language（很简单的language，大家不用害怕...）。ld的功能是将input文件组装成一个output文件。这些文件内部的都有特殊的组织结构，这种结构被叫做object file format。每一个文件叫做object file（这可能就是.o文件的来历吧。哈哈），输出文件也叫可执行文件（an executable），但是对于ld来说，它也是一种object文件。那么Object文件有什么特殊的地方呢？恩，它内部组织是按照section（段、或者节，以后不再区分二者）来组织的。一句话，object文件内部包含段......每个段都有名字和size。另外，段内部还包含一些数据，这些数据叫做section contents，以后称段内容。每个段有不同的属性。例如text段标志为可加载（loadable），表示该段内的contents在运行时候（当然指输出文件执行的时候）需要加载到内存中。另外一些段中没有contents，那么这些段标示为allocatable，即需要分配一些内存（有时候这些内存会被初始化成0，这里说的应该是BSS段。BSS段在二进制文件中没有占据空间，即磁盘上二进制文件的大小比较小，但是加载到内存后，需要为BSS段分配内存空间。），还有一些段属于debug的，这里包含一些debug信息。

既然需要加载到内存中，那么加载到内存的地址是什么呢？loadable和allocable的段都有两个地址，VMA:虚拟地址，即程序运行时候的地址，例如把text段的VMA首地址设置为0x800000000，那么运行时候的首地址就是这个了。另外还有一个LMA，即Load memory address。这个地址是section加载时的地址。晕了吧？二者有啥区别？一般情况下，VMA=LMA。但也有例外。例如设置某数据段的LMA在ROM中（即加载的时候拷贝到ROM中），运行的时候拷贝到RAM中，这样LMA和VMA就不同了。---------》很难搞懂不是？这种方法用于初始化一些全局变量，基于那种ROM based system。（问一个问题，run的时候，怎么根据section中的VMA进行相应设置啊？？以后可能需要研究下内核中关于execve实现方面的内容了）。关于VMA和LMA，大家通过objdump -h选项可以查看。

LS描述输入文件（也就是gcc -c命令产生的.o文件即object文件）中的section最终如何对应到一个输出文件。这个其实好理解，例如一个elf由三个.o文件构成，每个.o文件都有text/data/bss段，但最终的那一个elf就会将三个输入的.o文件的段合并到一起。

linux最终链接用的是vmlinux.lds，但是那个文件由vmlinux.lds.S（这是一个汇编文件）得到，  arm-linux-gcc -E -Wp,-MD,arch/arm/kernel/.vmlinux.lds.d -nostdinc ...... -D__KERNEL__ -mlittle-endian ...... -DTEXT_OFFSET=0x00008000 -P -C -Uarm -D__ASSEMBLY__ -o arch/arm/kernel/vmlinux.lds     arch/arm/kernel/vmlinux.lds.S

linux的链接脚本文件arch/arm/kernel/vmlinux.lds.S，可以使用 ld -T vmlinux.lds.S 加载

**ARM链接脚本:**<br>
文档有些内容很少见，不需要全部理解：1. https://blog.csdn.net/gameit/article/details/13169337 ; 2.     https://blog.csdn.net/ssdsafsdsd/article/details/8687334

`-Ttext $(TEXT_BASE)` 指定

**设置入口点**
在运行一个程序时第一个被执行到的指令称为"入口点". 你可以使用'ENTRY'连接脚本命令来设置入口点.参数是一个符号名:  ENTRY(SYMBOL). 有多种不同的方法来设置入口点.连接器会通过按顺序尝试以下的方法来设置入口点, 如果成功了,就会停止:
- `-e'入口命令行选项;
- 连接脚本中的`ENTRY(SYMBOL)'命令;
- 如果定义了start, 就使用start的值;
- 如果存在,就使用'.text'节的首地址;
- 地址`0'.

**处理文件的连接脚本命令**
很少使用的命令：
- `INCLUDE FILENAME' : 在当前点包含连接脚本文件FILENAME. 在当前路径下或用'-L'选项指定的所有路径下搜索这个文件, 你可以嵌套使用'INCLUDE'达10层.
- `INPUT(FILE, FILE, ...)'
- `INPUT(FILE FILE ...)'
- 'INPUT'命令指示连接器在连接时包含文件, 就像它们是在命令行上指定的一样.
- 'INPUT (-lFILE)', 'ld'会把文件名转换为'libFILE.a', 就象命令行参数'-l'一样
- `GROUP(FILE, FILE, ...)'
- `GROUP(FILE FILE ...)'
- `OUTPUT(FILENAME)' ： 在连接脚本中使用'OUTPUT(FILENAME)'命令跟在命令行中使用'-o FILENAME'命令是完全等效的. 如果两个都使用了, 那命令行选项优先
- `SEARCH_DIR(PATH)' ： 这个命令给 ld 用于搜索档案文件的路径中再增加新的路径，这和在命令行上使用'-L PATH'选项是完全等效的. 如果两个都使用了, 那连接器会两个路径都搜索. 用令行选项指定的路径首先被搜索.
- `STARTUP(FILENAME)' ： 除了FILENAME会成为第一个被连接的输入文件, 'STARTUP'命令跟'INPUT'命令完全相似, 就象这个文件是在命令行上第一个被指定的文件一样. 如果在一个系统中, 入口点总是存在于第一个文件中,那这个就很有用.
- `OUTPUT_FORMAT(BFDNAME)' : 跟在命令行上使用'-oformat BFDNAME'是完全等效的. 如果两个都使用了, 命令行选项优先.
- `OUTPUT_FORMAT(DEFAULT, BIG, LITTLE)' :
- `OUTPUT_ARCH(BFDARCH)' : 指定一个特定的输出机器架构. 这个参数是BFD库中使用的一个名字. 你可以通过使用带有'-f'选项的'objdump'程序来查看一个目标文件的架构.
- `TARGET(BFDNAME)' : 'TARGET'命令在读取输入文件时命名BFD格式. 它会影响到后来的'INPUT'和'GROUP'命令. 这个命令跟在命令行上使用 -b BFDNAME 相似. 如果使用了 TARGET 命令但 OUTPUT_formAT 没有指定, 最后的'TARGET'命令也被用来设置输出文件的格式
- `ASSERT(EXP, MESSAGE)' : 确保EXP不等于零,如果等于零, 连接器就会返回一个错误码退出,并打印出MESSAGE.
- `EXTERN(SYMBOL SYMBOL ...)' : 强制SYMBOL作为一个无定义的符号输入到输出文件中去. 这样做了,可能会引发从标准库中连接一些节外的库. 你可以为每一个EXTERN'列出几个符号, 而且你可以多次使用'EXTERN'. 这个命令跟'-u'命令行选项具有相同的效果.
- `FORCE_COMMON_ALLOCATION' : 这个命令跟命令行选项'-d'具有相同的效果: 就算指定了一个可重定位的输出文件('-r'),也让'ld'为普通符号分配空间.
- `INHIBIT_COMMON_ALLOCATION' :  这个命令跟命令行选项 --no-define-common 具有相同的效果: 就算是一个不可重位输出文件, 也让'ld'忽略为普通符号分配的空间.
- ASSERT命令，如果第一个参数为0，则打印第二个参数的信息（也就是错误信息），然后ld命令退出。如：  ASSERT((__proc_info_end - __proc_info_begin), "missing CPU support")
- `ADDR(SECTION)' 内建函数，返回节SECTION的绝对地址（VMA）。你的脚本之前必须已经定义了.output1。如： symbol_1 = ADDR(.output1);
- `ALIGN(EXP)' 内建函数，返回定位计数器'.'对齐到下一个EXP指定的边界后的值。‘ALIGN’不改变定位计数器的值，它只是在定位计数器上面作了一个运算
- 'SORT' 连接器会把匹配通配符的文件和节按在连接中被看到的顺序放置. 你可以通过'SORT'关键字改变它, 它出现在括号中的通配符之前(比如,'SORT(.text*)'). 当'SORT'关键字被使用时, 连接器会在把文件和节放到输出文件中之前按名字顺序重新排列它们.
-

**通配符的使用**<br>
    SECTIONS {
      .text : { *(.text) }
      .DATA : { [A-Z]*(.data) }
      .data : { *(.data) }
      .bss : { *(.bss) }
    }
一个普通的范例
    SECTIONS {
      outputa 0x10000 :
        {
        all.o
        foo.o (.input1)
        }
      outputb :
        {
        foo.o (.input2)
        foo1.o (.input1)
        }
      outputc :
        {
        *(.input1)
        *(.input2)
        }
    }



**定位计数器**<br>
一个特殊的连接器变量"dot"'.'总是含有当前的输出定位计数器。因为'.'总引用输出段中的一个位置，它只可以出现在'SECTIONS'命令中的表达式中。'.'符号可以出现在表达式中一个普能符号允许出现的任何位置。

把一个值赋给'.'会让定位计数器产生移动。这会在输出段中产生空洞。定位计数器从不向前移动。
```cpp
    SECTIONS
    {
      output :
        {
          file1(.text)
          . = . + 1000;
          file2(.text)
          . += 1000;
          file3(.text)
        } = 0x12345678;
    }
```
在前面的例子中，来自'file1'的'.text'节被定位在输出节'output'的起始位置。它后面跟有1000byte的空隙。然后是来自'file2'的'.text'节，同样是后面跟有1000byte的空隙，最后是来自'file3'的'.text'节。符号'=0x12345678'指定在空隙中填入什么样的数据。

注意：'.'实际上引用的是当前包含目标的从开始处的字节偏移。通常，它就是'SECTIONS'语句，其起始地址是0，因为'.'可以被用作绝对地址。但是如果'.'被用在一个节描述中，它引用的是从这个节起始处开始的偏移，而不是一个绝对地址。这样，在下面这样一个脚本中：
```cpp
    SECTIONS
    {
        . = 0x100
        .text: {
          *(.text)
          . = 0x200
        }
        . = 0x500
        .data: {
          *(.data)
          . += 0x600
        }
    }
```
'.text'节被赋于起始地址0x100，尽管在'.text'输入节中没有足够的数据来填充这个区域，但其长度还是0x200bytes。（如果数据太多，那会产生一条错误信息，因为这会试图把'.'向前移）。'.data'节会从0x500处开始，并且它在结尾处还会有0x600的额外空间。

**支持的运算符**<br>
连接器可以识别标准的C的算术运算符集, 以及它们的优先集:<br>
    优先集        结合性          运算符                  备注
    (highest)
    1              left            !  -  ~                  (1)
    2              left            *  /  %
    3              left            +  -
    4              left            >>  <<
    5              left            ==  !=  >  <  <=  >=
    6              left            &
    7              left            |
    8              left            &&
    9              left            ||
    10              right          ? :
    11              right          &=  +=  -=  *=  /=      (2)
    (lowest)
  注: (1) 前缀运算符 (2) *Note Assignments::.

**简单赋值**<br>
可以使用所有的C赋值符号为一个符号赋值, EXPRESSION后面的分号是必须的.
- `SYMBOL = EXPRESSION ;'
- `SYMBOL += EXPRESSION ;'
- `SYMBOL -= EXPRESSION ;'
- `SYMBOL *= EXPRESSION ;'
- `SYMBOL /= EXPRESSION ;'
- `SYMBOL <<= EXPRESSION ;'
- `SYMBOL >>= EXPRESSION ;'
- `SYMBOL |= EXPRESSION ;'
- `SYMBOL &= EXPRESSION ;'

**常数**<br>
所有的常数都是整型值。就像在C中，连接器把以'0'开头的整型数视为八进制数，把以'0x'或'0X'开头的视为十六进制。连接器把其它的整型数视为十进制。另外，你可以使用'K'和'M'后缀作为常数的度量单位，分别为'1024'和'1024*1024'。比如，下面的三个常数表示同一个值: _fourk_1 = 4K;    _fourk_2 = 4096;    _fourk_3 = 0x1000;

**变量定义和使用**

```cpp
//lds文件中的定义
  . = ALIGN((1 << 12));
  __sram_copy_in_dram = .;
  .sram 0xffff2000 : AT(__sram_copy_in_dram) {
    __sram_start = .;
    *(.sram.start);
    . = ALIGN(8);
    *(.sram.text);
    . = ALIGN(8);
    *(.sram.rodata);
    . = ALIGN(8);
    *(.sram.data);
    . = ALIGN(8);
    __sram_bss = .;
    *(.sram.bss);
    . = ALIGN(8);
    __sram_end = .;
  }
//kernel中的使用方式
extern char __sram_copy_in_dram, __sram_start, __sram_bss, __sram_end;
char *ram = &__sram_copy_in_dram, start = &__sram_start, *end = &__sram_end, *bss = &__sram_bss;
//说白了，LS中定义的变量其实就是地址，比如__sram_start这个值本身是没有意义的，只有它的地址才有意义。因为它的值没有初始化。比如_stext=0x100会创建一个symbol项，指向0x100的内存，但该内存中没有存储value，所以相当于定义了一个位置固定在0x100的变量，长度和类型无需确定，用户使用的时候自行解析。
//或者如下，直接用数组指针访问
extern initcall_t __initcall_start[], __initcall_end[], __early_initcall_end[];
```

**section格式**<br>
一个完整的输出section的描述:
SECTION [address] [(TYPE)] : [AT(LMA)]
{
  OUTPUT-SECTION-COMMAND
  OUTPUT-SECTION-COMMAND
  …
} [>REGION] [AT>LMA_REGION]
[ ]内的内容为可选选项, 一般不需要. 其中， address 为VMA，而AT命令中的为LMA。一般情况，address不会设置，所以它默认等于当前的location counter；SECTION边上的空格是必须的, 所以节名是明确的. 冒号跟花括号也是必须的. 断行和其他的空格是可选的. 每一个OUTPUT-SECTION-COMMAND可能是如下的情况: 1.一个符号赋值.2.一个输入节描述.3.直接包含的数据值.4.一个特定的输出节关键字.

ADDRESS是关于输出节中VMA的一个表达式. 如果你不提供ADDRESS, 连接器会基于REGION(如果存在)设置它,或者基于定位计数器的当前值.如果你提供了ADDRESS, 那输出节的地址会被精确地设为这个值. 如果你既不提供ADDRESS也不提供REGION, 那输出节的地址会被设为当前的定位计数器向上对齐到输出节需要的对齐边界的值. 输出节的对齐要求是所有输入节中含有的对齐要求中最严格的一个. 比如: .text . : { *(.text) } 和 .text : { *(.text) }有细微的不同. 第一个会把'.text'输出节的地址设为当前定位计数器的值. 第二个会把它设为定位计数器的当前值向上对齐到'.text'输入节中对齐要求最严格的一个边界. 所以一般应该使用第二个表述方式；或者使用.text ALIGN(0x10) : { *(.text) }的格式，强化对齐要求。

输入节描述是最基本的连接脚本操作. 你使用输出节来告诉连接器在内存中如何布局你的程序. 你使用输入节来告诉连接器如何把输入文件映射到你的内存中.

有两种方法包含多于一个的节: *(.text .rdata)  *(.text) *(.rdata)。上面两句的区别在于'.text'和'.rdata'输入节的输出节中出现的顺序不同. 在第一个例子中, 两种节会交替出现,并以连接器的输入顺序排布. 在第二个例子中,所有的'.text'输入节会先出现,然后是所有的'.rdata'节.

```cpp
//举个小例子，看看VMA和LMA到底有什么作用
SECTIONS
{
  .text 0x1000 : { *(.text) _etext = . ; }  //.text段的VMA为0x1000，而且LMA=VMA
  .mdata 0x2000 : AT ( ADDR (.text) + SIZEOF (.text) ) {  //.mdata段的VMA为0x2000,但是它的LMA却在.text段的结尾
       _data = . ; *(.data); _edata = . ;
  } //.mdata段运行的时候在0x2000，但是数据load地址却在.text段后，所以运行的时候需要把.mdata段内容拷贝过去。
  .bss 0x3000 :  {
     _bstart = . ; *(.bss) *(COMMON) ; _bend = . ;
  }
}

void section_cpy() {
  extern char _etext, _data, _edata, _bstart, _bend;
  char *src = &_etext;  //_etext为.text端的末尾 VMA地址，但同时也是.mdata段LMA的开始，有LS种的AT指定
  char *dst = &_data;  //_data为mdata段的VMA，现在需要把LMA地址开始的内容拷贝到VMA开始的地方

  /* ROM has data at end of text; copy it. */
  while (dst < &_edata)
   *dst++ = *src++;   //拷贝....明白了？不明白的好好琢磨

  /* Zero bss. */
  for (dst = &_bstart; dst< &_bend; dst++)
   *dst = 0;  //初始化数据区域
}

```

**输出段填充**
你可以通过使用'=FILLEXP'为整个节设置填充样式。FILLEXP是一个表达式。任何没有指定的输出段内的内存区域（比如，因为输入段的对齐要求而产生的裂缝）会被填入这个值。如果填充表达式是一个简单的十六进制值，比如，一个以'0x'开始的十六进制数字组成的字符串，并且尾部不是'k'或'M'，那一个任意的十六进制数字长序列可以被用来指定填充样式；前导零也变为样式的一部分。对于所有其他的情况，包含一个附加的括号或一元操作符'+'，那填充样式是表达式的最低四字节的值。在所有的情况下，数值是big-endian. 你还可以通过在输出节命令中使用'FILL'命令来改变填充值。一个简单的例子:  SECTIONS { .text : { *(.text) } =0x90909090 }

**MEMORY内存区域命令的文法:**<br>
连接器在缺省状态下被配置为允许分配所有可用的内存块。你可以使用‘MEMORY’命令重新配置这个设置。‘MEMORY’命令描述目标平台上内存块的位置与长度。你可以用它来描述哪些内存区域可以被连接器使用，哪些内存区域是要避免使用的。然后你就可以把节分配到特定的内存区域中。连接器会基于内存区域设置节的地址，对于太满的区域，会提示警告信息。连接器不会为了适应可用的区域而搅乱节。一个连接脚本最多可以包含一次'MEMORY'命令。但是，你可以在命令中随心所欲定义任意多的内存块. 一旦你定义了一个内存区域，你也可以指示连接器把指定的输出段放入到这个内存区域中，这可以通过使用'>REGION'输出段属性。比如，如果你有一个名为'mem'的内存区域，你可以在输出段定义中使用'>mem'。如果没有为输出段指定地址，连接器就会把地址设置为内存区域中的下一个可用的地址。如果总共的映射到一个内存区域的输出段对于区域来说太大了，连接器会提示一条错误信息。

```cpp
MEMORY {
NAME1 [(ATTR)] : ORIGIN = ORIGIN1, LENGTH = LEN2
NAME2 [(ATTR)] : ORIGIN = ORIGIN2, LENGTH = LEN2
}
//例如:
MEMORY
{
rom (rx) : ORIGIN = 0, LENGTH = 256K
ram (!rx) : org = 0×40000000, l = 4M
}
```
- NAME ：存储区域的名字，这个名字可以与符号名、文件名、section名重复，因为它处于一个独立的名字空间。
- ATTR ：定义该存储区域的属性，在讲述SECTIONS命令时提到，当某输入section没有在SECTIONS命令内引用时，连接器会把该输入 section直接拷贝成输出section，然后将该输出section放入内存区域内。如果设置了内存区域设置了ATTR属性，那么该区域只接受满足该属性的section(怎么判断该section是否满足？输出section描述内好象没有记录该section的读写执行属性)。ATTR属性内可以出现以下7个字符: R 只读section; W 读/写section; X 可执行section; A ‘可分配的’section; I 初始化了的section; L 同I; ! 不满足该字符之后的任何一个属性的section
- ORIGIN ：是一个关于内存区域地始地址的表达式。在内存分配执行之前，这个表达式必须被求值产生一个常数，这意味着你不可以使用任何节相关的符号。关键字'ORIGIN'可以被缩写为'org'或'o'(但是，不可以写为，比如‘ORG’）
- LENGTH ：是一个关于内存区域长充（以字节为单位）的表达式。就像ORIGIN表达式，这个表达式在分配执行前也必须被求得为一个常数值。关键字'LENGTH'可以被简写为‘len'或'l'

```cpp
MEMORY
{
  rom (rx)  : ORIGIN = 0, LENGTH = 256K
  ram (!rx) : org = 0x40000000, l = 4M
}
```

```cpp
//下面是irom的lds文件，可以看做是MEMORY的范例
OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
OUTPUT_ARCH(arm)
ENTRY(_start)   //入口函数或标记
MEMORY
{
	IROM_BASE  : ORIGIN = 0x00000000, LENGTH = 120K
	IRAM_BASE  : ORIGIN = 0x3c000000, LENGTH = 48K
	IRAM_STAC  : ORIGIN = 0x3c00c000, LENGTH = 4K
	IRAM_DATA  : ORIGIN = 0x3c00d000, LENGTH = 4K
	IRAM_MLOC  : ORIGIN = 0x3c00e000, LENGTH = 72K
	GRAM_BASE  : ORIGIN = 0x3c020000, LENGTH = 128K
	DRAM_BASE  : ORIGIN = 0x80000000, LENGTH = 32K /* DDR @ 0x8000'0000 ???? */
}

SECTIONS
{
	.text : {
		boot/start.o	(.text)
		*(.text)
	} > IROM_BASE
	. = ALIGN(4);

	.rodata : {
		*(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*)))
	} > IROM_BASE
	. = ALIGN(4);

	.u_boot_cmd : {
		__u_boot_cmd_start = .;
		*(.u_boot_cmd)
	} > IROM_BASE
	. = ALIGN(4);
	__u_boot_cmd_end = .;

	.data : AT(__u_boot_cmd_end) {  /* it is bured at the end of code; LMA */
		_data_start = .;
		*(.data)
		. = ALIGN(4);
	} > IRAM_DATA
	. = ALIGN(4);

	.bss (NOLOAD) : {
		__bss_start = .;
		*(.bss)
	} > IRAM_DATA
	. = ALIGN(4);
	_end = .;

	/* set data boundary */
	_data_len  = SIZEOF(.data);
	_data_load = LOADADDR(.data);

	/* also init stack offset
	 * leave 4 words for abort-stack
	 */
	_stack = ORIGIN(IRAM_STAC) + LENGTH(IRAM_STAC) - 0x20;

	/* the malloc area */
	_malloc_ori = ORIGIN(IRAM_MLOC);
	_malloc_end = ORIGIN(IRAM_MLOC) + LENGTH(IRAM_MLOC);

	/* buffer for USB & eth */
	_ethresv = ORIGIN(GRAM_BASE);
	_usbresv = ORIGIN(GRAM_BASE) + 0xf000;
}
```

### 5.3 BFD库
Binary format descriptor, 即二进制文件格式描述符，它是连接工具(ld)和二进制文件操作工具(bin-util)实现对于目标文件操作的标准接口，ld和bin-util通过调用实现BFD接口的库libbfd来实现它们的目标文件操作功能。一个基于BFD库开发小工具的页面： https://blog.csdn.net/absurd/article/details/3593156

**BFD的结构**
BFD整体上简单地可分为前端和后端（就象gcc一样），这样做的目的主要出于可移植性的考虑，前端向应用层提供统一的调用接口，是目标文件格式 无关的，后端实现目标格式相关的部分，前端通过调用后端的相关函数实现真正的具体目标文件格式操作功能。所以如果要支持一种新嵌入式目标文件格式（就象 uclinux支持的简化类coff文件格式BFLT）就只要修改BFD的后端就行了。但是为了节约运行时内存，连接器和相关的工具一般被配置为只支持可用的目标文件格式的一个子集，你可以使用'objdump -i'来列出你配置的所有支持的

BFD的结构
前端的结构和一些主要的功能是：段操作，符号表处理，重定位管理，库操作，及其为了方便用的函数。后端涉及具体的文件格式操作方法的支持，典型的是a.out，coff，和elf.

BFD工作过程简述
每当bin-util工具如（objdump）打开一个目标文件时，工具通过调用BFD库 里相关目标文件格式的信息判定该文件的二进制格式。然后 抽取库里相关例程的信息建立对应的二进制格式操作描述符表（实际上诗歌函数指针表，有点象COM的VTABLE），利用这些指针，工具读取分析和操作该目 标文件。我们利用objcopy(操作)，objdump（读取、分析），readelf(读取)，就是全仰仗BFD的功能。我刚才讲了现成目标文件的工 作过程，那么目标文件的形成过程又是怎样的呢？如上所述，编译器/连接器在处理目标文件符号表等时先会调用前端函数（前端是统一和抽象的过程），然后通过 后端处理具体文件格式的操作函数将符号表等相关信息写到输出文件, 这些任务的就是通过调用内存中的BFD描述符的函数实现的。
