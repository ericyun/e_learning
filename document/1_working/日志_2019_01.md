*# 工作日志

### 修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2019/01/07 | 员清观 |  |

## misc
`nautilus .` 可以用来从终端启动文件管理器并切换到当前文件夹

如果同时使能`arm-lib`和`dsp-lib`，可以通过audiobox命令行`-a`参数确定audiobox实际激活的lib:
- 命令行不包含`-a`参数，使能`dsp-lib`
- 通过'-a dsp'参数，使能`dsp-lib`
- 通过'-a speex'参数，使能`arm-lib(speexdsp)`

aecv2_controler 改变为struct imapx_runtime_data *prtd中一个结构。这样，多codec的系统也可以支持。通过card_id来区分不同的codec。要求获取当前播放偏移的时候，通过card_id访问不同控制device文件。aec功能开启关闭，可以通过card_id指定，两者暂时需要保持一致，因为没有接口提供分别配置。

完成完整的存储管理机制：　fat32以及文件系统；buffer.c等相关cache管理；mtd以及块设备驱动；mmc和spi等下层驱动；

中断管理子系统，包括pl330等dma驱动；时间管理子系统；

记忆力，专注能力全面衰退的情况下，尽量使用外在的办法帮助，保证自己的工作学习能力；
  １．使用atom记代码笔记，一方面用来整理思路，更重要的是，记录笔记的时候，简单的ctrl+c/v可以强制性的稳定和引导思路
  ２．坚持，坚持

**剩余整理内容**<br>
1. ffmpeg对codec的定制和调试,以及其他音频的内容
2. __schedule() 函数, 进程加载的基本过程.
3. ftrace 以及其他的调试方式
4. 尽量能够将所有的文档整理一遍.

## 12-23->...
**12-25**<br>
1. 音频开发,包括:codec驱动,alsa驱动,audiobox模块 vplayer ffmpeg应用 aec处理和测试效果量化评估
2. 存储系统: 性能和稳定性(各种异常情况的处理) fat32文件系统延迟分配解决fat32文件系统缺点, sd/mmc, spi flash, ftl, 启动出错问题, 50M提速
3. 设计门铃项目的demo: 基于全志xr871和cortex-A5
4. 内核维护: uboot和内核启动速度优化;解决内核bug导致的CMA内存碎片问题; freertos内核移植到公司cortex-A5平台

Kernel压缩算法 Kernel裁剪 将一些驱动模块编译为KO延后动态加载

盈方微:
  产品化工程化方向, 有很长的路
  单元测试, 自动测试, 压力测试
  诊断和客户支持手段
  学徒制度, 深度培养每一个员工,但是不适应文化不成熟的公司, 如德国,基本是终身雇佣制的,员工和企业有比较密切的关联.

按照之前讨论，盈方微新的门铃项目采用C20+wifi MCU的架构，两芯片间通过SPI总线通信，尚云P2P的工作将会拆分开在C20和MCU分别完成，MCU端注册到唤醒服务器并维持心跳和支持设备唤醒和客户端推送；C20只有在有实际视频传输任务的时候才会启动，负责监听和建立视频连接。

设备启动流程：
a．MCU端注册到唤醒服务器
b．MCU进入休眠状态，但会定时醒来发送唤醒服务器keepalive心跳(比如60s一次)

手机客户端发起的呼叫流程：
a．客户端向唤醒服务器查询设备休眠状态信息
b．唤醒服务器向设备发送唤醒封包
c．MCU结束休眠，启动C20
d．C20启动完成后，开始listen()监听客户端连接
e．客户端确认设备唤醒之后，connect()连接到设备
f．开始视频通信

设备端主动触发呼叫流程(按门铃按键等事件)：
a．MCU结束休眠，向推送服务器发送推送请求，同时启动C20
b．推送服务器推送请求到手机客户端
c．C20启动完成后，开始listen()监听客户端连接
d．客户端确认推送请求后，connect()连接到设备
e．开始视频通信



## 04-14->...
**04-25**<br>
增加如下的诊断内容:
  dev->dev_fr_counter++;
  prtd->xrun_step

**04-24**<br>
static unsigned long long get_timestamp(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
    return  ts.tv_sec * 1000ull + ts.tv_nsec / 1000000;
}

APP_LOG_CRIT("get 2: %d\n", (int)get_timestamp());

**04-23**<br>

abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/pcm_16khz_ch2_32b.wav -y 22 -z 34 &
abctrl record -w 16 -s 16000 -n 2 -t 8 -o /mnt/sd0/record_1.wav &
abctrl record --enable-aec -w 16 -s 16000 -n 2 -t 8 -o /mnt/sd0/record_2.wav &

**04-22**<br>
如果在设备将要结束的时候, audio_set_format,会否出现异常呢? 应该增加保护.
codec_open 增加pid打印

**04-17**<br>
audiobox crash 的问题， 如何跟踪:
  1. 如果出现， 可以在相关的函数中增加延时和打印，以帮助定位。发送参考代码给客户。
  2. gdb, 具体到process_end的bug，应用进程sleep启动， audiobox中杀死应用进程。
  3. 把trace通过管道或者消息队列,重定向到另外一个进程,这样可以保证trace的完整性.
应用程序打印中增加内核时间，可以和内核代码同步
```cpp
int devctrl_check_release_dev(audio_dev_t dev)
{
	int next_check = 5000;//check 5ms later

	pthread_mutex_lock(&dev->dev_mutex);
	if (dev->trying_hal_release != 1) {
		pthread_mutex_unlock(&dev->dev_mutex);
		return next_check;
	}
	if (list_empty(&dev->head)) {
		int result = 0, cmd = AB_RELEASE_DEVICE;
		snd_pcm_sframes_t delay;
		char rpcname[64];
		snd_pcm_delay(dev->handle, &delay);
		result = delay*1000/dev->attr.samplingrate;
		APP_LOG_INFO("Frame left:%d, %dms\n", delay, result);
		if (delay > (dev->attr.samplingrate>>9)) {
			if (result > 40) {
				next_check = 40000;
			} else if (result > 20) {
				next_check = 20000;
			} else if (result > 10) {
				next_check = 10000;
			}
			pthread_mutex_unlock(&dev->dev_mutex);
			return next_check;
		}
		sprintf(rpcname, "%s-%s", AUDIOBOX_RPC_BASE, dev->devname);
		AB_EVENT(sc, &cmd, dev->devname, NULL, &result);
		audiobox_event_scatter(rpcname, sc, AB_EVENT_SIZE(sc));
	}
	pthread_mutex_unlock(&dev->dev_mutex);

	return next_check;
}
```

客户说,aecv2没有ctrl+c时候的crash问题：
**04-16**<br>
```cpp
//音频放大
		short *ptr = dev_buf.virt_addr;
		int i, multi = 5;
		for (i=0;i<(dev_buf.size/2);) {
			ptr[i+2] = multi*ptr[i+2];
			ptr[i+3] = multi*ptr[i+3];
			i += 4;
		}
```
**04-15**<br>
获取完整的内部数据结构信息，然后打印出来:   audio_dev_t     audio_chn_t     apu_codec_t
是否可以查询fr的情况呢？
还有一些全局变量的打印
  static uint8_t audiobox_id[AB_ID] = {0, 0, 0, 0};
  static int enhance_mode = 0;
  static int default_aec_algorithm = -1;
  static int capture_devfr_duration = 300;//in ms

**04-14**<br>
是否应该增加api接口，可以临时的提升或者降低audio播放时钟呢？
## 03-04->...
**03-23**<br>
增加通道和api的单独控制功能, abctrl直接命令行指定通道和命令以及参数, 或者, abctrl提供控制台解析测试. 主要目标是对运行中的通道和设备进行解析, 打印配置和统计信息, 控制测试等.

增加一条消息, 开启dma的trace信息。应该可以实现比较复杂和全面的dma trace。

**03-22**<br>
记录一下spinlock锁死问题相关信息,重现等:
```cpp
echo 6 > /proc/sys/vm/dirty_ratio
echo 3 > /proc/sys/vm/dirty_background_ratio

mount -t vfat /dev/mmcblk0p1 /mnt
videoboxd   /mnt/player_320_g1.json
cd /mnt
./vplayer /mnt/320_264_15fps_1track.mkv

new
play 1

mount -t vfat /dev/mmcblk0p1 /mnt
abctrl unitest setlog -m audiobox -l 0
abctrl play -w 32 -s 16000 -n 2 -d /mnt/pcm_16khz_ch2_32b.wav -y 22 -z 28 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 5 -o /mnt/voice_0.wav &
```

**03-21**<br>
调试底层音频, 可使用校验和或者非0字符个数来判断播放的音频是什么玩意.
```cpp
	int i;
	long long zero_flag = 0;
	char* myptr = (char*)p_dbginfo->audio_devinfo;
	for (i=0;i<sizeof(p_dbginfo->audio_devinfo);i++) {
		zero_flag += myptr[+i];
	}
	APP_LOG_CRIT("audiobox zero_flag : %d\n", zero_flag);

int i;
long long zero_flag = 0;
for (i=0;i<prtd->dma_period;i++) {
	zero_flag += prtd->hw_dma_area[prtd->dma_pos+i];
}
printk(KERN_EMERG "zero_flag: %lld 0x%x\n", zero_flag, counter_1*prtd->dma_period/8);
```
**03-20**<br>
增加一个
void audiobox_set_event(audio_dev_t dev, int* variable, int event)
dev->hal_state 的改变,一定要在临界区中进行, 只能在主线程和service线程中进行.
dev清空了当前的所有数据之后,恢复正常工作.所以,flush应该是一次性的操作. 增加一个flush的函数,
audiobox应该设定40ms的缺省帧长
应该可以直接使用下面接口,快进所有的frame,一直到无数据为止
```cpp
snd_pcm_forward(dev->handle, size);
printk(KERN_DEBUG "~~~(%s, %d) %x %x %x -- %x == %x --  %x %x -- %x ~~~\n", __func__, __LINE__
, runtime->status->hw_ptr
, runtime->control->appl_ptr
, prtd->app_copy_ptr
, prtd->dma_pos/8
, prtd->last_valid_pos/8
, prtd->app_pos/8
, prtd->dma_copy_pos/8
, prtd->fill_silence
);

```

**03-19**<br>

snd_pcm_close()之前应该增加snd_pcm_drain(),保证播放完毕.
audiobox应该返回在某个系统时间点上,延时等等的参数,这样,即使上层被阻塞一段时间,仍然可以得到准确的音视频同步播放时间. 这个同步时间,应该是write一个Frame之后锁定alsa接口,然后调用,获取到pcm delay和当前时间,通知上层

**03-18**<br>
imapx_dma.c中增加一个sound链表，可以根据device找到对应的管理信息；这是因为，aecv2_controler并不能简单归纳入imapx_runtime_data，因为它包含了较多的录音和播放两个方向的关联信息。

先确定上次什么位置开始填充静音的，然后，等hw_ptr大于它，代表已播放完毕；
runtime->control->appl_ptr 应该是下一个写入的帧的开始位置

如果需要进一步的读取更加精确的剩余时间，那么需要读取dam位置信息。

**03-16**<br>
启动过程
```cpp
printf("~~~(%s, %d)~~~%p %p %s\n", __func__, __LINE__, pcmp, *pcmp, name);

int snd_pcm_open(snd_pcm_t **pcmp, const char *name, snd_pcm_stream_t stream, int mode)
  int err = snd_config_update();
  return snd_pcm_open_noupdate(pcmp, snd_config, name, stream, mode, 0);
    err = snd_config_search_definition(root, "pcm", name, &pcm_conf);
    snd_config_set_hop(pcm_conf, hop);
    err = snd_pcm_open_conf(pcmp, name, root, pcm_conf, stream, mode);
      _snd_pcm_empty_open
        _snd_pcm_plug_open
          err = snd_pcm_open_slave(&spcm, root, sconf, stream, mode, conf);
          err = snd_pcm_plug_open(pcmp, name, sformat, schannels, srate, rate_converter, route_policy, ttable, ssize, cused, sused, spcm, 1);
            _snd_pcm_hw_open
              snd_pcm_hw_open

int snd_pcm_hw_params(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
  int err = _snd_pcm_hw_params(pcm, params);
    int err = pcm->ops->hw_params(pcm->op_arg, params); //int snd_pcm_plug_change_format(snd_pcm_t *pcm, snd_pcm_t **new, snd_pcm_plug_params_t *clt, snd_pcm_plug_params_t *slv)
      err = snd_pcm_plug_insert_plugins(pcm, &clt_params, &slv_params);
        int snd_pcm_plug_change_format(snd_pcm_t *pcm, snd_pcm_t **new, snd_pcm_plug_params_t *clt, snd_pcm_plug_params_t *slv)
          snd_pcm_linear_open(new, NULL, slv->format, plug->gen.slave, plug->gen.slave != plug->req_slave);
            err = snd_pcm_new(&pcm, SND_PCM_TYPE_LINEAR, name, slave->stream, slave->mode);
            pcm->fast_ops = &snd_pcm_plugin_fast_ops;
            snd_pcm_set_hw_ptr(pcm, &linear->plug.hw_ptr, -1, 0);
            snd_pcm_set_appl_ptr(pcm, &linear->plug.appl_ptr, -1, 0);

~~~(snd_pcm_hw_open, 1310)~~~0xb6b0b9e8 0x2ca18 (null)
~~~(snd_pcm_plug_open, 1148)~~~0x22278 0x2cd30 default
~~~(_snd_pcm_empty_open, 106)~~~0x22278 0x2cd30 default
```
**03-15**<br>
开始填0的时候设置flag并递增，收到数据的时候清除flag.上层可以通过读取这个flag得知已经填多少个0，下层是否已经播放完毕。或者，put_channel的时候通过这个机制来判断，比延时关闭放音设备更好。如果有更高精度要求
put_channel 时候，增加参数
put_channel函数阻塞，返回的时候表示播放完毕，如何？

读取数据，如果当前hw_ptr位置是上次最后一次数据的app_ptr位置，那么，播放完成了

**03-14**<br>
es8323增加如下： SOC_SINGLE_XR_SX("Infotm Spk Playback Volume", 0x2e, 4, 5, 0, 0x2e, 0), auidobox应该读取参数个数然后配置相应个数的音量

**03-13**<br>
x15的i2s的mclk必须手动初始化

**03-12**<br>
早上08:07到公司

如果支持audio_route_cset，那么不改写下面两个：
  chndata_set_mvol_setting(dev_name, volume);
  dev->m_volume
这样，相当于音量100

继续跟踪函数 int snd_ctl_elem_info(struct snd_ctl_file *ctl, struct snd_ctl_elem_info *info)如何获取step参数
先尝试硬件处理，失败，转软件方式以保持向前兼容。

**03-11**<br>
早上08:06到公司

audiobox增加新的函数，读取下层kcontrol的min和max和db范围，一般是0dB到-90dB，即使有误差也不大；然后直接计算得到音量，而不需要在驱动层次调试。另外提供另外一个kcontrol，供查询db范围如何？

如下面数据结构定义：
```cpp
struct sndrv_ctl_elem_info {
	struct sndrv_ctl_elem_id id;	/* W: element ID */
	int type;			/* R: value type - SNDRV_CTL_ELEM_TYPE_* */
	unsigned int access;		/* R: value access (bitmask) - SNDRV_CTL_ELEM_ACCESS_* */
	unsigned int count;		/* count of values */
	pid_t owner;			/* owner's PID of this control */
	union {
		struct {
			long min;		/* R: minimum value */
			long max;		/* R: maximum value */
			long step;		/* R: step (0 variable) */
		} integer;
		struct {
			long long min;		/* R: minimum value */
			long long max;		/* R: maximum value */
			long long step;		/* R: step (0 variable) */
		} integer64;
```
两个问题：
1. 部分手头没有的平台，如何处置
2. 给上层提供的音量接口，根据一般客户感受，还是现有的db量化
3. 之后可以增加： softvol放大功能，比如2550就是放大10倍


统一使用`Speaker Playback Volume`作放音音量控制；至于录音音量控制，可以在x15开发板上，控制reg11看是否；

为了兼容不同的codec，audiobox调用应该采用统一的volume定义(对应了实际的db)，这样，到reg值的转换，应该在下层完成。应该考虑使用tlv的方式来设置音量。不同的codec，根据最大最小取值以及对应的db变换范围，确定最小db和step这两个参数即可。应该以最大音量为0db，如果取值范围大，那么变化1对应的db就小。比如100->50，应该对应降低多少db呢？

增加音量控制功能的基本范例：
```cpp
static const struct snd_kcontrol_new fr1023_snd_controls[] = {
    SOC_SINGLE_EXT("Speaker Enable Switch", 0, 0, 1, 0, fr1023_spk_get, fr1023_spk_put),
  	SOC_DOUBLE_R("Speaker Playback Volume", FR1023_CONTROL18, FR1023_CONTROL19, 0, 63, 1),
};
int fr1023_probe(struct snd_soc_codec *codec)
  snd_soc_add_codec_controls(codec, fr1023_snd_controls, ARRAY_SIZE(fr1023_snd_controls));
```

应该把libdsp的驱动注册进入ffmpeg中，然后增加额外的注册?好像不是标准的。

重采样和编码应该分开

跟踪 swr_convert 函数的处理，找到bug所在。
～～～～～ aec前面应该增加一个recombine，每次获取固定的采样点，这样，可以方便的支持512的整数倍的帧
～～～～～ 重采样，先看看现有机制，是否内置有
～～～～～ 编码前，增加recombine函数接口

## 02-25->...
**02-29**<br>
**02-28**<br>
audiobox -l 1ffff &
abctrl record -W 16 -w 32 --enable-aec -s 16000 -n 2 -t 1 -f 576 -o /mnt/sd0/record_1.mp3
**02-27**<br>
make libffmpeg-rebuild;make libcodecs-dirclean;make libcodecs-rebuild;make audiobox-dirclean;make audiobox-rebuild;make;./tools/gendisk.sh /dev/sdb

abctrl record -W 16 -w 32 -s 8000 -n 2 -t 2 -o /mnt/sd0/record_3.mp3
gdb audiobox -l 1ffff

mp3录音，是否可以如下测试：
abctrl record -w 32 -s 16000 -n 2 -t 1 -f 576 -o /mnt/sd0/record_1.mp3
abctrl record -w 32 -s 16000 -n 2 -t 1 -F 1024 -f 576 -o /mnt/sd0/record_2.mp3
abctrl record -W 32 -w 16 -s 16000 -n 2 -t 1 -f 576 -o /mnt/sd0/record_3.mp3

**02-25**<br>
libffmpeg.mk文件中：
LIBFFMPEG_DEPENDENCIES += lame
LIBFFMPEG_CONFIG_ENCODER += --enable-libmp3lame
LIBFFMPEG_CONFIG_ENCODER += --enable-encoder=mp3lame
LIBFFMPEG_CONFIG_MUXER += --enable-muxer=mp3
**02-26**<br>
cd ~/work/mp3_encoder/deprecated-lame-mirror
./configure
make
./frontend/lame testcase.wav test.mp3
```cpp

需要 CONFIG_MP3_MUXER
//这个好像是填写mp3头部信息的模块
ff_libmp3lame_encoder
AVOutputFormat ff_mp3_muxer = {
    .name              = "mp3",
    .long_name         = NULL_IF_CONFIG_SMALL("MP3 (MPEG audio layer 3)"),
    .mime_type         = "audio/mpeg",
    .extensions        = "mp3",
    .priv_data_size    = sizeof(MP3Context),
    .audio_codec       = AV_CODEC_ID_MP3,
    .video_codec       = AV_CODEC_ID_PNG,
    .write_header      = mp3_write_header,
    .write_packet      = mp3_write_packet,
    .write_trailer     = mp3_write_trailer,
    .query_codec       = query_codec,
    .flags             = AVFMT_NOTIMESTAMPS,
    .priv_class        = &mp3_muxer_class,
};

//注册所有的codec到ffmpeg
void avcodec_register_all(void)
//注册所有的codec到ffmpeg
void avdevice_register_all(void)
//注册所有的codec到ffmpeg
void av_register_all(void)
  REGISTER_MUXDEMUX(MP3,              mp3);
```

## 02-18->...
**02-18**<br>
安装画图工具：  `sudo apt-get install graphviz`

1. 需要补充三张图片：1. audiobox框图 2. dev/channel/apu链表 3. 录音和放音线程泳道图
2. 增加Audiobox的启动过程，图看情况
3. 增加api接口调用流程，图看情况，多个线程多个消息队列间

可以考虑，逐步完善文档

**02-19**<br>
**02-20**<br>

## 01-21->...
**01-28**<br>

**申请第一个录音通道**

只分析下面场景： 设备aec2.0使能，通道aec使能，codec为g711a，两个通道参数相同的场景

```cpp
int audiobox_get_channel(struct event_scatter *event)
	... //调整校验音频通道和设备参数
	devctrl_create_dev()
		devctrl_alloc_dev()//申请并初始化dev管理信息
		devctrl_activate_server()
			audio_hal_open()//为设备启动录音PCM设备
			devctrl_alloc_devfr()//为设备申请`dev_fr`和`dev_fr_mapped`
			audio_create_devserv()//启动capture server线程
		list_add_tail(&dev->node, &audiobox_devlist);//dev添加到`audiobox_devlist`链表
	... //申请并初始化channel管理信息
	apu_preproc_create()
		apu_preproc_prepare()//为设备申请`aec_fr`并初始化aec lib和管理信息
		pthread_create(&dev->preproc_pid, NULL, thread_apu_preproc, p_preproc);//启动aec处理线程
	apu_codec_create()
		apu_fr_alloc(dev, &chn->channel_fr, FR_NAME_CHAN_PREFIX); //为通道申请`chan_fr`
		__apu_codec_create(chn);
			... //申请并初始化codec管理信息
			apu_codec_prepare()
				apu_fr_alloc(dev, &p_codec->codec_fr_para, FR_NAME_CODEC_PREFIX);//为codec子模块申请`codec_fr`
				softvol_apu_open(apu_handle); //申请softvol子模块
				recombiner_apu_open(apu_handle); //申请recombine子模块
				codec_apu_open(apu_handle); //申请codec子模块
			list_add_tail(&chn->chn_node, &p_codec->vchanlist);//通道添加到codec的通道链表
			list_add_tail(&p_codec->node, &dev->apulist); //codec添加到设备的codec链表
		apu_codec_start(chn); //启动通道编码处理线程
	list_add_tail(&chn->node, &dev->head); //channel添加到dev的通道链表
```

```cpp
int audiobox_get_channel(struct event_scatter *event)
	... //调整校验音频通道和设备参数
	... //申请并初始化channel管理信息
	apu_codec_create()
		apu_fr_alloc(dev, &chn->channel_fr, FR_NAME_CHAN_PREFIX); //为通道申请`chan_fr`
		__apu_codec_create(chn);
			//第二通道和第一通道参数相同，可共享第一个通道的codec
			list_add_tail(&chn->chn_node, &p_codec->vchanlist);//通道添加到codec的通道链表
	list_add_tail(&chn->node, &dev->head); //channel添加到dev的通道链表
```

```cpp
int __audiobox_put_channel(int id)
	remove_chan_node(dev, chn);
		list_del(&chn->node); //从dev通道链表中移除通道
		list_del(&chn->chn_node); //从codec通道链表中移除通道
	apu_codec_destroy(chn);
		p_codec->ref_counter--; //codec的引用索引递减
		apu_fr_free(dev, &chn->channel_fr); //释放`chan_fr`
	free(chn);
```

```cpp
int __audiobox_put_channel(int id)
	remove_chan_node(dev, chn);
		list_del(&chn->node); //从dev通道链表中移除通道
		list_del(&chn->chn_node); //从codec通道链表中移除通道
	apu_codec_destroy(chn);
		pthread_join(p_codec->apu_pid, NULL); //通道处理线程退出
		apu_fr_free(dev, &chn->channel_fr); //释放`chan_fr`
		apu_fr_free(dev, &p_codec->codec_fr_para); //释放`codec_fr`
		list_del(&p_codec->node); //从dev的codec链表中移除codec
		apu_codec_unprepare(p_codec, 1);
			softvol_apu_close(p_codec); //关闭softvol子模块
			codec_apu_close(p_codec); //关闭codec子模块
			recombiner_apu_close(p_codec); //关闭recombiner子模块
		free(p_codec);
	free(chn);
	apu_preproc_destroy(dev);
		apu_preproc_unprepare(dev);
			pthread_join(dev->preproc_pid, NULL); //停止aec处理线程
			aec_lib_deactivate_preproc(p_preproc); //释放`aec_fr`并 deinit aec_lib
	devctrl_try_destroy_dev(dev);
		list_del(&dev->node);	//从`audiobox_devlist`链表中移除dev
		devctrl_deactivate_server()
			audio_release_devserv(dev); //退出capture server线程
			apu_fr_free(dev, &dev->dev_fr_para); //释放`dev_fr`
			apu_fr_free(dev, &dev->dev_fr_para_mapped); //释放`dev_fr_mapped`
			audio_hal_close(dev); //关闭PCM设备
```


```cpp
int audiobox_get_channel(struct event_scatter *event)
	... //调整校验音频通道和设备参数
	devctrl_create_dev()
		devctrl_alloc_dev()//申请并初始化dev管理信息
		devctrl_activate_server()
			audio_hal_open()//为设备启动放音PCM设备
			devctrl_alloc_devfr()//为设备申请`dev_fr`
			audio_create_devserv()//启动playback server线程
		list_add_tail(&dev->node, &audiobox_devlist);//dev添加到`audiobox_devlist`链表
	... //申请并初始化channel管理信息
	apu_codec_create()
		apu_fr_alloc(dev, &chn->channel_fr, FR_NAME_CHAN_PREFIX); //为通道申请`chan_fr`
		__apu_codec_create(chn);
			... //申请并初始化codec管理信息
			apu_codec_prepare()
				apu_fr_alloc(dev, &p_codec->codec_fr_para, FR_NAME_CODEC_PREFIX);//为codec子模块申请`codec_fr`
				softvol_apu_open(apu_handle); //申请softvol子模块
				recombiner_apu_open(apu_handle); //申请recombine子模块
				codec_apu_open(apu_handle); //申请codec子模块
			list_add_tail(&chn->chn_node, &p_codec->vchanlist);//通道添加到codec的通道链表
			list_add_tail(&p_codec->node, &dev->apulist); //codec添加到设备的codec链表
		apu_codec_start(chn); //启动设备统一的解码处理线程
	list_add_tail(&chn->node, &dev->head); //channel添加到dev的通道链表
```

```cpp
int audiobox_get_channel(struct event_scatter *event)
	... //调整校验音频通道和设备参数
	... //申请并初始化channel管理信息
	apu_codec_create()
		apu_fr_alloc(dev, &chn->channel_fr, FR_NAME_CHAN_PREFIX); //为通道申请`chan_fr`
		__apu_codec_create(chn);
			... //申请并初始化codec管理信息
			apu_codec_prepare()
				apu_fr_alloc(dev, &p_codec->codec_fr_para, FR_NAME_CODEC_PREFIX);//为codec子模块申请`codec_fr`
				softvol_apu_open(apu_handle); //申请softvol子模块
				recombiner_apu_open(apu_handle); //申请recombine子模块
				codec_apu_open(apu_handle); //申请codec子模块
			list_add_tail(&chn->chn_node, &p_codec->vchanlist);//通道添加到codec的通道链表
			list_add_tail(&p_codec->node, &dev->apulist); //codec添加到设备的codec链表
		apu_codec_start(chn); //无实际操作，因为解码线程之前已启动
	list_add_tail(&chn->node, &dev->head); //channel添加到dev的通道链表
```

```cpp
int __audiobox_put_channel(int id)
	remove_chan_node(dev, chn);
		list_del(&chn->node); //从dev通道链表中移除通道
	apu_codec_destroy(chn);
		apu_fr_free(dev, &chn->channel_fr); //释放`chan_fr`
		list_del(&p_codec->node); //从dev的codec链表中移除codec
		apu_codec_unprepare(p_codec, 1);
			softvol_apu_close(p_codec); //关闭softvol子模块
			codec_apu_close(p_codec); //关闭codec子模块
			recombiner_apu_close(p_codec); //关闭recombiner子模块
      apu_fr_free(dev, &p_codec->codec_fr_para); //释放`codec_fr`
		free(p_codec);
	free(chn);
```

```cpp
int __audiobox_put_channel(int id)
	remove_chan_node(dev, chn);
		list_del(&chn->node); //从dev通道链表中移除通道
	apu_codec_destroy(chn);
		apu_fr_free(dev, &chn->channel_fr); //释放`chan_fr`
		list_del(&p_codec->node); //从dev的codec链表中移除codec
		apu_codec_unprepare(p_codec, 1);
			softvol_apu_close(p_codec); //关闭softvol子模块
			codec_apu_close(p_codec); //关闭codec子模块
			recombiner_apu_close(p_codec); //关闭recombiner子模块
      apu_fr_free(dev, &p_codec->codec_fr_para); //释放`codec_fr`
		free(p_codec);
    pthread_join(dev->decoder_pid, NULL);
	free(chn);
	devctrl_try_destroy_dev(dev);
		list_del(&dev->node);	//从`audiobox_devlist`链表中移除dev
		devctrl_deactivate_server()
			audio_release_devserv(dev); //退出playback server线程
			apu_fr_free(dev, &dev->dev_fr_para); //释放`dev_fr`
			audio_hal_close(dev); //关闭PCM设备
```

**01-27**<br>
背景音的播放，应该永不停息，前景音播放多少，背景音就跳过多少，这样，方便音视频同步的处理，也更加自然符合逻辑。这样，只需要计算播放了多少帧，中间填充了多少静音，就可以计算得到准确的播放延时。

**01-25**<br>
音视频同步播放的问题，在audiobox中增加一个新的api，获取当前fr和alsa中总计累积的音频帧对应`时间`，注意是`时间`，输入参数为通道handle
精度需要保证，因而，需要直接读取dma当前位置信息。放音时因为采用了静音填充，故而可以考虑设置创建通道时候播放第一帧时候时间为0，时间轴单调递增。获取到的时间戳应该是dma播放的时间时间，直接在`imapx_audio_buffdone()`函数中，累加放音时间；
int imapx_pcm_new(struct snd_soc_pcm_runtime *rtd)函数中，为`pcm->card->dev` SNDRV_PCM_STREAM_PLAYBACK 设备增加一个device_file提供当前真实高精度时间戳
audiobox提供函数接口，参数为通道，从通道得到设备名称，然后得到设备id，然后直接读取device_file,可以避免eventhub机制的低效干扰。
另外，这样获取到的时间，是绝对播放时间，而不是通道自己的相对播放时间。比如，如果通道数据underrun，下层自动填充静音，那么，上下理解时间上可能不同。
音视频同步，应该发生在播放文件的场景。

增加fill silence计数，这样就知道播放的实际音频帧的个数了；这可以通过提供一个相对时间戳来实现，上面的是绝对时间戳。一般来说，应该通过相对时间戳来实现音视频同步控制。

视频播放线程应该只需要关心当前已经播放了多少个音频帧。
在下层统计的话，需要考虑到可能存在插入的前景播放的影响。
当前通道已经播放的，可以通过audiobox中fr的残留总大小，加上当前alsa buffer总的残留大小，参考当前通道历史总大小，估算得到当前正在播放的音频的时间戳。

放音时，多个同类通道，应该是禁止的，或者，不需要考虑这种场景了；也就是说，如果当前已经有了一个背景音通道，创建新的背景音通道会失败。否则，处理上会有非常烦人的事情。
前景音通道，应该无所谓音视频同步问题；对于背景音通道，所有的插入的前景音通道时间和帧率，都应该计算入。

根据当前设备当前背景音通道和所有当前前景音通道fr剩余数据，和alsa buffer剩余数据，和dma中Position，模拟计算，当前正在播放的音频帧的时间戳。如果大量插入前景音，可能导致得到荒谬的负值。

音视频同步烦人的因素：
1. 填充静音
2. 其他通道
3. xrun

**01-24**<br>
填充静音影响因素：
1. aecv2时，reserve number
2. snd_pcm_update_hw_ptr0()函数中，runtime->status->hw_ptr = new_hw_ptr;位置影响
3. dma的buffer的period总个数

## 01-14->...
数据结构章节中包含基本数据结构和fr两个部分

数据结构章节中，画图，描述下面链表结构：
struct audio_dev {
  struct list_head node;//dev的节点
	struct list_head head; //channel链表头部
	struct list_head apulist; //apu链表头

  int fr_total_size; //dev已经占用的fr大小
  int foreground_chan_counter;//没有存在的必要，如果有前景音播放，申请通道应该直接失败的。

struct audio_chn {
  struct list_head node;
  struct list_head chn_node;//node for vchanlist in apu.

typedef	struct	_apu_codec_{
  struct list_head node;    //节点 --> apulist
	struct list_head vchanlist; //list of capture channels referring to this codec //只有录音

4个dev
图中，4个channel应该有两个通道参数完全一致的，另外两个参数不一致；对应3个 codec 节点

放音图，录音图分开

然后，结构体中定义的主要单元，大概描述一下。


## 01-07->...
  cd ~/work/qsdkdoc/psdocs/qsdk/books/pg-audiobox

改变master_volume，可以在devfr之前或者之后，但额外进行了一次运算。

**01-11**<br>
struct audio_dev {
**01-10**<br>
设计文档：
- audiobox启动过程，eventhub
- 录音过程： devfr aec softvol recombine encoder
- 放音过程： decoder recombine softvol devfr
- fr定义
- apu概念： softvol recombine codec，录音时关联到codecfr，放音时关联到devfr
- 创建通道流程： 通道参数校验，申请fr，初始化alsa，启动线程
- 录音capture线程，mapped处理线程，aec线程，apucodec对应的编码线程，而非每个channel对应一个thread.
- 放音线程

需要解析流程的几个主要函数：
- audiobox_get_channel
- audiobox_activate_channel
- audiobox_set_format
- audiobox_enable_aec
-

```cpp
//--- 启动设备：
audio_dev_t devctrl_create_dev(char *dev_name, audio_dev_attr_t *attr)
  dev = devctrl_alloc_dev(dev_name, attr);//申请并初始化设备管理数据结构
  devctrl_activate_server(dev);//int devctrl_activate_server(audio_dev_t dev)
    audio_hal_open(dev);
    devctrl_alloc_devfr(dev);//申请dev_fr_para，AEC2.0会额外申请dev_fr_para_mapped
    audio_create_devserv(dev);//启动设备层录音或放音线程
//--- 启动设备：
```
画图呢，还是用代码流程来表示。

基本数据结构，好像无必要再详细描述

```cpp
//2.1 立体数据结构
//下面关系，是否应该给出示意图
LIST_HEAD(audiobox_devlist); //设备链表
  struct audio_dev
    struct list_head node; //添加到audiobox_devlist的本身node
    struct list_head head; //有效channel链表
    struct list_head apulist; //apu codec链表

    apu_codec_t
      list_add_tail(&chn->chn_node, &p_codec->vchanlist);

内部实现：
```

```cpp
//2.2 fr定义和图
先描述基本的fr定义介绍
fr访问的基本模式： get - proc - put 不需要体现在文档中
某些函数，如果需要详细解析，可以在泳道下面增加新的图
```
```cpp
//2.3 基本的处理模块介绍

```
融合了线程和处理流程和fr数据结构，使用fr名称来代表fr
能否使用纵坐标作为fr来区分呢？

怎么插入线程呢？
alsa --(thread::audio_hal_read())> devfr --()> aecfr --> codecfr --> chanfr

横坐标为线程或者模块：
  alsa lib ++ thread_audio_capture_server线程 ++ thread_audio_capture_server_mapped线程 ++

  线程之间为

函数处理流程和fr数据流程结合为一：
- 通道创建过程
- 通道销毁过程
- set_format过程
- 各种通道类型对应流程

--- 启动录音设备：

录音和放音全路径介绍，带图

// 章节：audiobox中管理数据结构和管理方式
// 章节：audiobox中的fr

描述fr在audiobox设计中的作用，然后绘制一个最长路径录音和放音。

然后，列出所有的fr，描述作用，还有命名规则

fr定义：
//struct audio_dev
- struct	_apu_frnode_ dev_fr_para; //vacant fr for playback dev, real fr for capture.dev
- struct	_apu_frnode_ dev_fr_para_mapped; //
- struct	_apu_frnode_ dev_preprocfr_para;//for capture dev, aec proc output fr; no use for playback.dev
//struct audio_chn
- struct	_apu_frnode_ channel_fr;
//struct	_apu_codec_
- struct	_apu_frnode_ codec_fr_para; //encoder and decoder out fr

设计文档：
- 1.优化效率，录音放音通道和设备参数相同时，hal到channel之间只需要一次数据拷贝
- 2.设备帧和通道帧非一一对应时，增加recombine模块重新组帧处理，之前处理避开这个问题，无视应用层采样点大小设定。
- 3.放音过程调用audio_put_chanel销毁最后一个通道时，播放完所有帧再退出playback server，以保证体验
- fr命名规则

放音：
- chanfr -> codecfr (by chan_codec) -> devfr(softvol recombine)
- chanfr -> devfr

录音，使能aec:
- devfr -> aecfr -> codecfr -> chanfr
- devfr -> aecfr -> chanfr

录音2.0：
- devfr -> mappedfr -> codecfr -> chanfr
- devfr -> mappedfr -> chanfr

录音1.0：
- devfr -> codecfr -> chanfr
- devfr -> chanfr

**01-09**<br>
整理audiobox_v2文档；设备参数限制：
- if(dev->attr.samplingrate > (MAX_FRAME_RATE*dev->attr.sample_size))
- 采样率当前只支持8k的整数倍
- channel：必须为 2
- bitwidth : 16或32
- sample_size : 最大为samplingrate/40
**01-08**<br>
audio相关的bug列表:
- [APOLLO3] audio codec驱动开发验证 功能 #2392
- QSDK:[Allchip][BSP]对audiobox的需求进行分析 功能 #4782
- QSDK:[Allchip][MID]添加ISP实时信息查询 功能 #4425
- QSDK:[Allchip][BSP]Audiobox 优化 功能 #4719
- BU1: auido frame timestamp error 错误 #4737

设备参数确定方式支持不关闭通道调用 audio_set_format() 改变设备参数

**01-07**<br>
增加的函数接口只有两个：
  int audio_get_channel_ex(const char *dev, audio_chn_fmt_t *chn_fmt, int flag)
  int audio_enhance_mode(void)
  增强模式和兼容模式

## 小熊湿疹
静安牙防所，早上7点开始排队，7点45开始挂号，8点开始门诊，儿童必须本人到场。
1. 皮肤清洁也很重要，不要怕洗澡，洗完澡之后马上用一些保湿霜润肤
    全身保湿; 应该使用酸性的沐浴，避免碱性肥皂; 秋冬季节干燥，润肤剂尤其要保持使用; 避免冷风或强烈日晒
2. 饮食控制．多食蔬菜和水果，禁止海苔海带海鱼，酸奶，冰淇淋等冷饮，肥肉、奶油蛋糕、巧克力
3. 生活环境控制：最近的换床会否有影响呢? 每周更换床单和枕巾等。
    尽量不要养宠物，尽量不要种鲜花，不要用地毯
    家里也不要养花了。 纯棉的衣服，不要让宝宝穿易刺激皮肤的衣服，如羊毛、丝、尼龙; 修短指甲
4. 主动治疗：是否需要做脱敏治疗呢？
5. 放大镜找螨虫

**得了湿疹吃什么好**<br>
　　番茄。番茄内含丰富的维生素A、维生素B1、维生素B2、维生素C、烟酸，维生素E;还含有苹果酸、柠檬酸，钙、磷、铁及番茄碱等物质。具有生津止咳、健胃消食、凉血平肝、清热等功效。番茄中的果酸对维生素C有保护作用，故而能有效地补充维生素C;番茄碱有抑菌消炎、降低血管通透性作用，所以外用番茄汁治疗湿疹可起到止痒收敛的作用。
　　苦瓜。苦瓜内含奎宁。具有清热解毒、祛湿止痒之功。可用于治疗热毒、疖疮、痱子、湿疹等病症。
　　韭菜。韭菜内含胡萝卜素、维生素B、维生素C及钙。磷、铁、蛋白质、纤维素等。韭菜还有解毒祛湿的功效，故韭菜汁外搽可治湿疹。

钙磷酸酶抑制剂 不含激素，据说效果不错，但比较贵。

主持人：特应性皮炎药物治疗配合润肤剂剂使用频率是什么样的？
顾恒：首先，皮肤干燥是特应性皮炎的诊断标准之一，因此每天使用润肤剂是必不可少的。不同的季节可以选择不同类型的润肤剂，在冬季可以使用油脂性强一点的润肤剂，到了夏季可以使用稍微稀润一点或者油脂性弱一点的润肤剂。如果一些患者病情反复发作，发病比较频繁，可以使用钙调磷酸酶抑制剂这些能够安全有效，且可以长期使用的外用药物治疗。并且在控制住病情后，改用一周2次的长期维持治疗来减少复发频率和严重程度。钙调磷酸酶抑制剂不会出现使用激素类药物的皮肤萎缩、毛细血管扩张不良反应。

正确治疗有五部曲，在经过正确的治疗后，特应性皮炎是可以得到控制和缓解，这样花的代价最小，副反应也是最小。
1.首先，皮肤日常基本护理就是要保护皮肤，使受损的皮肤屏障功能慢慢恢复。通过使用保湿霜或者润肤露都可以起到保护皮肤湿润的功能。另外，皮肤清洁也很重要，不要怕洗澡，洗完澡之后马上用一些保湿霜润肤。
2.其次就是基本的药物治疗，基本的药物治疗就是外用药，对于儿童特应性皮炎患者，一般选用温和的中效或者弱效激素，而不要选用强效激素或者含卤素元素的激素。同时还可以用非激素类药膏，代表就是他克莫司软膏。
3.另外，根据症状，如果瘙痒的非常严重，可以吃一些镇静类的药物，镇静药物可以用西利琴或者罗瑞它丁。如果这些治疗不能完全缓解控制疾病，就需要系统治疗，比如内服激素类药物和免疫抑制剂药物。如果合并细菌感染，则同时需要用一些局部的抗生素软膏进行治疗


公司腾讯企业邮箱。微信客户端绑定密码 : ooErfMAnogvZeWtL

密码管理：
需要修改密码的项目：　qq 微信　支付宝　工商银行　招商银行　印象笔记　网易邮箱和云　百度云百度账号　
需要管理的支付密码：　工商银行　招商银行　微信红包　
所有的技术和论坛，都是用　ericyun110322    ，密码　为　中学　１　３　３　应该不会需要用大写的情况，而且也够长。１１个字符刚好。
无所谓的普通的信息和公司密码，爱家，快捷方便为主啊
印象笔记非常重要的个人笔记， 活期通, 微信，支付宝，银行等相关的

dd if=/dev/zero of=/dev/spiblock0 bs=1M count=1
dd if=/dev/zero of=/dev/mmcblk0 skip=16M bs=1M count=1

ipcs -q　获取消息队列表，然后根据key，进入队列，从队列中查询，从队列中删除。

audio驱动当前缺少32khz的支持； audiobox_set_chn_mute 函数现在实际上是无效的

printk(KERN_EMERG "~~~(%s, %d)~~~\n", __func__, __LINE__);

.mk .pc文件
depends on BR2_PRIMARY_SITE != ""
depends on BR2_EXTERNAL != "buildroot/support/dummy-external"
select BR2_PACKAGE_SSTRIP_HOST
depends on !BR2_PACKAGE_HOST_ELF2FLT
default "$(TOPDIR)/buildroot/local.mk"

显示下次make将会编译的所有目标，这样方便调试。
    make show-targets;make help;make pkg-source;//pkg只下载; make pkg-extract;//pkg只下载和解压但不编译，可以在output/build/目录中修改后编译

## 当前任务备忘
**守则**<br>
!!!! 讨论，是否强制留校
晚上做作业定闹钟35分钟，中间不可以吃东西喝水上厕所；
晚上课间休息5-10分钟，可以看书吃东西聊天打球
周一到周五不可以玩游戏，看电视
ipad上只能装一个游戏；一周最多可以更换一次安装的游戏

**湿疹**<br>
洗手,凉白开去除氯胺,加白醋中和PH值(计算好兑换比例);
洗澡,水温尽量不要高;减少洗澡次数;减少洗澡时间;洗头和洗澡分开,看能否干洗
测试ph值: 1.凉水(每周测试一次) 2.热开水 3.凉开水 4. 洗澡水 5.
维生素C 是否可以用于去除水中的氯;
白醋和氯是否会反应生成有害物质
安装净水器或者使用净水壶
常吃油炸食物的人，其皮肤病的发病率远远高于不吃或极少进食油炸食物的人群。缺乏维生素、矿物质、纤维素等营养，持久食用也会对身体造成风险。这些食物中含有较高的油脂和氧化物质，经常进食易导致血热、血燥，诱发皮肤病。

这是一种过敏性的局部皮肤炎表现，真菌感染、过敏症状、精神压力、湿热的天气等都可能引发。

化学清洁剂的伤害也是一个很重要的原因，洗衣粉、洗洁精这些化学清洁剂会破坏皮肤的屏障功能，天气和体质的内因，遇上清洁剂的刺激，就容易诱发汗疱疹。
金银花有着清热解毒的功效，在炎热的夏季可以经常看见用金银花泡茶喝的人，能够缓解人体内各地方的炎症问题，起到抗菌消炎的作用

适度保湿 : 1、皮肤是抵御外部真菌的前线战士，洗手时避免用过热的水，使用温和的清洁产品、洗手后将手擦干，但不宜过度清洁。2、可使用温和保湿成分护手霜，在洗手后使用。

勤动动
避免吸烟、喝酒、熬夜习惯
  长期生活在湿热环境中; 长期情绪压抑; 经常吃辛辣，油腻，烧烤，煎炸，冰冷食物

血糖，血脂过高都可以归结为湿气重浊。

祛湿的四大禁忌: 凉食冷饮 经常吹空调 熬夜 嗜酒

两种除湿方向:
  第一种，这种方法其实就是中医说的淡渗利湿，服用茯苓、泽泻、薏米、赤小豆、莲子等都属于这种方法，这些药物或食物都有比较好的效果，但这种方法也有致命的缺点，即能除掉已经生成的湿，不能防止湿邪的再次形成，在一定程度上来说解决不了根本问题。
  第二种方法，疏通气机。前面说了湿邪的本质特征就是缓，什么能克制缓呢？当然是急。在五脏中，肝木是急的，脾土是缓的，所以五行生克中的木能克土就是这个意思。一个慢性子的人整天懒得动，这时要让一个急性子的人带动他一下。这样第二种方法的具体实施就是健脾疏肝，健脾是为了增强懒人的实力，让他有力气运动；疏肝是让机体的节奏变快一些，整个气机流动起来，这样一来湿邪就祛除了。健脾可以选用六君子汤，疏肝可选用香附、苏梗、郁金、白芍等药物.现代的这种湿和古代不一样，古人劳作的多，湿邪多由外部侵入，属于外湿，用第一种方法效果非常好。现代人湿的根源是懒，所以第二种方法更为合适.

**内湿的形成和防治**<br>
**形成**
过食肥甘，嗜烟好酒；恣食生冷，内伤脾胃，致使脾失健运，不能为胃行其津液。
喜静少动，素体肥胖；情志抑郁，气机不利，致津液输布障碍，聚而成湿。
纵欲过度，房事不节；肾阳虚衰，脾失温煦，致脾阳虚津液不化，而湿浊内生。
**防**
少吃甜食、肉类、动物油，可以使人体气血顺畅，而水湿输布顺畅；
戒烟限酒，不损肺及脾胃，则水液输布、运化正常；
坚持适当运动。动则为阳，水湿痰饮皆为阴邪，唯气血流畅运行方可使阴邪不滞留体内；
乐观豁达，保持良好情绪，肝气调达，气机疏泄正常，则脾胃不受肝克，而气机顺畅，痰湿运化正常；
节欲养精，肾气充足，则元阳充足而能温煦脾胃，使津液水湿运化如常。
**药**
对于肝气犯胃而引起的脾胃功能失调如胃脘胀满，攻撑作痛，脘痛连胁，胸闷嗳气，喜长叹息，大便不畅或黏腻者，可用舒肝和胃丸治疗。如反酸胃痛，胃内烧灼感者，可用加味左金丸治疗。
