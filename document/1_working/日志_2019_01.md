# 工作日志

### 修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2019/01/07 | 员清观 |  |

## misc
`nautilus .` 可以用来从终端启动文件管理器并切换到当前文件夹

如果同时使能`arm-lib`和`dsp-lib`，可以通过audiobox命令行`-a`参数确定audiobox实际激活的lib:
- 命令行不包含`-a`参数，使能`dsp-lib`
- 通过'-a dsp'参数，使能`dsp-lib`
- 通过'-a speex'参数，使能`arm-lib(speexdsp)`

audio_put_frame()`与`audio_get_frame()`改变
aecv2_controler 改变为struct imapx_runtime_data *prtd中一个结构。这样，多codec的系统也可以支持。通过card_id来区分不同的codec。要求获取当前播放偏移的时候，通过card_id访问不同控制device文件。aec功能开启关闭，可以通过card_id指定，两者暂时需要保持一致，因为没有接口提供分别配置。

应该提供背景音通道rewind功能，背景音通道应该保持不断播放
填充的静音，应该是对所有逻辑通道都有意义的

公司腾讯企业邮箱。微信客户端绑定密码 : ooErfMAnogvZeWtL

密码管理：
需要修改密码的项目：　qq 微信　支付宝　工商银行　招商银行　印象笔记　网易邮箱和云　百度云百度账号　
需要管理的支付密码：　工商银行　招商银行　微信红包　
所有的技术和论坛，都是用　ericyun110322    ，密码　为　中学　１　３　３　应该不会需要用大写的情况，而且也够长。１１个字符刚好。
无所谓的普通的信息和公司密码，爱家，快捷方便为主啊
印象笔记非常重要的个人笔记， 活期通, 微信，支付宝，银行等相关的

dd if=/dev/zero of=/dev/spiblock0 bs=1M count=1
dd if=/dev/zero of=/dev/mmcblk0 skip=16M bs=1M count=1

ipcs -q　获取消息队列表，然后根据key，进入队列，从队列中查询，从队列中删除。


## 当前任务备忘

## 01-21->...
**01-27**<br>
背景音的播放，应该永不停息，前景音播放多少，背景音就跳过多少，这样，方便音视频同步的处理，也更加自然符合逻辑。这样，只需要计算播放了多少帧，中间填充了多少静音，就可以计算得到准确的播放延时。

**01-25**<br>
音视频同步播放的问题，在audiobox中增加一个新的api，获取当前fr和alsa中总计累积的音频帧对应`时间`，注意是`时间`，输入参数为通道handle
精度需要保证，因而，需要直接读取dma当前位置信息。放音时因为采用了静音填充，故而可以考虑设置创建通道时候播放第一帧时候时间为0，时间轴单调递增。获取到的时间戳应该是dma播放的时间时间，直接在`imapx_audio_buffdone()`函数中，累加放音时间；
int imapx_pcm_new(struct snd_soc_pcm_runtime *rtd)函数中，为`pcm->card->dev` SNDRV_PCM_STREAM_PLAYBACK 设备增加一个device_file提供当前真实高精度时间戳
audiobox提供函数接口，参数为通道，从通道得到设备名称，然后得到设备id，然后直接读取device_file,可以避免eventhub机制的低效干扰。
另外，这样获取到的时间，是绝对播放时间，而不是通道自己的相对播放时间。比如，如果通道数据underrun，下层自动填充静音，那么，上下理解时间上可能不同。
音视频同步，应该发生在播放文件的场景。

增加fill silence计数，这样就知道播放的实际音频帧的个数了；这可以通过提供一个相对时间戳来实现，上面的是绝对时间戳。一般来说，应该通过相对时间戳来实现音视频同步控制。

视频播放线程应该只需要关心当前已经播放了多少个音频帧。
在下层统计的话，需要考虑到可能存在插入的前景播放的影响。
当前通道已经播放的，可以通过audiobox中fr的残留总大小，加上当前alsa buffer总的残留大小，参考当前通道历史总大小，估算得到当前正在播放的音频的时间戳。

放音时，多个同类通道，应该是禁止的，或者，不需要考虑这种场景了；也就是说，如果当前已经有了一个背景音通道，创建新的背景音通道会失败。否则，处理上会有非常烦人的事情。
前景音通道，应该无所谓音视频同步问题；对于背景音通道，所有的插入的前景音通道时间和帧率，都应该计算入。

根据当前设备当前背景音通道和所有当前前景音通道fr剩余数据，和alsa buffer剩余数据，和dma中Position，模拟计算，当前正在播放的音频帧的时间戳。如果大量插入前景音，可能导致得到荒谬的负值。

音视频同步烦人的因素：
1. 填充静音
2. 其他通道
3. xrun

**01-24**<br>
填充静音影响因素：
1. aecv2时，reserve number
2. snd_pcm_update_hw_ptr0()函数中，runtime->status->hw_ptr = new_hw_ptr;位置影响
3. dma的buffer的period总个数

## 01-14->...
数据结构章节中包含基本数据结构和fr两个部分

数据结构章节中，画图，描述下面链表结构：
struct audio_dev {
  struct list_head node;//dev的节点
	struct list_head head; //channel链表头部
	struct list_head apulist; //apu链表头

  int fr_total_size; //dev已经占用的fr大小
  int foreground_chan_counter;//没有存在的必要，如果有前景音播放，申请通道应该直接失败的。

struct audio_chn {
  struct list_head node;
  struct list_head chn_node;//node for vchanlist in apu.

typedef	struct	_apu_codec_{
  struct list_head node;    //节点 --> apulist
	struct list_head vchanlist; //list of capture channels referring to this codec //只有录音

4个dev
图中，4个channel应该有两个通道参数完全一致的，另外两个参数不一致；对应3个 codec 节点

放音图，录音图分开

然后，结构体中定义的主要单元，大概描述一下。


## 01-07->...
  cd ~/work/qsdkdoc/psdocs/qsdk/books/pg-audiobox

改变master_volume，可以在devfr之前或者之后，但额外进行了一次运算。

**01-11**<br>
struct audio_dev {
**01-10**<br>
设计文档：
- audiobox启动过程，eventhub
- 录音过程： devfr aec softvol recombine encoder
- 放音过程： decoder recombine softvol devfr
- fr定义
- apu概念： softvol recombine codec，录音时关联到codecfr，放音时关联到devfr
- 创建通道流程： 通道参数校验，申请fr，初始化alsa，启动线程
- 录音capture线程，mapped处理线程，aec线程，apucodec对应的编码线程，而非每个channel对应一个thread.
- 放音线程

需要解析流程的几个主要函数：
- audiobox_get_channel
- audiobox_activate_channel
- audiobox_set_format
- audiobox_enable_aec
-

```cpp
//--- 启动设备：
audio_dev_t devctrl_create_dev(char *dev_name, audio_dev_attr_t *attr)
  dev = devctrl_alloc_dev(dev_name, attr);//申请并初始化设备管理数据结构
  devctrl_activate_server(dev);//int devctrl_activate_server(audio_dev_t dev)
    audio_hal_open(dev);
    devctrl_alloc_devfr(dev);//申请dev_fr_para，AEC2.0会额外申请dev_fr_para_mapped
    audio_create_devserv(dev);//启动设备层录音或放音线程
//--- 启动设备：
```
画图呢，还是用代码流程来表示。

基本数据结构，好像无必要再详细描述

```cpp
//2.1 立体数据结构
//下面关系，是否应该给出示意图
LIST_HEAD(audiobox_devlist); //设备链表
  struct audio_dev
    struct list_head node; //添加到audiobox_devlist的本身node
    struct list_head head; //有效channel链表
    struct list_head apulist; //apu codec链表

    apu_codec_t
      list_add_tail(&chn->chn_node, &p_codec->vchanlist);

内部实现：
```

```cpp
//2.2 fr定义和图
先描述基本的fr定义介绍
fr访问的基本模式： get - proc - put 不需要体现在文档中
某些函数，如果需要详细解析，可以在泳道下面增加新的图
```
```cpp
//2.3 基本的处理模块介绍

```
融合了线程和处理流程和fr数据结构，使用fr名称来代表fr
能否使用纵坐标作为fr来区分呢？

怎么插入线程呢？
alsa --(thread::audio_hal_read())> devfr --()> aecfr --> codecfr --> chanfr

横坐标为线程或者模块：
  alsa lib ++ thread_audio_capture_server线程 ++ thread_audio_capture_server_mapped线程 ++

  线程之间为

函数处理流程和fr数据流程结合为一：
- 通道创建过程
- 通道销毁过程
- set_format过程
- 各种通道类型对应流程

--- 启动录音设备：

录音和放音全路径介绍，带图

// 章节：audiobox中管理数据结构和管理方式
// 章节：audiobox中的fr

描述fr在audiobox设计中的作用，然后绘制一个最长路径录音和放音。

然后，列出所有的fr，描述作用，还有命名规则

fr定义：
//struct audio_dev
- struct	_apu_frnode_ dev_fr_para; //vacant fr for playback dev, real fr for capture.dev
- struct	_apu_frnode_ dev_fr_para_mapped; //
- struct	_apu_frnode_ dev_preprocfr_para;//for capture dev, aec proc output fr; no use for playback.dev
//struct audio_chn
- struct	_apu_frnode_ channel_fr;
//struct	_apu_codec_
- struct	_apu_frnode_ codec_fr_para; //encoder and decoder out fr

设计文档：
- 1.优化效率，录音放音通道和设备参数相同时，hal到channel之间只需要一次数据拷贝
- 2.设备帧和通道帧非一一对应时，增加recombine模块重新组帧处理，之前处理避开这个问题，无视应用层采样点大小设定。
- 3.放音过程调用audio_put_chanel销毁最后一个通道时，播放完所有帧再退出playback server，以保证体验
- fr命名规则

放音：
- chanfr -> codecfr (by chan_codec) -> devfr(softvol recombine)
- chanfr -> devfr

录音，使能aec:
- devfr -> aecfr -> codecfr -> chanfr
- devfr -> aecfr -> chanfr

录音2.0：
- devfr -> mappedfr -> codecfr -> chanfr
- devfr -> mappedfr -> chanfr

录音1.0：
- devfr -> codecfr -> chanfr
- devfr -> chanfr

**01-09**<br>
整理audiobox_v2文档；设备参数限制：
- if(dev->attr.samplingrate > (MAX_FRAME_RATE*dev->attr.sample_size))
- 采样率当前只支持8k的整数倍
- channel：必须为 2
- bitwidth : 16或32
- sample_size : 最大为samplingrate/40
**01-08**<br>
audio相关的bug列表:
- [APOLLO3] audio codec驱动开发验证 功能 #2392
- QSDK:[Allchip][BSP]对audiobox的需求进行分析 功能 #4782
- QSDK:[Allchip][MID]添加ISP实时信息查询 功能 #4425
- QSDK:[Allchip][BSP]Audiobox 优化 功能 #4719
- BU1: auido frame timestamp error 错误 #4737

设备参数确定方式支持不关闭通道调用 audio_set_format() 改变设备参数

**01-07**<br>
增加的函数接口只有两个：
  int audio_get_channel_ex(const char *dev, audio_chn_fmt_t *chn_fmt, int flag)
  int audio_enhance_mode(void)
  增强模式和兼容模式
