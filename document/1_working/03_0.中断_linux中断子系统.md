# 部门研发制度规定

## 0 修订记录1
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2018/04/10 | 员清观 |  |

## 1 中断子系统一些基本概念

可以查看linux系统中中断统计信息：　`cat /proc/interrupts`

**一些基本概念：**
- 硬中断（外部中断）：通过外部设备接口，向CPU的中断请求引脚INT和NMI发中断请求产生
- 软中断（内部中断）：CPU内部执行中断指令，或由运算溢出，TF（Trap Falg，每执行一条指令，自动产生一个内部中断去执行一个中断服务程序）标志而产生
- 可屏蔽中断（INT）
- 不可屏蔽中断（NMI）
- 向量中断：不同的中断分配不同的中断号，有不同的入口地址，硬件提供
- 非向量中断：多个中断共享一个入口地址，再通过中断标志识别具体哪个中断，软件提供

中断处理程序是在关掉其他所有中断的情况下进行，执行于硬件相关的处理要求快，而有些驱动在中断处理程序中又需要完成大量的工作，这就矛盾了。这需要在这两者间找到一个平衡点，所以分解为两个部分。
- 顶半部（tophalf） 顶半部的功能是“登记中断”。顶半部尽可能快的完成比较急的功能，往往只是简单的读取寄存器中的中断状态并清除中断标志后进行“登记中断”即中断例程的底半部挂到该设备的底半部执行队列中去。这样顶半部执行的速度很快，能服务更多的中断请求. 申请和释放中断函数request_irq() 和 free_irq();
- 底半部(bottom half)  底半部来完成中断事件的绝大多数使命。顶半部与底半部最大的不同是，底半部是可中断的，顶半部不可中断。

一个`irq_domain`对应一个GIC控制器,

### 1.1 中断的申请和释放

```cpp
struct irq_domain_ops gic_irq_domain_ops = {
	.map = gic_irq_domain_map,
	.xlate = gic_irq_domain_xlate,
};
struct irq_chip gic_chip = { //gic_v2为硬件中断定义的方法集
	.name			= "GIC",
	.irq_mask		= gic_mask_irq, //屏蔽一个中断
	.irq_unmask		= gic_unmask_irq, //解除一个中断源的屏蔽操作
	.irq_eoi		= gic_eoi_irq, //发送EOI信号给中断控制器,表示硬件中断已经处理完毕
	.irq_set_type		= gic_set_type, //设置中断触发类型
	.irq_retrigger		= gic_retrigger, //重新发送中断到CPU
	.irq_set_wake		= gic_set_wake, //使能/关闭该中断在电源管理中的唤醒功能
};
struct gic_chip_data {
	union gic_base dist_base; union gic_base cpu_base;
	u32 saved_spi_enable[DIV_ROUND_UP(1020, 32)];
	u32 saved_spi_conf[DIV_ROUND_UP(1020, 16)];
	u32 saved_spi_target[DIV_ROUND_UP(1020, 4)];
	u32 __percpu *saved_ppi_enable; u32 __percpu *saved_ppi_conf;
	struct irq_domain *domain; //和irq_domain一一对应
	unsigned int gic_irqs;
};
struct irq_data {
	unsigned int		irq; unsigned long hwirq; unsigned int	node; unsigned int state_use_accessors;
	struct irq_chip		*chip;
	struct irq_domain	*domain;
	void			*handler_data;
	void			*chip_data;
	struct msi_desc		*msi_desc;
	cpumask_var_t		affinity;
};
struct irq_desc {
	struct irq_data		irq_data;
	unsigned int __percpu	*kstat_irqs;
	irq_flow_handler_t	handle_irq;
	struct irqaction	*action;	/* IRQ action list */
	unsigned int		status_use_accessors; unsigned int		core_internal_state__do_not_mess_with_it;
	unsigned int		depth; /* nested irq disables */
	unsigned int		wake_depth;	/* nested wake enables */
	unsigned int		irq_count;	/* For detecting broken IRQs */
	unsigned long		last_unhandled;	/* Aging timer for unhandled count */
	unsigned int		irqs_unhandled;
	raw_spinlock_t		lock;
	struct cpumask		*percpu_enabled;
	unsigned long		threads_oneshot;
	atomic_t		threads_active;
	wait_queue_head_t       wait_for_threads;
	struct proc_dir_entry	*dir;
	int			parent_irq;
	struct module		*owner;
	const char		*name;
} ;

struct irqaction {
	irq_handler_t		handler; //中断处理函数，注册时提供
	void			*dev_id;//设备id,用来区分中断源,中断处理函数的第二个参数
	void __percpu		*percpu_dev_id;
	struct irqaction	*next; //链接共享一个中断的几个action
	irq_handler_t		thread_fn; //线程化的中断处理
	struct task_struct	*thread;
	unsigned int		irq; //中断源, 中断处理函数的第一个参数
	unsigned int		flags;
	unsigned long		thread_flags;
	unsigned long		thread_mask;
	const char		*name;
	struct proc_dir_entry	*dir;
} ;
struct irq_domain_ops {
	int (*match)(struct irq_domain *d, struct device_node *node);
	int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);
	void (*unmap)(struct irq_domain *d, unsigned int virq);
	int (*xlate)(struct irq_domain *d, struct device_node *node, *intspec, intsize, *out_hwirq, *out_type);
};
struct irq_domain {
	struct list_head link;  //通过这个节点加入irq_domain_list链表
  unsigned int revmap_type;
  union {
		struct { unsigned int size;	unsigned int first_irq;	irq_hw_number_t first_hwirq; } legacy;
		struct { unsigned int size; unsigned int *revmap; } linear;
		struct { unsigned int max_irq; } nomap;
		struct radix_tree_root tree;
	} revmap_data;
	const struct irq_domain_ops *ops;
	void *host_data;
	irq_hw_number_t inval_irq;
  struct device_node *of_node; //对应中断控制器的device node
};

//每个gic控制器对应一个irq_domain,所以一般这个链表只有一个节点
static LIST_HEAD(irq_domain_list);  //irq_domain的链表
static struct irq_domain *irq_default_domain;

int nr_irqs = NR_IRQS;
static DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);
struct irq_desc irq_desc[NR_IRQS] = {
	[0 ... NR_IRQS-1] = {	.handle_irq	= handle_bad_irq, .depth		= 1, .lock		= __RAW_SPIN_LOCK_UNLOCKED(irq_desc->lock),	}
};
int irq_thread(void *data) //中断处理线程
	static const struct sched_param param = { .sched_priority = MAX_USER_RT_PRIO/2, };
	struct irqaction *action = data;
	struct irq_desc *desc = irq_to_desc(action->irq);
	irqreturn_t action_ret;
	sched_setscheduler(current, SCHED_FIFO, &param);
	init_task_work(&on_exit_work, irq_thread_dtor); task_work_add(current, &on_exit_work, false);
	while (!)
		|--> ret = irq_wait_for_interrupt(action);
			set_current_state(TASK_INTERRUPTIBLE);
			while (!kthread_should_stop()) //--> test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);
				if (test_and_clear_bit(IRQTF_RUNTHREAD, &action->thread_flags))
					__set_current_state(TASK_RUNNING); return 0;
				schedule();
				set_current_state(TASK_INTERRUPTIBLE);
			__set_current_state(TASK_RUNNING);
		if (ret) break;
		|--> action_ret = irq_thread_fn(desc, action);
			action->thread_fn(action->irq, action->dev_id); irq_finalize_oneshot(desc, action);
		if (!noirqdebug) note_interrupt(action->irq, desc, action_ret);
		|--> wake_threads_waitq(desc);//
			if (atomic_dec_and_test(&desc->threads_active) && waitqueue_active(&desc->wait_for_threads)) wake_up(&desc->wait_for_threads);
	task_work_cancel(current, irq_thread_dtor);

static inline int devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler, unsigned long irqflags, const char *devname, void *dev_id) //此函数申请的必然不是线程化处理
  |--> return devm_request_threaded_irq(dev, irq, handler, NULL, irqflags, devname, dev_id);
  //非线程化中断
  //int  devm_request_threaded_irq(struct device *dev, unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id)
    struct irq_devres *dr = devres_alloc(devm_irq_release, sizeof(struct irq_devres), GFP_KERNEL);
    |--> request_threaded_irq(irq, handler, thread_fn, irqflags, devname, dev_id);//irq是linux管理的虚拟中断号
      struct irq_desc *desc = irq_to_desc(irq); //--> (irq < NR_IRQS) ? irq_desc + irq : NULL; 简单的在数组中索引
      struct irqaction *action = kzalloc(sizeof(struct irqaction), GFP_KERNEL);
      action->handler = handler; action->thread_fn = thread_fn; action->flags = irqflags;
      action->name = devname; action->dev_id = dev_id;
      |--> __setup_irq(irq, desc, action);
        if (new->thread_fn && !nested)
          struct task_struct *t = kthread_create(irq_thread, new, "irq/%d-%s", irq, new->name);
          get_task_struct(t); new->thread = t; set_bit(IRQTF_AFFINITY, &new->thread_flags);
        //省略根据flags等参数配置中断控制器的操作部分
        ...; //把新的action添加到desc的action链表中
        __enable_irq(desc, irq, false);
        if (new->thread) wake_up_process(new->thread);
        register_irq_proc(irq, desc); new->dir = NULL; register_handler_proc(irq, new);//创建proc目录下中断
    dr->irq = irq;  dr->dev_id = dev_id;
    devres_add(dev, dr);
```

`request_irq()`这个函数是对`request_thread_irq()`的封装，它给`request_thread_irq()`的`thread_fn`参数传进了一个NULL，也就是只申请中断处理函数，不要`thread_fn`; `devm_request_threaded_irq`这个函数增加了对申请irq的dev的管理．

```cpp
//顶半部机制
//申请和释放中断函数request_irq() 和 free_irq()
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long irqflags, const char * devname, void *dev_id);
//irq是要申请的硬件中断号。handler是向系统登记的中断处理函数。这是一个回调函数，中断发生时，系统调用这个函数，传入的参数包括硬件中断号，device id，寄存器值。dev_id就是下面的request_irq时传递给系统的参数dev_id。irqflags是中断处理的一些属性。比较重要的有标明中断处理程序是快速处理程序(设置IRQF_DISABLED)还是慢速处理程序(不设置IRQF_DISABLED)。快速处理程序被调用时屏蔽所有中断。慢速处理程序不屏蔽。还有一个IRQF_SHARED属性，设置了以后运行多个设备共享中断。dev_id在中断共享时会用到。一般设置为这个设备的 device结构本身或者NULL。中断处理程序可以用dev_id找到相应的控制这个中断的设备，或者用irq2dev_map找到中断对应的设备。
void free_irq(unsigned int irq,void *dev_id);

//使能和屏蔽中断
void disable_irq(int irq)
void disable_irq_nosync(int irq)
void enable_irq(int irq)
//disable_irq()和disable_irq_nosync()的区别在于，后者立即返回，而且前者等待目前的中断处理完成。如果enable_irq()函数会引起系统死锁，这种情况下，只能使用disable_irq_nosync()
local_irq_save(flags)
local_irq_restore(flags)
//注意：保存的是数值，不是指针，因为flags是unsigned long类型，所以这对中断函数要在同一个函数中使用
```

linux kernel的中断子系统分成4个部分：
1. 硬件无关的代码，我们称之Linux kernel通用中断处理模块。无论是哪种CPU，哪种controller，其中断处理的过程都有一些相同的内容，这些相同的内容被抽象出来，和HW无关。此外，各个外设的驱动代码中，也希望能用一个统一的接口实现irq相关的管理（不和具体的中断硬件系统以及CPU体系结构相关）这些“通用”的代码组成了linux kernel interrupt subsystem的核心部分。
2. CPU architecture相关的中断处理。 和系统使用的具体的CPU architecture相关。
3. Interrupt controller驱动代码 。和系统使用的Interrupt controller相关。
4. 普通外设的驱动。这些驱动将使用Linux kernel通用中断处理模块的API来实现自己的驱动逻辑。

当外设触发一次中断后，一个大概的处理过程是：
1. 具体CPU architecture相关的模块会进行现场保护，然后调用machine driver对应的中断处理handler.--> ARM的IRQ异常,保护现场,调用中断handler
2、machine driver对应的中断处理handler中会根据硬件的信息获取HW interrupt ID，并且通过irq domain模块翻译成IRQ number.
3、调用该IRQ number对应的high level irq event handler，在这个high level的handler中，会通过和interupt controller交互，进行中断处理的flow control（处理中断的嵌套、抢占等），当然最终会遍历该中断描述符的IRQ action list，调用外设的specific handler来处理该中断
//中断控制器相关的处理.
4、具体CPU architecture相关的模块会进行现场恢复。

对于中断处理而言，linux将其分成了两个部分，一个叫做中断handler（top half），属于不那么紧急需要处理的事情被推迟执行，我们称之deferable task，或者叫做bottom half，。具体如何推迟执行分成下面几种情况：
1、推迟到top half执行完毕, 包括softirq机制和tasklet机制
2、推迟到某个指定的时间片（例如40ms）之后执行, softirq机制的一种应用场景（timer类型的softirq）
3、推迟到某个内核线程被调度的时候执行,包括threaded irq handler以及通用的workqueue机制和驱动专属kernel thread（不推荐使用）

软中断不会抢占另外一个软中断，唯一可以抢占软中断的是中断处理程序。软中断可以在不同CPU上并发执行(哪怕是同一个软中断)

## 2 中断处理过程
### 2.1 中断初始化相关
```cpp
struct gic_chip_data gic_data[MAX_GIC_NR]; //所有gic的总控制,但这里只需要看第一个.

void __init start_kernel(void)
  local_irq_disable();
  |--> setup_arch(&command_line);
    setup_processor();-->cpu_init();//初始化cpu stack
    |--> paging_init(mdesc);
      |--> devicemaps_init(mdesc); //static void __init devicemaps_init(struct machine_desc *mdesc) 加载中断向量表
        vectors = early_alloc(PAGE_SIZE);
        |--> early_trap_init(vectors); //完成中断向量表的拷贝工作
        	unsigned long vectors = (unsigned long)vectors_base; int kuser_sz = __kuser_helper_end - __kuser_helper_start;
        	vectors_page = vectors_base;
        	memcpy((void *)vectors, __vectors_start, __vectors_end - __vectors_start);
        	memcpy((void *)vectors + 0x200, __stubs_start, __stubs_end - __stubs_start);
        	memcpy((void *)vectors + 0x1000 - kuser_sz, __kuser_helper_start, kuser_sz); kuser_get_tls_init(vectors);
        	memcpy((void *)(vectors + KERN_SIGRETURN_CODE - CONFIG_VECTORS_BASE), sigreturn_codes, sizeof(sigreturn_codes));
        	flush_icache_range(vectors, vectors + PAGE_SIZE); modify_domain(DOMAIN_USER, DOMAIN_CLIENT);
        map.virtual = 0xffff0000; create_mapping(&map, false);
        fill_pmd_gaps(); local_flush_tlb_all(); flush_cache_all();
  early_irq_init(); //
  |--> init_IRQ();//-->machine_desc->init_irq();-->q3f_init_irq();-->gic_init(0, 29, IO_ADDRESS(IMAP_GIC_DIST_BASE), IO_ADDRESS(IMAP_GIC_CPU_BASE));-->gic_init_bases(nr, start, dist, cpu, 0, NULL);
    struct gic_chip_data *gic = &gic_data[gic_nr];
    gic->dist_base.common_base = dist_base; gic->cpu_base.common_base = cpu_base;
    for (i = 0; i < NR_GIC_CPU_IF; i++) gic_cpu_map[i] = 0xff;
    hwirq_base = 16; irq_start = 16; gic_irqs = readl_relaxed(gic_data_dist_base(gic) + GIC_DIST_CTR) & 0x1f;
    gic->gic_irqs = gic_irqs = 32; //得到的SPI的开始编号应该是32
    gic_irqs -= hwirq_base; //反正最后得到的是中断开始编号和中断个数
    |--> irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());//-->__irq_alloc_descs()
      start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS, from, cnt, 0);//找到连续的0空间,其实之前没有申请过,所以从第一个开始
      bitmap_set(allocated_irqs, start, cnt);
      |--> return alloc_descs(start, cnt, node, owner); //从数组中分配指定个数的irq)desc结构体
        for (i = 0; i < cnt; i++) struct irq_desc *desc = irq_to_desc(start + i); desc->owner = owner;
    |--> gic->domain = irq_domain_add_legacy(node, gic_irqs, irq_base,hwirq_base, &gic_irq_domain_ops, gic);
      |--> domain = irq_domain_alloc(of_node, IRQ_DOMAIN_MAP_LEGACY, ops, host_data);//申请一个domain并简单初始化
        domain = kzalloc_node(sizeof(*domain), GFP_KERNEL, of_node_to_nid(of_node));
        domain->revmap_type = revmap_type;	domain->ops = ops; domain->of_node = of_node_get(of_node);
        domain->host_data = host_data; //上文的struct gic_chip_data *gic, 之后配置给desc->irq_data.chip_data, 这样可以从irq索引到irq_desc,然后可以找到gic,找到domain,找到irq_chip操作行为
      for (i = 0; i < size; i++)
        struct irq_data *irq_data = irq_get_irq_data(first_irq + i);irq_data->hwirq = first_hwirq + i; irq_data->domain = domain;
      for (i = 0; i < size; i++)
        int irq = first_irq + i; 	int hwirq = first_hwirq + i;
        |--> ops->map(domain, irq, hwirq); //-->gic_irq_domain_map(); 根据irq查到irq_desc, 配置chip和handle和irq_data参数
          |--> irq_set_chip_and_handler(irq, &gic_chip, handle_fasteoi_irq);//-->irq_set_chip_and_handler_name()
            |--> irq_set_chip(irq, chip);
              struct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);
              desc->irq_data.chip = chip;
            |--> __irq_set_handler(irq, handle, 0, name);
              struct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);
              desc->handle_irq = handle; desc->name = name; irq_startup(desc, true);
		      set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
          |--> irq_set_chip_data(irq, d->host_data);
            struct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0); desc->irq_data.chip_data = data;
        irq_clear_status_flags(irq, IRQ_NOREQUEST);
      irq_domain_add(domain); //-->list_add(&domain->link, &irq_domain_list);
    set_handle_irq(gic_handle_irq); //--> handle_arch_irq = handle_irq;
    gic_chip.flags |= gic_arch_extn.flags; gic_dist_init(gic); gic_cpu_init(gic); gic_pm_init(gic);
  local_irq_enable();

//kernel/arch/arm/mach-q3f.c文件中
MACHINE_START(IMAPX15, "iMAPx15")
	.nr						= 0x8f9,
	.atag_offset	= 0x100,
	.smp					= smp_ops(q3f_smp_ops),
	.init_early		= q3f_init_early,
	.init_irq			= q3f_init_irq, // 中断初始化函数指针定义
	.map_io				= q3f_map_io,
	.init_machine = q3f_machine_init,
	.init_time		= q3f_init_time,
	.init_late		= q3f_init_late,
	.restart			= q3f_restart,
	.reserve			= q3f_reserve,
MACHINE_END
```

### 2.2 中断入口汇编解析
在ARM V4及V4T以后的大部分处理器中，异常向量表的位置可以有两个位置：一个是0，另一个是0xffff0000。可以通过CP15协处理器c1寄存器中V位(bit[13])控制。V和中断向量表的对应关系如下：V=0 ～0x00000000~0x0000001C; V=1 ～ 0xffff0000~0xffff001C。Linux中选择的是设置0xffff0000为异常向量表的位置。

**当中断被触发之后，处理器行为：**
```cpp
//Cpu进入irq状态
  R14_irq = 下一条指令 + 4 的地址
  SPSR_irq = CPSR
  CPSR(4:0) = 0b10010 CPSR(5) = 0 CPSR(8) = 1  CPSR(9) = CP15_reg1_EEbit CPSR(7) = 1  //disable normal interrupt
  If VE=0
    If high vectors configured then
      PC = 0xffff0018
    Else
      PC = 0x00000018
  Else
    PC = 不可预测
```
**linux中断向量表定义：**
```cpp
.macro	svc_entry, stack_hole=0
	sub	sp, sp, #(S_FRAME_SIZE + \stack_hole - 4)
	SPFIX(	tst	sp, #4		)
	SPFIX(	subeq	sp, sp, #4	)
	stmia	sp, {r1 - r12}
	ldmia	r0, {r3 - r5}
	add	r7, sp, #S_SP - 4 //@ here for interlock avoidance
	mov	r6, #-1			@  ""  ""      ""       ""
	add	r2, sp, #(S_FRAME_SIZE + \stack_hole - 4)
	SPFIX(	addeq	r2, r2, #4	)
	str	r3, [sp, #-4]!		//@ save the "real" r0 copied@ from the exception stack
	mov	r3, lr
	stmia	r7, {r2 - r6}
	.endm

.macro	svc_exit, rpsr, irq = 0
	ldr	lr, [sp, #S_SP]			//@ top of the stack
	ldrd	r0, r1, [sp, #S_LR]		//@ calling lr and pc
	clrex					//@ clear the exclusive monitor
	stmdb	lr!, {r0, r1, \rpsr}		//@ calling lr and rfe context
	ldmia	sp, {r0 - r12}
	mov	sp, lr
	ldr	lr, [sp], #4
	rfeia	sp!
	.endm

// kernel/arch/arm/entry-armv.S文件中，定义了中断向量表
	.equ	stubs_offset, __vectors_start + 0x200 - __stubs_start
	.globl	__vectors_start
__vectors_start:
 ARM(	swi	SYS_ERROR0 )
 THUMB(	svc	#0 )
 THUMB(	nop )
	W(b)	vector_und + stubs_offset
	W(ldr)	pc, .LCvswi + stubs_offset
	W(b)	vector_pabt + stubs_offset
	W(b)	vector_dabt + stubs_offset
	W(b)	vector_addrexcptn + stubs_offset
	W(b)	vector_irq + stubs_offset
	W(b)	vector_fiq + stubs_offset

	.globl	__vectors_end
__vectors_end:
	// Vector stubs. 阅读下面宏，看看上面的 vector_irq 等，是如何从 vector_\name解析的
	.macro	vector_stub, name, mode, correction=0
	.align	5

vector_\name:
	.if \correction
	sub	lr, lr, #\correction
	.endif
	// Save r0, lr_<exception> (parent PC) and spsr_<exception> (parent CPSR)
	stmia	sp, {r0, lr}	//@ save r0, lr
	mrs	lr, spsr
	str	lr, [sp, #8]		//@ save spsr
	// Prepare for SVC32 mode.  IRQs remain disabled.
	mrs	r0, cpsr
	eor	r0, r0, #(\mode ^ SVC_MODE | PSR_ISETSTATE)
	msr	spsr_cxsf, r0
	// the branch table must immediately follow this code
	and	lr, lr, #0x0f
 THUMB(	adr	r0, 1f )
 THUMB(	ldr	lr, [r0, lr, lsl #2] )
	mov	r0, sp
 ARM(	ldr	lr, [pc, lr, lsl #2] )
	movs	pc, lr			// branch to handler in SVC mode
ENDPROC(vector_\name)

	.align	2
	// handler addresses follow this label
1:
	.endm

__irq_svc: //irq跳转过程中一环
	svc_entry // Svc_entry主要将cpu相应的寄存器保存到堆栈，并将irq状态中保存的spsr_riq lr_irq等也保存到svc状态下的栈中。
	irq_handler
				@====================================================================
				@		.macro	irq_handler // irq跳转过程中一环
				@			ldr	r1, =handle_arch_irq // 在init_IRQ()函数中设置，接着，在中断
				@			mov	r0, sp
				@			adr	lr, BSYM(9997f)
				@			ldr	pc, [r1]
				@		9997:
				@			.endm
				@====================================================================
	get_thread_info tsk //取得thread_info结构体，增加preempt计数
				@====================================================================
				@		.macro	get_thread_info, rd
				@			mov	\rd, sp
				@			lsr	\rd, \rd, #13
				@			mov	\rd, \rd, lsl #13
				@			.endm
				@====================================================================
	ldr	r8, [tsk, #TI_PREEMPT]		// get preempt count
	ldr	r0, [tsk, #TI_FLAGS]		// get flags
	teq	r8, #0				// if preempt count != 0
	movne	r0, #0				// force flags to 0
	tst	r0, #_TIF_NEED_RESCHED
	blne	svc_preempt //检查是否能够抢占，如果是，调用 svc_preempt
				@====================================================================
				@			.ltorg
				@		svc_preempt:
				@			mov	r8, lr
				@		1:	bl	preempt_schedule_irq	@ 调用外部定义的C函数
				@			ldr	r0, [tsk, #TI_FLAGS]		@ get new tasks TI_FLAGS
				@			tst	r0, #_TIF_NEED_RESCHED
				@			moveq	pc, r8				@ go again
				@			b	1b
				@====================================================================
	svc_exit r5, irq = 1			// return from exception
 UNWIND(.fnend		)
ENDPROC(__irq_svc)

	.globl	__stubs_start
__stubs_start:
/*
 * Interrupt dispatcher
 */
	vector_stub	irq, IRQ_MODE, 4
  .long	__irq_usr			@  0  (USR_26 / USR_32)
	.long	__irq_invalid			@  1  (FIQ_26 / FIQ_32)
	.long	__irq_invalid			@  2  (IRQ_26 / IRQ_32)
	.long	__irq_svc			@  3  (SVC_26 / SVC_32)
  ... //12个 __irq_invalid 类型的

void __sched preempt_schedule_irq(void)
	struct thread_info *ti = current_thread_info();
	prev_state = exception_enter();
	do
		add_preempt_count(PREEMPT_ACTIVE);
		local_irq_enable();
		__schedule();
		local_irq_disable();
		sub_preempt_count(PREEMPT_ACTIVE);
		barrier();
	while (need_resched());
	exception_exit(prev_state);
```

### 2.3 中断处理流程
中断的处理流程如下：
1）发生中断时，CPU执行异常向量 vector_irq 的代码。
2）在vector_irq里面，最终会调用中断处理的总入口函数 asm_do_IRQ
3）asm_do_IRQ()根据中断号调用`irq_desc[]`数组项中的handle_irq。
4）handle_irq会使用chip成员中的函数来设置硬件，比如清楚中断，禁止中断，重新使能中断等。
5）handle_irq逐个调用用户在action链表中注册的处理函数。

```cpp
//#define preempt_count()	(current_thread_info()->preempt_count) //可以表示是否处于中断处理或者软件中断处理过程中
//对应上面 handle_arch_irq 函数指针
void gic_handle_irq(struct pt_regs *regs)
  struct gic_chip_data *gic = &gic_data[0];
  void __iomem *cpu_base = gic_data_cpu_base(gic);
  while(1) {
    u32 irqstat = readl_relaxed(cpu_base + GIC_CPU_INTACK);
    u32 irqnr = irqstat & ~0x1c00;
    irqnr = irq_find_mapping(gic->domain, irqnr);
		handle_IRQ(irqnr, regs);
  }

void wakeup_softirqd(void)
	struct task_struct *tsk = __this_cpu_read(ksoftirqd);
	if (tsk && tsk->state != TASK_RUNNING)
		wake_up_process(tsk); //--> try_to_wake_up()

void handle_IRQ(unsigned int irq, struct pt_regs *regs)
  struct pt_regs *old_regs = set_irq_regs(regs);
  irq_enter();
  if (unlikely(irq >= nr_irqs))
		if (printk_ratelimit()) printk(KERN_WARNING "Bad IRQ%u\n", irq);
		ack_bad_irq(irq);
	else
		|--> generic_handle_irq(irq);
      struct irq_desc *desc = irq_to_desc(irq);
      |--> generic_handle_irq_desc(irq, desc); // --> desc->handle_irq(irq, desc)-->handle_fasteoi_irq()-->handle_irq_event(desc);-->handle_irq_event_percpu();
				while(action)
					res = action->handler(irq, action->dev_id);//调用挂载在这个irq上的所有回调函数
					if (res == IRQ_WAKE_THREAD) irq_wake_thread(desc, action); //唤醒中断关联线程-->wake_up_process(action->thread);
	|--> irq_exit(); //void irq_exit(void) //中断处理函数退出的时候可能触发tick或者软中断
    account_irq_exit_time(current);
  	sub_preempt_count(HARDIRQ_OFFSET);
  	if (!in_interrupt() && local_softirq_pending())
  		|--> invoke_softirq();
        if (!force_irqthreads) __do_softirq();
  	    else wakeup_softirqd();
  	tick_irq_exit();
  	rcu_irq_exit();

	set_irq_regs(old_regs);
```

### 2.4 基本控制函数asm实现

```cpp
static inline void arch_local_irq_enable(void)
{
	asm volatile (
		"	cpsie i			@ arch_local_irq_enable"
		:
		:
		: "memory", "cc");
}
static inline void arch_local_irq_disable(void)
{
	unsigned long temp;
	asm volatile(
		"	mrs	%0, cpsr	@ arch_local_irq_disable\n"
		"	orr	%0, %0, #128\n"
		"	msr	cpsr_c, %0"
		: "=r" (temp)
		:
		: "memory", "cc");
}
static inline unsigned long arch_local_irq_save(void)
{
	unsigned long flags, temp;
	asm volatile (
		"	mrs	%0, cpsr	@ arch_local_irq_save\n"
		"	orr	%1, %0, #128\n"
		"	msr	cpsr_c, %1"
		: "=r" (flags), "=r" (temp)
		:
		: "memory", "cc");
	return flags;
}
static inline void arch_local_irq_restore(unsigned long flags)
{
	asm volatile(
		"	msr	cpsr_c, %0	@ local_irq_restore"
		:
		: "r" (flags)
		: "memory", "cc");
}
		#define raw_local_irq_disable()		arch_local_irq_disable()
		#define raw_local_irq_enable()		arch_local_irq_enable()
		#define raw_local_irq_save(flags)	do { typecheck(unsigned long, flags);	flags = arch_local_irq_save(); } while (0)
		#define raw_local_irq_restore(flags) do {	typecheck(unsigned long, flags); arch_local_irq_restore(flags);	} while (0)

		#define local_irq_enable()	do { raw_local_irq_enable(); } while (0)
		#define local_irq_disable()	do { raw_local_irq_disable(); } while (0)
		#define local_irq_save(flags)	do { raw_local_irq_save(flags); } while (0)
		#define local_irq_restore(flags) do { raw_local_irq_restore(flags); } while (0)
```

## 3 中断 范例

### 3.1 gpio中断
```cpp
//#include <linux/interrupt.h>
//#include <linux/gpio.h>

static int spidev_irq_index = 21;

struct spidev_data {
  //...
  struct semaphore sem;
  int     irq;
};

static irqreturn_t spidev_irq(int irq, void *dev_id)
    struct spidev_data	*spidev = dev_id;
    disable_irq_nosync(spidev->irq);
    up(&spidev->sem);
    return IRQ_HANDLED;

static int spidev_probe(struct spi_device *spi)
  //...
  int rc = 0;
  spidev_irq_index = 21;
  if (gpio_is_valid(spidev_irq_index))
		rc = gpio_request(spidev_irq_index, "ts_int");
		if (rc) pr_err("failed request gpio for ts_int\n"); return -1;
  sem_init(&spidev->sem);
  spidev->irq = gpio_to_irq(spidev_irq_index);
  //INIT_WORK(&spidev->work, gsl_ts_xy_worker);
  rc = request_irq(spidev->irq, spidev_irq, IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, "test", spidev);
  //...

```

### 3.2 按键中断

```cpp
//#include <linux/module.h>
//#include <linux/kernel.h>
//#include <linux/fs.h>
//#include <linux/init.h>
//#include <linux/delay.h>
//#include <asm/irq.h>
//#include <linux/interrupt.h>
//#include <asm/uaccess.h>
//#include <asm/arch/regs-gpio.h>
//#include <asm/hardware.h>

//#define DEVICE_NAME "buttons" /* 加载模式后，执行”cat /proc/devices”命令看到的设备名称 */
//#define BUTTON_MAJOR 232 /* 主设备号 */

struct button_irq_desc {
    int irq;
    unsigned long flags;
    char *name;
};

/* 用来指定按键所用的外部中断引脚及中断触发方式, 名字 */
static struct button_irq_desc button_irqs [] = {
    {IRQ_EINT19, IRQF_TRIGGER_FALLING, "KEY1"}, /* K1 */
    {IRQ_EINT11, IRQF_TRIGGER_FALLING, "KEY2"}, /* K2 */
    {IRQ_EINT2, IRQF_TRIGGER_FALLING, "KEY3"}, /* K3 */
    {IRQ_EINT0, IRQF_TRIGGER_FALLING, "KEY4"}, /* K4 */
};

/* 按键被按下的次数(准确地说，是发生中断的次数) */
static volatile int press_cnt [] = {0, 0, 0, 0};

/* 等待队列:
 * 当没有按键被按下时，如果有进程调用s3c24xx_buttons_read函数，
 * 它将休眠
 */
static DECLARE_WAIT_QUEUE_HEAD(button_waitq);

/* 中断事件标志, 中断服务程序将它置1，s3c24xx_buttons_read将它清0 */
static volatile int ev_press = 0;


static irqreturn_t buttons_interrupt(int irq, void *dev_id)
{
    volatile int *press_cnt = (volatile int *)dev_id;

    *press_cnt = *press_cnt + 1; /* 按键计数加1 */
    ev_press = 1; /* 表示中断发生了 */
    wake_up_interruptible(&button_waitq); /* 唤醒休眠的进程 */

    return IRQ_RETVAL(IRQ_HANDLED);
}


/* 应用程序对设备文件/dev/buttons执行open(...)时，就会调用s3c24xx_buttons_open函数 */
static int s3c24xx_buttons_open(struct inode *inode, struct file *file)
    for (i = 0; i < sizeof(button_irqs)/sizeof(button_irqs[0]); i++)  // 注册中断处理函数
        err = request_irq(button_irqs[i].irq, buttons_interrupt, button_irqs[i].flags, button_irqs[i].name, (void *)&press_cnt[i]);
        if (err)  break;
    if (err) // 释放已经注册的中断
        i--;
        for (; i >= 0; i--)
            free_irq(button_irqs[i].irq, (void *)&press_cnt[i]);
        return -EBUSY;
    return 0;

/* 应用程序对设备文件/dev/buttons执行close(...)时，就会调用s3c24xx_buttons_close函数 */
static int s3c24xx_buttons_close(struct inode *inode, struct file *file)
    for (i = 0; i < sizeof(button_irqs)/sizeof(button_irqs[0]); i++)
        free_irq(button_irqs[i].irq, (void *)&press_cnt[i]);// 释放已经注册的中断
    return 0;

/* 应用程序对设备文件/dev/buttons执行read(...)时，就会调用s3c24xx_buttons_read函数 */
static int s3c24xx_buttons_read(struct file *filp, char __user *buff, size_t count, loff_t *offp)
    wait_event_interruptible(button_waitq, ev_press); /* 如果ev_press等于0，休眠 */
    err = copy_to_user(buff, (const void *)press_cnt, min(sizeof(press_cnt), count)); /* 将按键状态复制给用户，并清0 */
    memset((void *)press_cnt, 0, sizeof(press_cnt));
    return err ? -EFAULT : 0;

/* 这个结构是字符设备驱动程序的核心, 当应用程序操作设备文件时所调用的open、read、write等函数，最终会调用这个结构中的对应函数 */
static struct file_operations s3c24xx_buttons_fops = {
    .owner = THIS_MODULE, /* 这是一个宏，指向编译模块时自动创建的__this_module变量 */
    .open = s3c24xx_buttons_open,
    .release = s3c24xx_buttons_close,
    .read = s3c24xx_buttons_read,
};

static int __init s3c24xx_buttons_init(void) /* 执行“insmod s3c24xx_buttons.ko”命令时就会调用这个函数 */
    /* 注册字符设备驱动程序, 参数为主设备号、设备名字、file_operations结构；这样，主设备号就和具体的file_operations结构联系起来了，操作主设备为BUTTON_MAJOR的设备文件时，就会调用s3c24xx_buttons_fops中的相关成员函数, BUTTON_MAJOR可以设为0，表示由内核自动分配主设备号  */
    ret = register_chrdev(BUTTON_MAJOR, DEVICE_NAME, &s3c24xx_buttons_fops);
    if (ret < 0) printk(DEVICE_NAME " can't register major number\n"); return ret;

static void __exit s3c24xx_buttons_exit(void) /* 执行”rmmod s3c24xx_buttons.ko”命令时就会调用这个函数 */
    unregister_chrdev(BUTTON_MAJOR, DEVICE_NAME);/* 卸载驱动程序 */

/* 这两行指定驱动程序的初始化函数和卸载函数 */
module_init(s3c24xx_buttons_init);
module_exit(s3c24xx_buttons_exit);

/* 描述驱动程序的一些信息，不是必须的 */
MODULE_AUTHOR("http://www.100ask.net"); // 驱动程序的作者
MODULE_DESCRIPTION("S3C2410/S3C2440 BUTTON Driver"); // 一些描述信息
MODULE_LICENSE("GPL"); // 遵循的协议
```

### 3.3 设置任意位置中断向量表

```cpp
vPortInstallFreeRTOSVectorTable:
	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */
	mrc    p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register
	bic    r0, r0, #0x00002000		@ V = 0
	mcr    p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register
	 /* Set vector address in CP15 VBAR register */
	ldr    r0, =_start
	mcr    p15, 0, r0, c12, c0, 0	 @Set VBAR
	dsb
	isb
```
