*# 工作日志

### 修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2019/01/07 | 员清观 |  |

## misc

~/work/qts/testcase_data/vplay/play/ 3001.txt文件为vplay的脚本文件

江苏路公司wifi:  office : 1234abcd
上海长宁区江苏路398号舜元企业发展大厦A座三楼
祖冲之路887弄83-84号402室

./tools/setproduct.sh
  36
  nvp6134
  mbox_all.json

**确认**<br>
  分工情况:
  近期任务清单: q3f是否需要测试, 整理测试用例,
  redmine管理, 增加权限, 添加bug来管控问题.

**调试性质启动盘:**<br>
  之后的调试性质启动盘,应该格式化为ext4文件系统; 其他场景保持向前兼容, 找一个合适的方式来判断, 或者使用一个独立的脚本.

**理清个人负责模块:**<br>
  ivan.zhuang - usb otg /frbuffer /usb网口 /uvc /i2c /
  can.cai     - dw_mmc /audio_codec /CCF(common clock framework) /pmu /ether /item /adc /
      pause/resume当前是否有效呢?
  bob.yang    - wifi /upgrade /cep.eventhub /display /net /dvfs(cpu_freq) /


gitk --author=bob.yang

**重建q3f测试流程:**<br>
  1. 检查一下testing文件夹, 哪些测试项目是就绪的.
  2. 整理所有的测试项目, 然后再沟通
  2. 郭东俊 刘艳, 看是否存在appolo3的标准测试过程
  3. 付老师, 了解一下qsdk的基本状况, 比如usb等接口功能的开发程度是否已经完备

**karry, 最好是找个晚餐时间:**<br>
  1. 客户接口
  2. 文档管理, 代码管理git gerrit redmine, bug管理
  3. TestLink系统, 单元测试管理, 自动测试, 压力测试
  4. 客户接口
  5. 研发部门架构:
  6. 开发流程

**auduiobox:**<br>
  1. abctrl命令支持指定默认trace的保存目录
  2. 增加一个新的命令, 原封不动的传递单元测试命令, 现有abctrl debug 支持的外部配置, 命令和参数完整的传输到audiobox后解析执行, 这样, abctrldebug保持同样的版本, 只需要升级audiobox就好

## 12-01->...
## 11-01->...
## 10-01->...
## 09-01->...
## 08-01->...
## 07-01->...
## 06-01->...
## 05-01->...
## 04-01->...

**04-08**<br>
今日体会：
  1.驱动部分每个模块应该增加初始化和外部控制的相应trace，方便问题的分析和定位
  2.每个模块trace可以动态开关
  3.内核增加对自己每个模块工作状态的记录，可以方便的查询；否则就要提供足够详尽的文档，描述如何查看每个模块
**04-07**<br>
eventhub基本搞定，估计会解决掉客户的问题，今天继续功耗问题。解决eventhub问题的基本体会是，所有的分支都应该加上trace.按照消息流动的次序增加trace
**04-06**<br>
加班，eventhub的eventhub.c改变数据结构
**04-04**<br>
加班，eventhub的libevent.c改变数据结构
**04-03**<br>
int event_destory_msgqueue()
    int msgid = -1;
    msgid = msgget(getpid(), 0777);
    if (msgid > 0)
        msgctl(msgid, IPC_RMID, NULL);
    return 0;
**04-02**<br>
http://res.xyirobot.com/kr3/cnword/pronunciation/xiaoyi_588zofelwis.mp3
http://res.xyirobot.com/kr3/cnword/pronunciation/1726hvpdetli.mp3

echo 3 > /proc/sys/vm/drop_caches
cat /proc/meminfo

精简掉所有不用的驱动模块。
spi1 mmc2

我这边优化了一下内核之后，可以大概节省4.5M内存出来。
items.itm文件中增加：  cevadsp.enable    0 ；新增这项配置是为了在uboot和kernel中去除为cevadsp分配的内存
int calc_dram_M(void)
spl_printf("dram_size: %d\n", dram_size);

unsigned char __initdata __800_480_bmp[] = {

modified: bootloader/apollo2/src/boot_main.c
modified: kernel/arch/arm/mach-q3f/mach-q3f.c
modified: kernel/drivers/infotm/q3f/display/implementation/module/logo/kernel_logo_800_480.h

items.itm文件中增加：  cevadsp.enable    0 ；新增这项配置是为了在uboot和kernel中去除为cevadsp分配的内存

**04-01**<br>
希望下一步，可以直接在基于同一个代码编译不同的product,用什么办法呢？1.软连接代码到不同的目录不知道是否可行呢？ 可行的。
  make menuconfig -> Filesystem images -> tar the target filesystem -> Compression method (随意)


    /dev/ttyUSB1
串口的设置
    | A -    Serial Device      : /dev/ttyUSB0                              |
    | B - Lockfile Location     : /var/lock                                 |
    | C -   Callin Program      :                                           |
    | D -  Callout Program      :                                           |
    | E -    Bps/Par/Bits       : 115200 8N1                                |
    | F - Hardware Flow Control : No                                        |
    | G - Software Flow Control : No                                        |

## 03-01->...
stop
delete
media
new
queue /mnt/sd0/MKV023_AAC.mkv
play

new
queue /mnt/tj.mp4
play
queue /mnt/sd0/MKV005_Cooker.mkv
play
queue /mnt/sd0/030-AVC-PCM-1920x1088.MOV
play
queue /mnt/025-airkiller_AVC-FLAC-1920x1080.mkv
play
queue /mnt/026-MPEG-4--AAC-720x480.mkv
play
queue /mnt/027-pandera-AVC-AAC-1920x1080.mov
play
queue /mnt/028-MPEG-4--Qdesign2-640x480.mov
play
queue /mnt/MKV026_AAC.mkv
play
new
queue /mnt/sd0/Video_20_1080P_VC1_AAC_8M_24F.mkv
play

new
queue /mnt/MKV026_AAC.mkv
play

new
queue /mnt/sd0/tj.mp4
play


stop
delete


photo
new
queue /mnt/sd0/1.jpg
play

queue /mnt/pao_mo.aac
play
queue /mnt/give_me_love_tank.aac
play
queue /mnt/17452--AAC 64 44.1tian_lan_lan.aac
play
queue /mnt/yi_ge_ren_shi_yi.aac
play

videoboxd
sleep 1
vplayer

**03-31**<br>
电脑:
登录名:         yuan
密码:        infotm1bsp

邮箱:
登录名:   eric.yun@infotm.com
密码:         Infotm123

REDMINE帐号
登录名:        eric.yun
密码:         mPRCAAFVMH

gerrit登录地址:
登录名:        eric.yun
密码:           637004

工作服务器:
登录名:  ssh eric.yun@192.168.0.14
密码:           123456


先安装jre（已有jre的跳过） 打开终端输入java -version，如果java未安装，则会提示找不到java指令，然后建议你安装列出的软件包，建议选择安装openjdk的jre。 安装完成后再输入java -version，测试一下jre是否安装成功...sudo apt install openjdk-9-jre-headless

创建一个启动器，类型为应用程序，名称随便填，命令写java -jar /home/yuan/SmartIM-App.jar。注意jar的路径要是绝对路径哦。 然后就能像在windows下面一样双击运行了，是不是很方便？

java -jar /home/yuan/SmartIM-App.jar

功耗问题：
双核固件					单核固件
条件：光PCBA
名称	电压（V）	电流（mA）	备注		名称	电压（V）	电流（mA）
总电源输入	12	　263			　总电源输入	12	　　249
VCC-CPU	　1.2	600		　　	VCC-CPU	  1.2	　　500
					             　VCC-DDR	　 1.56	　140
					               　VCC-3V   3.4	　 190	最大到230
卡在root 的正版 100mA， 整板，包括指示灯，
不启动应用是300mA。 整板，包括指示灯，
启动正常的390mA， 整板，包括指示灯，
耗电问题三大重点：１．显示fb的dma ２．wifi部分的工作　３．sensor相关

功耗问题：
  echo standby > /sys/power/state
  echo freeze > /sys/power/state
  echo standby > /sys/power/state
  CONFIG_PM  CONFIG_PM_SLEEP
  搜索　 struct dev_pm_ops 可以得到更加全面的功耗情况。
  SET_SYSTEM_SLEEP_PM_OPS(pl022_suspend, pl022_resume)

功耗管理这部分我还不熟悉。

按照我的理解：　暂时不考虑cpu降频，因为根据测试结果做出简单计算，一个核100mA(1.2v)，cpu其他部分400ms，优先考虑功能模块的管理情况，尤其是这些模块还直接控制着它连接的设备的工作状态。

浏览了一些驱动模块，大部分都包含省电模式的代码，在我的EVB上尝试了一下，"echo freeze > /sys/power/state"应该是可以用来进入省电模式，但我这边出错直接返回了，请刘工先在板上试下，给我你们板子出错的trace.

双核版本，在内核启动的若干个点，比如每次初始化一个新的设备，等待一段时间，测试电流。

module_power_on(SYSMGR_PWM_BASE);


方便的话再做一个测试：卡在boot阶段时候VCC-CPU的电流。我主要是需要一个判断基准，来确定思路。

第一个，显示模块
如果你们最看重的是屏幕显示时间的话，有两个建议：
１．mdec和vdec_g1和videobox，全部延时到屏幕显示之后启动
２．当前doorbell进程中tuya的操作，是否阻塞了启动的流程，从而延后了屏幕显示时间呢？如果是，能否后台启动一个线程来启动tuya？tuya大部分都是网络操作，io多而cpu占用少，和gui刚好相反。

read_sect
spiblock_normal_read_multisect
read_page

**03-30**<br>
配置8388:
codec.model  	es8388
codec.clk 		imap-audio-clk
codec.ctrl		i2c.1
codec.data  	i2s.0
sound.speaker 	pads.108

开机时间：
  １．Starting mdev new...　应该可以拉倒后面
  ２．

kernel 4秒

[03-30 17:02:57.046] [    2.946666] [gslX681]-Enter gsl_ts_init
[03-30 17:02:57.046] [    2.949999] [gslX681] Enter gsl_ts_probe
[03-30 17:02:57.046] [    2.949999] input: gslx681 as /devices/platform/imap-iic.2/i2c-2/2-0040/input/input2
[03-30 17:02:57.076] [    4.059999] i2c-core: driver [gslx681] using legacy suspend method
[03-30 17:02:57.076] [    4.059999] i2c-core: driver [gslx681] using legacy resume method
[03-30 17:02:57.076] [    4.059999] [gslX681]-i2c_add_driver return 0


你找到static struct amba_device *amba_devs[]，从中把imap_ssp1_device注释掉吧，省点系统启动时间和内存资源

```cpp
mount -t debugfs none  /sys/kernel/debug
cat /sys/kernel/debug/clk/clk_summary

   clock                        enable_cnt  prepare_cnt  rate
---------------------------------------------------------------------
 osc-clk                        5           5            12000000
    vpll                        1           1            792000000
       ddr-phy                  0           0            396000000
    epll                        11          11           1188000000
       mipi-dphy-pix            0           0            1188000000
       mipi-dphy-ref            0           0            27843750
       mipi-dphy-con            0           0            27843750
       ids1-tvif                0           0            148500000
       ids1-ods                 0           0            237600000
       ids1-eitf                0           0            148500000
       ids0-tvif                1           1            148500000
       ids0-ods                 1           1            148500000
       ids0-eitf                1           1            51652173
       bus6                     4           4            169714285
          sdmmc2                1           1            169714285
          sdmmc1                1           1            169714285
          sdmmc0                0           0            169714285
          usb-otg               0           0            169714285
          usb-ehci              1           1            169714285
          usb-ohci              1           1            169714285
       bus3                     0           0            1188000000
          gpu                   0           0            1188000000
       bus2                     0           0            297000000
          crypto-dma            0           0            297000000
          gps                   0           0            297000000
          ids1                  0           0            297000000
       bus1                     1           1            297000000
          ids0                  1           1            297000000
       uart                     1           2            297000000
       uart3                    1           1            297000000
       uart2                    1           1            297000000
       uart1                    1           1            297000000
       uart0                    1           1            297000000
       nand-ecc                 0           0            396000000
    dpll                        6           6            1536000000
       crypto                   0           0            153600000
       sata-phy                 0           0            1536000000
       clk-out1                 0           0            1536000000
       clk-out0                 0           0            1536000000
       audio-clk                1           1            61440000
       spdif                    0           0            61440000
       sd-mmc2                  1           1            96000000
       sd-mmc1                  1           1            96000000
       sd-mmc0                  0           0            96000000
       isp-osd                  0           0            256000000
       bus7                     0           0            256000000
          eth                   0           0            256000000
          sata                  0           0            256000000
          nandflash             0           0            256000000
       bus5                     0           0            153600000
          camif                 0           0            153600000
          tsif                  0           0            153600000
          mipi-csi              0           0            153600000
          isp                   0           0            153600000
       bus4                     2           2            348000000
          venc                  1           1            348000000
          vdec                  2           2            348000000
       usb-ref                  3           3            24000000
       hdmi                     0           0            24000000
    apll                        7           7            564000000
       dmic                     0           0            56400000
       touch screen             1           1            564000000
       camo                     1           1            8812500
       apb_pclk                 12          14           70500000
          tsc-ctrl              1           1            70500000
          uart-core             0           0            70500000
          keyboard              0           0            70500000
          simc1                 0           0            70500000
          simc0                 0           0            70500000
          cmn-timer1            0           0            70500000
          cmn-timer0            1           1            70500000
          watch-dog             0           0            70500000
          spi2                  0           0            70500000
          spi1                  1           1            70500000
          spi0                  1           1            70500000
          i2c3                  1           1            70500000
          i2c2                  1           1            70500000
          i2c1                  1           1            70500000
          i2c0                  1           1            70500000
          pwm                   1           1            70500000
          pwm4                  0           0            70500000
          pwm3                  0           0            70500000
          pwm2                  0           0            70500000
          pwm1                  0           0            70500000
          pwm0                  0           0            70500000
          ps2-1                 0           0            70500000
          ps2-0                 0           0            70500000
          sysm                  0           0            70500000
          rtc                   0           0            70500000
          cpu-core              0           0            70500000
          dma                   1           1            70500000
          gpio                  0           0            70500000
          spdif-core            0           0            70500000
          pcm1                  0           0            70500000
          pcm0                  0           0            70500000
          iis                   1           1            70500000
       smp_twd                  1           1            70500000
       cpu-clk                  1           1            564000000
       gtm-clk                  1           1            70500000
```
/mnt/MKV026_AAC.mkv
/mnt/tj.mp4
./stress --vm 1 --vm-bytes 35M &
./stress --io 1 --vm 1 --vm-bytes 40M &
abctrl apicall -L 1ffff
mount -t vfat /dev/mmcblk0p1 /mnt
cd /mnt
vplayer


video_rec.json

pl022->dma_cb_flag = 1; 应该换成是atomic的。

```cpp
	struct spi_message *msg = pl022->cur_msg;
	struct dma_chan *chan = pl022->dma_rx_channel;
	dma_addr_t src, dst;
	int delta = 0;

	if (pl022->use_rx_sglist) {
		if (test_cnt++ > 100) {
			terminate_dma(pl022);
			configure_dma(pl022);
			test_cnt = 0;
			printk(KERN_EMERG "reset_dma!!\n");
			return;
		}

		chan->device->device_dma_getposition(chan, &src, &dst);
		delta = (int)dst - (int)sg_phys(pl022->rx_sgl);
		if (delta != pl022->rx_sgl->length) {
			terminate_dma(pl022);
			configure_dma(pl022);
		}
	}
```

**03-28**<br>
mkfs.fat /dev/spiblock2

mount -t ext2 /dev/spiblock2 /mnt

最后出现的打印是符合预期的：
  e0:1,1170 1170,1170 116f,1170 116f.825c3ff8 825c4000


**03-27**<br>
下面几个问题：
  １．　IMAPX_SSP0_TX,IMAPX_SSP0_RX,　感觉pl330的发布顺序乱了，很奇怪
  ２．　发送完毕之后，如果后面因为上层控制不好，导致还有message，现在处理机制是否有问题呢
  ３．　双份读取？？ spiblock_fs_read_multisect, 1033 (20544 8)　---- seg:1 blk:20544 nblk:8 read 6073 us
```cpp
pl330_update()
  _start(thrd);
  _callback(rqdone, PL330_ERR_NONE);
    dma_pl330_rqcb();
      tasklet_schedule(&pch->task);
        pl330_tasklet()
          pl330_chan_ctrl(pch->pl330_chid, PL330_OP_START);
          free_desc_list(&list);
```
有时候只看到rx的callback，没有tx的，是否应该两个都有了再启动下一次传输呢？

一个pl330基本流程：
[    4.359999] sid:1->0 32 1
[    4.359999] sid:0->1 1024 0
[    4.363333] _start id:0 err:1 step:1!!! _start()函数在中断中被调用 当前状态：PL330_STATE_STOPPED
[    4.363333] _start id:1 err:1 step:1!!!
[    4.363333] peri:1
[    4.363333] dma_pl330_rqcb
[    4.363333] peri:0
[    4.363333] dma_pl330_rqcb
[    4.366666]    eid:1->0 1 1
[    4.369999]    eid:0->1 1 0


wait_for_completion_timeout()　函数也许可以实现重传。

pl022_unprepare_transfer_hardware()函数中，可能之后需要增加一些出错处理。
pl022_runtime_suspend() pl022_runtime_resume()　这两个动态开关的玩意，会否有影响呢？

重要线索：
    不是应该先发送，后接收么？现在的过程好像不是这样子：应该是1 0 1 0
    然后会否两者之间的时间差比较大，导致溢出呢？
[2020-03-27 14:36:12] [    4.089999] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.089999] sid:0 32
[2020-03-27 14:36:12] [    4.093333] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.093333] sid:1 1024
[2020-03-27 14:36:12] [    4.096666] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.096666] eid:0 1
[2020-03-27 14:36:12] [    4.099999] pl330_chan_ctrl, 2123, die 2!!!
[2020-03-27 14:36:12] [    4.099999] add blk err: 228 161 20
[2020-03-27 14:36:12] [    4.103333] pl330_chan_ctrl, 2123, die 2!!!
[2020-03-27 14:36:12] [    4.106666] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.106666] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.106666] sid:0 32
[2020-03-27 14:36:12] [    4.106666] eid:1 1024


**03-26**<br>
make linux-menuconfig:
    为squashfs使能"Use 4K device block size?"选项
items.itm文件中：
    system.11231.fs 改成 system.11231.normal
kernel部分：
    modified:   drivers/dma/pl330.c
    modified:   drivers/infotm/common/ftl/spi_ftl/spi_block.c
    modified:   drivers/infotm/common/spi/spi-pl022.c
    modified:   drivers/mtd/devices/m25p80.c
    modified:   include/linux/dmaengine.h
system部分：
    modified:   qlibupgrade/ius_util.c
    modified:   qlibupgrade/libupgrade.c
    modified:   qlibupgrade/spiblk_util.c

kernel部分：
    modified:   drivers/infotm/common/fr/fr-core.c
    modified:   include/linux/fr.h

**03-25**<br>
spi-block.c 文件
  mtd->erasesize : 64k
  spi_info->writesize : 512
  mtd->size : 16777216
  spi_info->bootblock : 69
  spi_info->normalblock : 204

	printk(KERN_EMERG "spi_info :: (%d %d %d %d %d) (%d %d)\n"
		, spi_info->accessibleblocks, size_in_blk
		, mtd->erasesize, spi_info->writesize, (int)mtd->size
		, spi_info->bootblock, spi_info->normalblock);

**03-23**<br>
考虑一下，那些应用应该在pc建立模拟器呢：
  FTL算法的进一步开发应该移植到pc平台更加方便一些，除了调试更加方便快捷，还可以更加方便的制造各种测试场景。
  minigui?

增加_suspend()和_resume()两个函数，可以用来控制数据传输的开始和结束。在这中间的所有的sub_m25p80_read()函数调用，转换为一次统一传输。m25p80增加一个全局变量的spi_message，一条spi_message可以支持最高8个transfer(和pl022匹配)

制作文件系统的参数，-b 改变的话对性能应该有影响：
  mksquashfs/opt/Hisi/Hi3519/Hi3519V101_SDK_V1.0.2.0/osdrv/pub/rootfs_uclibc_big-little3519_wqw.sqhfs -b 65536 -comp xz

当前配置命令，好像使用的默认逻辑块大小128k：
/home/yuan/work/x15_cus1/output/host/usr/bin/mksquashfs /home/yuan/work/x15_cus1/output/system /home/yuan/work/x15_cus1/output/images/rootfs.squashfs -noappend -comp

针对nandflash访问问题，应该增加写后校验，增加坏块管理，增加读次数检测。

**03-21**<br>
下面这个地址，有代码可以挪用：
  https://www.cnblogs.com/mengfanrong/p/5239633.html

**03-18**<br>
改变线程优先级:
  struct sched_param sched;
  sched.sched_priority = 90;
  pthread_setschedparam(pthread_self(), SCHED_RR, &sched);

开发一个系统资源监控器，cpu/mem/中断/flash/sdio/wifi/eth/.../等等的统计信息。

bootloader/apollo2
kernel/arch/arm/mach-q3f/devices.c 　中，和　spi_nand_gd5f_flash_info　定义相关的部分
kernel/drivers/infotm/common/spi_nftl/
kernel/drivers/mtd/devices/giga_spinand/

**03-17**<br>
ffmpeg出错callback函数机制，可以选择控制每个操作允许的错误上限，不知道最终是否可行。
```cpp
 #define DEMUX_STOP_DET_ERR       -2
 #define DEMUX_START_DET_ERR      0
 #define DEMUX_FRAME_ERROR_THLD   20  //if demux_get_frame() have too much error, exit.
 #define DEMUX_INIT_ERROR_THLD    300 //if demux_init() have too much error, exit.
static int DemuxIntCallback(void *ctx)
{
    //static int test_counter = 0;
    //printf("%d\n", test_counter++);
    if (ProcDemuxErrorCnter++ < ProcDemuxErrorThld)
        return 0;
    pthread_testcancel();
    return 1;
}
ProcDemuxErrorThld = DEMUX_INIT_ERROR_THLD;
    ProcDemuxErrorCnter = 0;
    pDemux =  demux_init(file->file, DemuxIntCallback);

  ProcDemuxErrorThld = DEMUX_FRAME_ERROR_THLD;
    ProcDemuxErrorCnter = 0;
    ret = demux_get_frame(this->DemuxInstance, &frame);
```

软件著作权文档格式：
1. 项目背景
2. 软件功能介绍
3. 软件特性介绍
4. 系统物理结构
5. 系统总结构　：　系统框架图，描述几个主要子模块，系统总的流程图
6. 系统主要子系统
7. 算法设计
8. 接口设计
9. 系统出错处理设计
10. 系统维护设计

音频文档格式：　背景和介绍　需求和功能设计　主要系统模块设计　算法和数据结构　通道管理流程　通道数据流程　软件测试

videobox_repath("/root/.videobox/jpeg.json");
init_photo_player_info(&playerInfo);
videobox_repath("/root/.videobox/video.json");
init_player_info(&playerInfo, 0);

make menuconfig 这个要关掉
　# BR2_LINUX_KERNEL_INSTALL_TARGET is not set

调试发现：　seek之后，之前的所有frame的时间戳信息都是无效的，应该要设置
!!!!!!!!!!!!!!!  /mnt/sd0/030-AVC-PCM-1920x1088.MOV 这个文件的音频格式根本不需要codec的。
SetWorkingState()　存在机制性问题，线程无论如何，不应该自己确定状态。
!!!!!!!!!!!!!!!!!!! 音频和视频AQ VQ差别很大的时候，是否播放不同步的问题比较严重呢？

0316 -- 新的patch。和周六上午提交的patch相比，增加了和刘工周六调试完毕的几个fix，然后只是把tab转成了4个空格以统一代码风格。现在代码策略就是先稳定下来。

photo
new
queue /mnt/sd0/3.jpg
play


**03-14**<br>
　#define VBERR_FR_INTERRUPTED "get fr buffer interrupted"

	sleep(2);
	vplay_media_info_t stMediaFileInfo;
    memset(&stMediaFileInfo, 0, sizeof(stMediaFileInfo));
	vplay_control_player(*pstPlayer, VPLAY_PLAYER_QUERY_MEDIA_INFO, &stMediaFileInfo);
	value = (int)stMediaFileInfo.time_length - 2000;
	printf("&&&&&&&&&&&&&&&&&&&&&&&&& seek to %d\n", value);
	vplay_control_player(*pstPlayer, VPLAY_PLAYER_SEEK, &value);

问题75/83/85/88/90，请验证
问题75，请验证。只有025视频seek失败，请另外专为025建立BUG降低优先级延后处理
问题84，改进了机制，会只播放音乐，不解码视频。 -- 026视频播放问题延后解决
问题85，卡住的问题已经解决。 -- AC3不支持问题延后解决。

问题81，我无法重现，请在出现问题的时候抓个audiobox的完整trace.
问题66/69/79下周跟进
建议相关音频视频无法播放问题另外单独建立新BUG管理，并降低优先级。

另外增加的内容：
调整了音频通道启动方式，解决之前有时候出现的xrun问题，可能会对减少切换后杂音有帮助

**03-13**<br>
OpenNextMediaDemuxer() 函数，应该把结束当前和开始下一个严格分开处理，否则逻辑会有点混乱。
外部消息发送到末尾，内部消息的优先级应该高一点，发送到头部，这样只要一个普通的临界区就可以保护好消息的次序了，不会被外部消息插入到连续的两个内部消息中间。
几个需要发送消息给自己的场景
  QPlayer::Play() 失败
      OpenNextMediaDemuxer()失败，发送stop消息
  QPlayer::StepDisplay()　失败，发送stop消息
  当前播放文件结束，发送play消息，结束当前播放下一个
fr_get_float_remain() 函数可以改造一下，如果满，就返回0xffff

**03-12**<br>
增加状态机机制来支持qplayer工作(参数不能太多)：

```cpp
std::list <VPlayerCommand>     *PMesgList;
    this->PMesgList = new std::list<VPlayerCommand>();
	this->PMesgList->empty();
    this->PMesgList->clear();
    delete this->PMesgList;
    this->CurFile = this->PMesgList->front();
    this->PMesgList->pop_front();
    this->PMesgList->push_back(fileInfo);
    this->PMesgList->size()
    this->PMesgList->clear();

	vplay_file_info_t fileinfo;
	int index = 0;

	for(auto it = this->PFileList->begin();it!=this->PFileList->end();it++){
		fileinfo = *it;
		if (memcmp(fileinfo.file, file, strlen(file)) == 0) {
			pthread_mutex_lock(&this->MesgListLock);
			this->PFileList->erase(it);
			pthread_mutex_unlock(&this->MesgListLock);
			LOGGER_INFO("file %s removed!\n", fileinfo.file);
			break;
		}
    }
	for(auto it = this->PFileList->begin();it!=this->PFileList->end();it++){
		fileinfo = *it;
		LOGGER_INFO("InList:%d %s\n", index, fileinfo.file);
		index++;
    }

    return 1;

  int i;
  char lowfile[8];
	for (i=(strlen(file)-4); i <= strlen(file); i++)
       lowfile[i] = tolower(file[i]);
```
**03-11**<br>
！！！！！！！！！！　AC3音频暂时不支持可好？
！！！！！！！！！！　昨天的补丁pause，会卡住，没有复现
！！！！！！！！！！　增加自动播放完毕自动停止的功能
！！！！！！！！！！　双核是否没有真正的发挥作用？　可以把中断引导到不同的内核。那么spi中断是否也可以呢？
spi是否可以使用16bits的处理呢？
现在的jpg机制重新调整之后，应该可以了。
1920x1088 2100x1400.jpg 宽高比不同
通过互斥锁和消息队列结合完成，play/stop/pasue/seek/continue 发送消息并且通过返回变量来得到返回值，所有的命令都加上锁。
QueryMediaFileInfo　需要用到动态变化可能变为空的指针，所以，用消息
或者可以考虑两个队列，一个专门用来保存返回的内容，这样，好像就完美的模拟了进程间rpc机制了。
基本的机制就是：　发送消息，等待自己消息队列中的返回。

！！！！！！！！！！需要考虑处理
          vplay_control_player 的行为，最好还是改为消息的格式来完成。应该增加一些消息，每个命令对应一个消息。
          播放完毕，应该进入stop状态，但是现在没有啊。现在明显的，外部改变全局变量的行为，也会造成不良影响。！！！！！！！！！
          如果所有线程进入pause状态，是否应该不要再打印统计信息呢？
          play命令应该增加返回：
          解析aac失败的文件，测试一下，返回错误。
          对于不支持的或者是解析错误的格式，应该finish，并返回错误代码
          播放出错了之后，及时结束；并且不要因为太多打印而卡顿不休。
          遇到一个audio的xrun，我判断是因为线程优先级比较低，发送了第一个帧之后，后续帧没有跟上，所以，应该保证读取了三个帧之后或者文件结束

int *ptr = (int *)this->VideoBuffer;
printf("%s: header: (0x%x > 0x%x) (%x %x %x %x)\n"
			, __func__, size, size
			, ptr[0], ptr[1], ptr[2], ptr[3]);

`[Switching to LWP 982]`　－－　`info threads` 查看到当前线程为demuxer,　`bt`看到当前出问题的函数是`free()`，从`/usr/lib/libavcodec.so.57`中被调用。 `WorkLoop,534 header:1 0, frames:0`的打印显示，dec线程必然会立刻停止。

**03-10**<br>
QPlayer::Play()函数应该包涵QPlayer::Stop()函数，逻辑上是正常的。

**03-09**<br>
解码器打印
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
  uint64_t currenttime = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
  LOGE("delay too big, cur:%lld %lld %lld, %lld %lld\n"
								, currenttime, m_stPTS.u64timebase, m_stPTS.u64ptsbase
								, m_stPTS.u64lastpts
								, m_u64timestamp[m_s32PicDecodeNum]);
增加以下处理：
  int audio_pause_channel(int handle, int flag)

VplayTimeStamp::
  this->PlayTs = ts; //　pts时间轴
  this->LastGetTs = SysTime; // 系统时间轴
  this->CurSysTs = SysTime;

VplayTimeStamp::UpdateTs
this->VPlayTs.Start();的调用地点，是否现在太早了

如果frame类型动态变化，可以考虑增加新的动态调整机制。
播放过程中，设置IsAudioMute，之后的音视频同步可能会有问题，应该设置的是audiobox的mute，而不是qplayer的mute. 创建通道时候需要判断，播放过程中这个函数直接配置到音频部分去。


**03-06**<br>
1. 解决了seek问题，需要修正libdemux库
2.
bool QPlayer::StepDisplay()
{
	if(this->OpenNextMediaDemuxer() == false) {
		LOGGER_ERR("open next media file error\n");
        return false;
	}
    LOGGER_INFO("Start step display!\n");
	if (!this->IsStepDisplay) {
		this->SetWorkingState(ThreadingState::Pause);
		this->SetWorkingState(ThreadingState::Pause);
		this->SetWorkingState(ThreadingState::Pause);

		this->IsStepDisplay = true;
		this->SetWorkingState(ThreadingState::Start);
		this->PSpeedCtrl->SetWorkingState(ThreadingState::Start);
	}

    return true;
}

**03-05**<br>
测试停止的地方，应该是音频通道创建了不应该的
[2020-03-05 23:50:13.029] INFO<lib/qplayer.cpp,1518>: Decfr:(d:20,l:26),VFr:20(0),AFr:  0(-1),VQ:20,AQ: -1,V:876 800, pos(2043/133285),fault(0 0 40 0 0)
[2020-03-05 23:50:14.846] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:22(0),AFr:  0(-1),VQ:18,AQ: -1,V:876 800, pos(3046/133285),fault(0 0 48 0 0)
[2020-03-05 23:50:15.863] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:26(0),AFr:  0(-1),VQ:20,AQ: -1,V:876 800, pos(4063/133285),fault(0 0 64 0 0)
[2020-03-05 23:50:16.867] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:22(0),AFr:  0(-1),VQ:18,AQ: -1,V:792 800, pos(5066/133285),fault(0 0 72 0 0)
[2020-03-05 23:50:17.870] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:23(0),AFr:  0(-1),VQ:17,AQ: -1,V:792 800, pos(6070/133285),fault(0 0 81 0 0)
[2020-03-05 23:50:18.937] INFO<lib/qplayer.cpp,1518>: Decfr:(d:26,l:26),VFr:26(0),AFr:  0(-1),VQ:17,AQ: -1,V:668 800, pos(7137/133285),fault(0 0 92 0 0)
[2020-03-05 23:50:19.806] INFO<lib/qplayer.cpp,1585>: vplay player control ->2
[2020-03-05 23:50:19.811] INFO<lib/qplayer.cpp,1036>: ~~~~~~~~~ stop player step
[2020-03-05 23:50:19.819] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12160(demuxer)
[2020-03-05 23:50:19.833] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12170(vplayer)

正常的流程：
[2020-03-05 23:50:11.123] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12160(demuxer)
[2020-03-05 23:50:11.136] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12170(vplayer)
[2020-03-05 23:50:11.150] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x2fc320(aplayer)
[2020-03-05 23:50:11.157] <audio_pause_channel,720>: Critical:audio flush channel:0 ok
[2020-03-05 23:50:11.187] INFO<lib/qplayer.cpp,1044>: ~~~~~~~~~ stop player step
[2020-03-05 23:50:11.192] INFO<lib/qplayer.cpp,1381>: release audio codecs


**03-04**<br>
modified:
  /system/videobox/IPU/VDECODER/VDecoder.cpp
  /system/videobox/IPU/VDECODER/VDecoder.h
  /kernel/drivers/infotm/common/fr/fr-core.c
  /kernel/include/linux/fr.h

  cp -fr ./drivers/infotm/common/fr/fr-core.c ~/Downloads/0305patch/
  cp -fr ./include/linux/fr.h ~/Downloads/0305patch/
  /kernel/include/linux/fr.h

销毁audio和video对象的时候，析构函数中stop之
make hlibunitrace-rebuild
**03-03**<br>
加快stop速度的方法：
1. 保证vdecoder已经停止，并且flush所有的视频帧，现在可能不能保证这一点
2. 优先停止读取文件，然后清空两个媒体流，然后清空音频和视频的播放缓存。
3.

上次建议增加的 audio_pause_channel()　函数有bug，所以现在先去掉了调用.　audiobox 启动时候的buffer，切换视频时需要播放完，所以会影响到反应时间，我会之后处理掉audio_pause_channel()函数的bug来解决这个问题。

当前的qplayer，根本没有等待qaudioplay退出就开始了下一个的工作，这是需要马上改变的。

**03-02**<br>
解码器几个bug:
1. 进入stop状态之后，应该保证把之前所有的frame清空，否则，老的frame影响到新的decoder的行为。类似while ((fr_get_float_remain(&stRef) > 0) && m_s32RunState == EM_VDEC_STOP)肯定是有问题的。
2. 之前所述的else if(HeaderUserflag)判断，导致bufferIn可能会指向上一个被访问的frame.
3. 两处可能的死循环
4. if (++nstops == 1)分支中的VDecReset();调用，实在莫名奇妙。
5. 设置状态和解码id的方式太粗暴
6.

解码器应该增加播放速度控制，增加

qlibvplay模块优化
现状：从客户反馈以及我们自己对代码的审核，建议重构qplayer，而qrecorder部分基本保持现状。对qlayer部分，第一步的优化建议
向前兼容，完全保持之前的api接口，解决结构不合理导致的bug和效率问题。

qplayer第一步优化内容：
1. 为threadcore增加新状态,避免每个loop只处理一个帧的低效情况
2. 调整trace机制，方便后续的开发和支持
3. 删除所有timestamp相关的变量和函数，比如 QPlayer::VPlayTs SpeedCtrl::PVPlayTs 以及相关的辅助内容
4. 去除对class Statistics的引用，因为其统计内容大部无用，而且实现方式麻烦，用新的方式替换
5. 基本保持

AddStreamEndDummy()函数中需要一个时间戳，可以直接使用上一个帧加5
建议在解码器部分增加播放速度控制的机制，而不是qplayer


**03-01**<br>
应该是等待所有的视频播放完毕，然后发送播放结束消息。判断的标准，应该是缓冲区中剩余帧为0或者１

播放完毕，应该先关闭原有的demux，然后在没隔一段年时间，判断是否准备就绪。

fr_get_buf()函数原本通过fr_buf_set_state()调用，阻塞等待获取缓存，float类型没有类似的机制，导致出现bug.

[2020-02-29 11:45:57] [   47.223333] !!!!!!!!!!!!!!!!!! failed to alloc float buf:name:dec0-stream remain:19 size:1048576, pbuf:180224 vbuf:3149824!

简历相关
毕业后先后在迪比特电子、UT斯达康、敏迅通讯从事过硬件、驱动和通信协议软件的开发，奠定了扎实的技术基础。

2011年作为技术核心参与创办上海伟视清数字技术有限公司，整体负责硬盘录像机和摄像机产品的软件开发工作。在领导团队进行开发工作时，非常注重产品性能和稳定性和关键新功能的开发，打下了坚实的产品基础，这保证了伟视清一直到现在都能在安防市场的残酷竞争中保有一席之地。

2017年加入盈方微电子从事BSP开发工作，致力于深入优化自己所涉及的每一个模块，有效的提高了产品稳定性和音频、回声消除、存储等方面的性能

在公司的三年，主要致力于优化自己所涉及的每一个模块，有效的提高了产品性能和稳定性，主要有：
1. 音频系统的重构，AEC功能的评估测试和优化等
2. BSP存储部分的优化，如提高MMC、SPI接口性能和稳定性，重构nftl算法，为fat32增加延迟分配算法等
3. 内核和uboot启动加速优化
4. 设计基于全志xr871和盈方微Q3f的门铃项目Demo，freertos到盈方微Q3f的移植

一种可能的场景：head占用了剩下的刚好1M中的一个PAGE，然后，后面的一个帧获取内存失败。

float部分使用好像有点问题，

## 02-01->...

**02-28**<br>

if (PPGetResult(m_stPPInst) != PP_OK)
{
  continue;
} 有bug吧,进去了就是死循环

while (m_s32RunState == EM_VDEC_PAUSE) //加的位置有点销魂

void QPlayer::UpdateAllStatics()
{
	if(this->PDemuxVideoInfo != NULL) {
		this->stat.UpdateFifoInfo(PACKET_TYPE_VIDEO,this->PVideoFrFifo->GetQueueSize()
			,this->PVideoFrFifo->GetDropFrameSize());
	}
　#ifdef ENABLE_AUDIO
	if(this->PDemuxAudioInfo != NULL)
		this->stat.UpdateFifoInfo(PACKET_TYPE_AUDIO,this->PAudioFrFifo->GetQueueSize()
			,this->PAudioFrFifo->GetDropFrameSize());
　#endif
    this->stat.UpdatePacketPTS(PACKET_TYPE_AUDIO,this->VPlayTs.GetTs(this->PlaySpeed));
	this->stat.UpdatePacketPTS(PACKET_TYPE_VIDEO, this->PSpeedCtrl->VideoFrame.timestamp);
}

**02-27**<br>
QPlayer::WorkingThreadTask()　函数中，　判断1s时间到的时候，打印状态统计信息。打印的时候去获取数据，而不是每个frame注册改动，太傻了

m_bHeaderflag 和 HeaderUserflag　都是 true的情况下，dec会执行两次动作：
第一次
  SetVDecInput(m_pu8StreamHeader, (u32)m_pu8StreamHeader, m_s32StreamHeaderLen);
第二次
  SetVDecInput(bufferIn.fr_buf.virt_addr, (u32)bufferIn.fr_buf.phys_addr, bufferIn.fr_buf.size);
  但需要注意的是，bufferIn = m_pstDecBuf->GetReferenceBuffer(&bufferIn);　在第一步并没有被执行，所以，bufferIn　使用的是上个frame的数据
**02-26**<br>
和万虎交接显示相关的内容；display2无人使用，主要是兼容各个平台的需要
继续调试float fr的bug

音视频的编解码，应该和读文件放在不同的线程中吧。读文件应该是一个简单任务。

QPlayer::Stop()中，this->PVideoFrFifo->Flush();this->PAudioFrFifo->Flush();都只能清除本地的fr缓存，无法清除videobox audiobox中已经缓存的帧，所以，QAudioPlayer::ThreadPostStopHook()中audio_put_channel()阻塞调用的结果就是，上层需要等待audiobox播放完毕，才能结束qaudioplay线程。如果是qplayer;:stop命令，那么，应该调用audio_pause_channel(CHAN_PAUSE_FLUSH);

vplay_control_player()函数中，应该增加一个event_regisyter的机制；消息中，增加一个传递字符串的消息，然后可以编辑脚本，发送一个个测试命令，比原有的控制台解析更加方便一些。

float类型，drop和nodrop两种，估计是对应enc和dec两种的，fr_get_float()函数需要考虑这两种情况

fr_get_ref()函数中,两次wait_event_interruptible_timeout()应该改成一次， 对应wake_up_interruptible(&fr->serial_update);和fr->serial_inc

**02-25**<br>
继续调试float fr的bug
**02-24**<br>
if((curTs -  this->LastTs) > 30000) 就改变player线程的优先级，看起来很二
QPlayer::Stop(void) 的实现中，音视频的停止效率差，不应该绑定join()动作；同样的，pause等动作也不应该是阻塞等待式的．
感觉，音视频的demux应该使用两个独立的读取线程，而不是现在这样的
qaudioplayer的workingtask, 应该是持续把所有音频数据送到audiobox，而不是中间usleep(1000);
线程间同步，考虑使用signal或者semphore之类的，而不是低效的轮询模式；状态机需要重新整理，太乱了
vplay_delete_player()函数，free(player);之后修改可能导致crash.
ENABLE_AUDIO 这个宏实在定义的莫名其妙
QPlayer::WorkingThreadTask()　一次调用，应该可以读取多个frame
每个线程，应该增加一个cnt和一个step，以确定当前线程或者说对象的工作状态．
create kworker/1:1H, nice: -20, cpumask: 0x2，　这个打印是调试信息，下个版本去掉、kernel/workqueue.c中
SpeedCtrl::WorkingThreadTask()的逻辑，应该是检查fr的缓冲区，有数据的话才尝试写入，否则休眠等待。

无用代码： frfifoloop.cpp qcodecs.cpp
录音代码： mediamuxer.cpp apicalleraudio.cpp apicallerextra.cpp apicallervideo.cpp qrecorder.cpp
放音代码： qaudioplayer.cpp speedctrl.cpp
共用代码： common.cpp threadcore.cpp qmediafifo.cpp

**02-22**<br>
SpeedCtrl类中，调用Prepare()函数，this->SetWorkingState(ThreadingState::Standby);　启动线程．但是在LoopThreadFunction()　函数中，线程首次启动之后usleep(50000);是不合理的．
abctrl apicall -L 1ffff
**02-21**<br>
mkdir -p /mnt/sd0
mount -t vfat /dev/mmcblk0p1 /mnt/sd0
cd /mnt/sd0
sleep 1
cp video.json /root/.videobox/path.json
vplayer

printk(KERN_EMERG "\n\n!!!!!!!!!!! 2 !!!!!!!!!!!!\n\n");

播放完毕之后没有可切换文件和播放完毕之后有，处理是不同的。

new
queue /mnt/sd0/tj.mp4
play

this->PVideoFrFifo->GetQueueSize()

seek 170000

**02-20**<br>
md文档转换为word格式的方法：1. atom中，md转html  2. LibreWriter中，html转docx 3. LibreWriter中，docx中调整所有图片，这样会移除原有的image链接地址，并替换掉图片原有的svg格式

安一周项目kernel启动优化点：
[2020-02-14 22:25:42:191] [    0.533333] imapfb init
[2020-02-14 22:25:42:628] [    0.893333] [dss][abstraction] <error> terminal_configure: Terminal lcd_panel not found.

[2020-02-14 22:25:43:542] [    1.666666] nvp6134_probe 1580
[2020-02-14 22:25:44:855] [    2.946666] [nvp6134_init 1271] camif open...

[2020-02-14 22:25:44:995] [    3.089999] es8388_probe() es8388_reset OK!
[2020-02-14 22:25:45:722] [    3.816666] es8388_set_bias_level

唯一的剩余提速可能调试失败了：　chip_info->ctrl_len　设定为１６位．可以设定为，dma模式下使用16位模式，这样，一次可以拷贝的数据更多，应该可以容纳更快的速度吧．
static void do_force_width(struct pl022 *pl022, int enable_16bits)
{
	int bits;

	struct chip_data *chip = pl022->cur_chip;

	if (enable_16bits) {
		if (chip->n_bytes != 2) {
			bits = 16;
			chip->n_bytes = 2;
			chip->read = READING_U16;
			chip->write = WRITING_U16;
			SSP_WRITE_BITS(chip->cr0, bits - 1, SSP_CR0_MASK_DSS, 0);
			writew(chip->cr0, SSP_CR0(pl022->virtbase));
		}
	} else {
		if (chip->n_bytes != 1) {
			bits = 8;
			chip->n_bytes = 1;
			chip->read = READING_U8;
			chip->write = WRITING_U8;
			SSP_WRITE_BITS(chip->cr0, bits - 1, SSP_CR0_MASK_DSS, 0);
			writew(chip->cr0, SSP_CR0(pl022->virtbase));
		}
	}
}
unsigned int bits = spi->bits_per_word;

**02-19**<br>

**02-17**<br>
张江4标搬家，找电脑和盘点零部件；
**02-14**<br>
音频处理部分，应该增加对时间戳和帧率的显示和监测
env分区的内容：　86 fd ae 36 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

touch /tmp/uboot
time dd if=/dev/spiblock0 of=/tmp/uboot bs=4096 count=1
hexdump /tmp/uboot -n 256

time dd if=/dev/spiblock0 of=/dev/null bs=4096 count=1024
time dd if=/dev/spiblock0 of=/dev/null bs=1024 count=4096
real  0m 12.8 --> 1.58s

cat /proc/kmsg

**02-13**<br>
为了更加自由的使用aec功能，增加调用下面函数，设定aec处理的时候右声道为有效mic通道：
   audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_REFCHAN, 1);

可以尝试下面场景，对比分析一下结果：
1. 底层设置16k采样率，配置 audio_set_aecfreq("default_mic", 16000);
2. 底层设置8k采样率，配置 audio_set_aecfreq("default_mic", 8000);

改变aec的参考音延时，可能会影响到aec效果：
audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_V2DELAY, 400);
audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_V2DELAY, 800);
．．．
audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_V2DELAY, 3000);

**02-12**<br>
软件著作权：　ＩＵＷ　WINDOW平台升级
1. videobox　2. audiobox　3. vplayer　4. vrecorder　5. 无人机软件包　6. 儿童故事机软件包　　7. eventhub　8. IQ调试工具
9. 鱼眼矫正工具　10.智能门铃软件包　11. Sensor bridge　12. FTL　13. FR内存管理　14. 人脸侦测优化　15. mv的移动侦测
16. 影子端口　17. G2D　18. 显示模块　19. 电子防抖　20. 旋转功能　21. H264智能P帧　22. 智能码率控制
 ---- 分类管理 ---- ：
1. videobox　2. audiobox　3. vplayer/vrecorder　4. FR内存管理　5. 电子防抖　6. 旋转功能　7. H264智能P帧　8. 智能码率控制
7. eventhub　8. IQ调试工具　9. 鱼眼矫正工具　10.智能门铃软件包　11. Sensor bridge　12. FTL　14. 人脸侦测优化
15. mv的移动侦测　16. 影子端口　17. G2D　18. 显示模块

我的：　　audiobox　vplayer  vrecorder ftl
万虎的：　FR内存管理  eventhub　G2D　显示模块


eventhub　

贵司文档中提到: "文档提供设计手册的应有软件完整的总体设计描述、总体结构和模块设计、功能分配、各项功能与程序结构关系、软件设计流程图"
请问下，对软件设计说明文档的内容和格式是否有强制要求呢？比如说我现在已经有了一个软件文档，但内容上并不是按照上述的方式组织的，那么我需要重构或重新写文档么？

1）要安装最新的，先要卸载之前的版本：[1]
sudo apt-get remove firefox
2）然后在terminal中运行：
cd /opt/ （在这个目录下解压文件）
sudo tar xvf ~/Downloads/firefox-73.0.tar.bz2
sudo ln -s /opt/firefox/firefox /usr/bin/firefox (把firefox链接到/usr/bin/下面）
3）然后，
cd /usr/share/applications
sudo gedit firefox.desktop
 在firefox.desktop里面写上：
[Desktop Entry]
Name=firefox
Comment=firefox
Exec=/opt/firefox/firefox
Icon=/opt/firefox/browser/chrome/icons/default/default128.png
Terminal=false
Type=Application
Categories=Application;
Encoding=UTF-8
StartupNotify=true
**02-11**<br>

打印env部分配置，以确认当前代码是否有问题：
	printk(KERN_EMERG "envirment: \n");
	for(i=0;i<CONFIG_ENV_SIZE;) {
		printk(KERN_EMERG " %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x"
				" %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x"
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]);
	}
	printk(KERN_EMERG "envirment: \n");

## 01-02->...
**01-20**<br>
  基本模块：　flash/spi/ftl/mtd/block
**01-19**<br>
触摸屏明显存在性能问题：
  [01-19 20:51:36.402] [    3.849999] [gslX681]-Enter gsl_ts_init
  [01-19 20:51:36.402] [    3.856666] [gslX681] Enter gsl_ts_probe
  [01-19 20:51:36.410] [    3.863333] input: gslx681 as /devices/platform/imap-iic.2/i2c-2/2-0040/input/input2
  [01-19 20:51:37.529] [    5.299999] i2c-core: driver [gslx681] using legacy suspend method
  [01-19 20:51:37.548] [    5.303333] i2c-core: driver [gslx681] using legacy resume method
  [01-19 20:51:37.549] [    5.306666] [gslX681]-i2c_add_driver return 0

显卡驱动明显存在优化空间：

已经尝试的优化：
１．uboot提升spi时钟速度之后，加载kernel加快了2s，这个已经实现；
２．kernel压缩算法从xz改成lzo，应该可以提速2s，但因为flash空间不够，无法实现；

make menuconfig 建议优化配置：
建议１：QSDK options-> Libs -> libffmpeg，是否有些codecs可以精简节省大小
建议２：Filesystem images-> squashfs target filesystem, 压缩算法使用xz对加载应用程序到内存的速度，影响很大
建议３：QSDK options-> Apps -> Videobox, 是否有些IPU可以精简掉

make linux-menuconfig 考虑优化配置：
建议１：File systems-> Miscellaneous filesystems-> SquashFS 4.0, 压缩算法从xz改为lzo，还有use 4k，都能提高读取应用程序速度
建议２：确认drivers/infotm/imapx15/display/implementation/module/logo
建议３：如果没有用到sdio wifi，可以关闭 InfoTM MMC2(SDIO) Driver enable
建议４：没必要开 CMA_MIGRATE_OFF

我用你们发过来的linuxconfig信息编译了一下代码，检查我这边内核编译的二进制目标中，下面这些请考虑优化：
1. size: 1850482 1月  20 09:05 ./drivers/infotm/imapx15/display/implementation/module/logo/built-in.o
2. size: 449429 1月  20 09:06 ./net/ipv6/built-in.o
3. size: 542489 1月  20 09:06 ./net/mac80211/built-in.o
4. size: 121007 1月  20 09:06 ./net/xfrm/built-in.o
5. size: 216682 1月  20 09:05 ./fs/ext3/built-in.o
6. size: 165830 1月  20 09:05 ./fs/jffs2/built-in.o
7. size: 113011 1月  20 09:05 ./fs/ntfs/built-in.o
8. size: 564175 1月  20 09:05 ./fs/ext4/built-in.o
9. size: 131880 1月  20 09:05 ./fs/jbd2/built-in.o
10. 62445 1月  20 09:05 ./fs/ext2/built-in.o
11. 98592 1月  20 09:05 ./fs/exfat/built-in.o

**01-18**<br>
**01-17**<br>
**01-16**<br>
上午儿子打电话，一个人到军区大院玩去了，得意洋洋的

.max_speed_hz = 27000000, 可以考虑提升频率

dma调试，可以查看１. 当前目标或者源地址;2. 通道状态 3.中断和其他标记; 3.loop counter 4.

flash_dma_reset()函数中，重新初始化ssp会导致加载uboot和item失败，下一步可以打印所有的ssp寄存器，确认一组正确的值．

ssp 寄存器列表：
  step 1: ( 0,cc7)( 4,  a)( 8, ff)( c,  3)(10,  2)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)
  step 2: ( 0,  0)( 4,  0)( 8,  0)( c,  3)(10,  0)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)
  step 3: ( 0,cc7)( 4,  8)( 8,  0)( c,  3)(10,  2)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)
  step 4: ( 0,cc7)( 4,  8)( 8,  0)( c,  3)(10,  2)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)

dma传输过程中，读取　SSP_SR_0　为 3

**01-15**<br>
调试uboot问题的时候, 可以修改 system_update_upgrade() 函数,
需要10项软件著作权，才可以申请高新技术企业．模块包含1500行以上代码就可以申请
1. audiobox 框架 2. AEC 3. FTL 4. videobox 5. 影子端口 6. FR内存管理 7. 人脸侦测优化 8. sensor bridge
9. 鱼眼矫正 10. 视频播放 11. 视频录像 12. mv的移动侦测

**01-14**<br>
分解任务, 建立了几个bug, 安一周的问题分出去
**01-13**<br>
浏览平台软件release的文档, 了解
**01-12**<br>
周日加班. 早起到六院挂号, 结果周日确实是没有门诊的, 网上的信息真是坑人啊.
晚上公司聚会. jim胆结石, 对酒精也过敏.
好好思考一下, 提供什么样的接口给客户:
  就上层应用而言, 最好是一个单独的image, 但这样一定需要同步提供完整的诊断机制.

  内核和驱动呢? 实际上, 客户不可避免的会对这个部分有修改.
  如何解决上层模块和驱动之间的依赖关系呢? 比如音频开发, 是否几个sound驱动模块增加一个版本号, devices.c也应该去掉关于sound的初始化代码, 而转移到sound的init函数, 在audiobox之类的模块增加对版本的依赖判断, 读取下层驱动版本号, 不匹配的话直接报告. 还有是否每个codecs之类的库也应该增加版本,audiobox会做相应的判断.
  audiobox应该保持多个版本号, 一个作为自身的累加版本(可能qplayer和abctrl对他有依赖), 其他对应各个依赖模块.

给客户的release notes, 版本号应该更加鲜明的指示数据结构的变化.

**01-11**<br>
周六. 国际象棋考级, 武宁小学, 因为失利和丢失一个圆珠笔, 儿子吵着要撞墙, 第三遍时因为喋喋不休被训.
老婆的脚很像是脚底板发炎了, 然后导致手上也有炎症性疼痛, 如果耽搁治疗, 担心会有后遗症.
**01-10**<br>
周五,请假. 带老婆儿子上医院, 小熊的流感终于好了, 可老婆的病没有确诊, 风湿免疫科-发热门诊-感染科-骨科, 一通瞎搞.
**01-09**<br>
研发部: 杨洁琼 庞松华 胡彦艳-财? 杨文正-杨老师-杨总;  陈鹏 员清观 郑万虎
**01-08**<br>
首要任务是, 找到所有的q3f平台功能测试用例和结果预判.
**01-04-05-06-07**<br>
公司搬家
**01-02**<br>
今天同学们基本都走光了, 办公室空荡荡的, 感觉说话都有回声, 有点风萧萧兮易水寒的感慨;

无论来年公司是何种走向, 需要保持初心: 认真思考和整理一下之前三年在公司的点点滴滴. 目标: 在不确定的离开之前, 要真正能够开发掌控一个独立的大型软件模块, 要有成为系统架构师的信心

## 系统架构师相关内容整理

核心思想之一: `去耦合, 去重复`

**模块设计**
1. 分层架构设计: 需要有分离分层的思想,层次之间通过api接口调用,不要产生数据上的耦合;并且注意处理上层多个模块对相同功能的调用接口,不要出现太多的冗余api接口
2. 模块化: 模块功能要划分清晰.大模块使用独立的进程, 线程之间也尽量的模块化,即使不是对象编程, 也应该尽量把一个大的进程分割成若干个独立的小模块. 进程和线程之间通信注意要架构清晰,接口简单去耦合
3. 封装常用功能: 如实现工具类，和帮助类，时间或者定时调用, 线程池, 日志和调试诊断, 自动测试机制, 同时要保存好，（耦合性低）以后开发直接拿出来用。
4. 注册回调框架: 数据和算法多选一的时候, 比如aec部分, 切换不同算法直接使用, 避免每次出现长窜的switch-case语句
5. 事件状态管理框架: 类似eventhub这样的接口, 用于管理系统内部的状态，基本思想上订阅发布机制（也称观察者模式），有了它，代码就不用再去请求一堆状态数据了，只需要把你关注打事件或者状态注册一下，当事件发生时，就主动通知给你了。

进程内拆开的小模块, 尽量能够做到外部能够直接进行单元测试. 比如音频模块下, 可以直接导入外部的配置和音频文件进行测试. 如果能够多个小模块可以从外部配置进行关联测试, 就更好了. 类似与ipc.json文件所定义的. 是否audiobox模块也应该定义类似的解析接口, 根据外部配置文件定义的信息进行功能测试呢? 这个解析直接在audiobox模块实现, 可以更加方便的安排单元测试和自动测试.是否应该继续改造audiobox模块, 作为我之后开发的魔板呢?

## 小熊湿疹
调理脾胃：　　　　 https://www.sohu.com/a/276020792_565194
湿热还是寒湿 :    http://www.sohu.com/a/249992438_707230

静安牙防所，早上7点开始排队，7点45开始挂号，8点开始门诊，儿童必须本人到场。
1. 皮肤清洁也很重要，不要怕洗澡，洗完澡之后马上用一些保湿霜润肤
    全身保湿; 应该使用酸性的沐浴，避免碱性肥皂; 秋冬季节干燥，润肤剂尤其要保持使用; 避免冷风或强烈日晒
2. 饮食控制．多食蔬菜和水果，禁止海苔海带海鱼，酸奶，冰淇淋等冷饮，肥肉、奶油蛋糕、巧克力
3. 生活环境控制：最近的换床会否有影响呢? 每周更换床单和枕巾等。
    尽量不要养宠物，尽量不要种鲜花，不要用地毯
    家里也不要养花了。 纯棉的衣服，不要让宝宝穿易刺激皮肤的衣服，如羊毛、丝、尼龙; 修短指甲
4. 主动治疗：是否需要做脱敏治疗呢？
5. 放大镜找螨虫

**得了湿疹吃什么好**<br>
　　番茄。番茄内含丰富的维生素A、维生素B1、维生素B2、维生素C、烟酸，维生素E;还含有苹果酸、柠檬酸，钙、磷、铁及番茄碱等物质。具有生津止咳、健胃消食、凉血平肝、清热等功效。番茄中的果酸对维生素C有保护作用，故而能有效地补充维生素C;番茄碱有抑菌消炎、降低血管通透性作用，所以外用番茄汁治疗湿疹可起到止痒收敛的作用。
　　苦瓜。苦瓜内含奎宁。具有清热解毒、祛湿止痒之功。可用于治疗热毒、疖疮、痱子、湿疹等病症。
　　韭菜。韭菜内含胡萝卜素、维生素B、维生素C及钙。磷、铁、蛋白质、纤维素等。韭菜还有解毒祛湿的功效，故韭菜汁外搽可治湿疹。

钙磷酸酶抑制剂 不含激素，据说效果不错，但比较贵。

主持人：特应性皮炎药物治疗配合润肤剂剂使用频率是什么样的？
顾恒：首先，皮肤干燥是特应性皮炎的诊断标准之一，因此每天使用润肤剂是必不可少的。不同的季节可以选择不同类型的润肤剂，在冬季可以使用油脂性强一点的润肤剂，到了夏季可以使用稍微稀润一点或者油脂性弱一点的润肤剂。如果一些患者病情反复发作，发病比较频繁，可以使用钙调磷酸酶抑制剂这些能够安全有效，且可以长期使用的外用药物治疗。并且在控制住病情后，改用一周2次的长期维持治疗来减少复发频率和严重程度。钙调磷酸酶抑制剂不会出现使用激素类药物的皮肤萎缩、毛细血管扩张不良反应。

正确治疗有五部曲，在经过正确的治疗后，特应性皮炎是可以得到控制和缓解，这样花的代价最小，副反应也是最小。
1.首先，皮肤日常基本护理就是要保护皮肤，使受损的皮肤屏障功能慢慢恢复。通过使用保湿霜或者润肤露都可以起到保护皮肤湿润的功能。另外，皮肤清洁也很重要，不要怕洗澡，洗完澡之后马上用一些保湿霜润肤。
2.其次就是基本的药物治疗，基本的药物治疗就是外用药，对于儿童特应性皮炎患者，一般选用温和的中效或者弱效激素，而不要选用强效激素或者含卤素元素的激素。同时还可以用非激素类药膏，代表就是他克莫司软膏。
3.另外，根据症状，如果瘙痒的非常严重，可以吃一些镇静类的药物，镇静药物可以用西利琴或者罗瑞它丁。如果这些治疗不能完全缓解控制疾病，就需要系统治疗，比如内服激素类药物和免疫抑制剂药物。如果合并细菌感染，则同时需要用一些局部的抗生素软膏进行治疗

甜食促使金黄色葡萄球菌等真菌生长繁殖，引发瘙痒、丘疹、水泡等不适。
油炸食品含有较高的油脂和氧化物质，经常进食易导致血热、血燥，诱发皮肤病。
冰淇淋、棒冰、冰冻水果、冰镇饮料等少吃
避免接触化学清洁剂的伤害也是一个很重要的原因，洗衣粉、洗洁精这些化学清洁剂会破坏皮肤的屏障功能，天气和体质的内因，遇上清洁剂的刺激，就容易诱发汗疱疹。
一、多喝几杯水
2、饮用水量：成年人每天推荐1500ml~1700ml水。按照250ml杯子来折算，就是6~6.8杯；按照200ml杯子来折算，就是7.5~8.5杯。
3、金银花有着清热解毒的功效，在炎热的夏季可以经常看见用金银花泡茶喝的人，能够缓解人体内各地方的炎症问题，起到抗菌消炎的作用。

二、适度保湿
1、皮肤是抵御外部真菌的前线战士，洗手时避免用过热的水，使用温和的清洁产品、洗手后将手擦干，但不宜过度清洁。
2、可使用温和保湿成分护手霜，在洗手后使用。
3、另一个重点是不可以抓破水泡，水泡一旦破了可能增加感染风险，想快去去除的方法就是涂抹眉寿堂修复霜，能有效渗透肌肤还原皮肤，天然无刺激，配合送的止痒喷雾，坚持使用两个星期左右即可恢复，网上很容易找到。

三、勤动动
先以每分钟100步的速度行走，再根据自身的体能，逐渐加快，最快可达到每分钟140步，同时尽可能大幅度地摆动和舒展手臂，以刺激淋巴结，有利于皮肤排出毒素。

饮食适宜：1、饮食宜清淡、爽口；2、饮食要节制。
宜吃食物宜吃理由食用建议
　　木耳。含有丰富的吡嗪，可使血小板凝集率下降，同时能降低血粘度、甘油三酯、改善肺循环。可以同苹果做汤食用。
　　西红柿。含有一种番茄因子有溶解血栓的作用。可以煮汤每日食用。
　　甜瓜。防止血小板凝集，抗血栓形成，还有溶解血栓的功效。将蜂蜜与瓜汁调匀，当饮料饮用。
　　饮食禁忌：1、忌油腻食物；2、忌辛辣刺激性食物；

忌吃食物忌吃理由忌吃建议
　　辣椒。易伤肺气，耗心阴，使心肺气阴两亏，从而加重喘咳等症状。辣油、辣味调料、辣酱、京葱、生姜、芥末、蓼蒿等，都少吃为好。
　　猪油。使痰浊内生，内外邪气搏结，胶固粘滞，从而使咯痰不畅，咳嗽难愈；且使水湿运化失司，水饮溢于四肢、胸胁，出现水肿、喘息不得卧等症状。牛油，奶油、油墩子、炸鹌鹑、电烤鸡、鸭等，尽量不要吃的。
　　冷饮。可阻遏胸阳，生痰滋湿，从而使肺病患者咳喘、咯痰、心悸等症状加重。冰淇淋、棒冰、冰冻水果、冰镇饮料等少吃为好。
    炒菜尽量用植物油, 少用动物油.

山茶油,又称茶油、油茶籽油、茶籽油、野山茶油等,是山茶树果实压榨的木本植物油。 茶油性味甘,凉,功效润胃通肠,退湿热,养颜生发,促进伤口愈合。

上海中医院  脾胃病科


## 今年的书单
记录在印象笔记中实在是有些诡异, 转移到这里吧, 每年
