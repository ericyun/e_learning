*# 工作日志

### 修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2019/01/07 | 员清观 |  |

## misc

~/work/qts/testcase_data/vplay/play/ 3001.txt文件为vplay的脚本文件

江苏路公司wifi:  office : 1234abcd
上海长宁区江苏路398号舜元企业发展大厦A座三楼
祖冲之路887弄83-84号402室

nvp6134
mbox_all.json

**确认**<br>
  分工情况:
  近期任务清单: q3f是否需要测试, 整理测试用例,
  redmine管理, 增加权限, 添加bug来管控问题.

**调试性质启动盘:**<br>
  之后的调试性质启动盘,应该格式化为ext4文件系统; 其他场景保持向前兼容, 找一个合适的方式来判断, 或者使用一个独立的脚本.

**理清个人负责模块:**<br>
  ivan.zhuang - usb otg /frbuffer /usb网口 /uvc /i2c /
  can.cai     - dw_mmc /audio_codec /CCF(common clock framework) /pmu /ether /item /adc /
      pause/resume当前是否有效呢?
  bob.yang    - wifi /upgrade /cep.eventhub /display /net /dvfs(cpu_freq) /


gitk --author=bob.yang

**重建q3f测试流程:**<br>
  1. 检查一下testing文件夹, 哪些测试项目是就绪的.
  2. 整理所有的测试项目, 然后再沟通
  2. 郭东俊 刘艳, 看是否存在appolo3的标准测试过程
  3. 付老师, 了解一下qsdk的基本状况, 比如usb等接口功能的开发程度是否已经完备

**karry, 最好是找个晚餐时间:**<br>
  1. 客户接口
  2. 文档管理, 代码管理git gerrit redmine, bug管理
  3. TestLink系统, 单元测试管理, 自动测试, 压力测试
  4. 客户接口
  5. 研发部门架构:
  6. 开发流程

**auduiobox:**<br>
  1. abctrl命令支持指定默认trace的保存目录
  2. 增加一个新的命令, 原封不动的传递单元测试命令, 现有abctrl debug 支持的外部配置, 命令和参数完整的传输到audiobox后解析执行, 这样, abctrldebug保持同样的版本, 只需要升级audiobox就好

## 12-01->...
## 11-01->...
## 10-01->...
## 09-01->...
## 08-01->...
## 07-01->...
## 06-01->...
## 05-01->...
## 04-01->...
## 03-01->...

new
queue /mnt/sd0/tj.mp4
play



调试发现：　seek之后，之前的所有frame的时间戳信息都是无效的，应该要设置


stop
queue /mnt/sd0/507.tanjing.mp4
play

new
queue /mnt/sd0/test_8k.wav
play


queue /mnt/sd0/give_me_love_tank.aac
play



photo
new
queue /mnt/sd0/5760x3840.jpg
play


photo
new

stop
queue /mnt/sd0/8k.jpg
play


photo
new
queue /mnt/sd0/2100x1400.jpg
play


continue


photo
new
queue /mnt/sd0/1.jpg
play


!!!!!!!!!!!!!!!  /mnt/sd0/030-AVC-PCM-1920x1088.MOV 这个文件的音频格式根本不需要codec的。
SetWorkingState()　存在机制性问题，线程无论如何，不应该自己确定状态。
!!!!!!!!!!!!!!!!!!! 音频和视频AQ VQ差别很大的时候，是否播放不同步的问题比较严重呢？

z
AVFormatContext *av_format_dtx = avformat_alloc_context();;


new
queue /mnt/sd0/MKV001.HDTV.1080P.x264.AC3-CMCT.mkv
play


stop
queue /mnt/sd0/tj.mp4
play


stop
new
queue /mnt/sd0/026-MPEG-4--AAC-720x480.mkv
play

**03-14**<br>
#define VBERR_FR_INTERRUPTED "get fr buffer interrupted"

	sleep(2);
	vplay_media_info_t stMediaFileInfo;
    memset(&stMediaFileInfo, 0, sizeof(stMediaFileInfo));
	vplay_control_player(*pstPlayer, VPLAY_PLAYER_QUERY_MEDIA_INFO, &stMediaFileInfo);
	value = (int)stMediaFileInfo.time_length - 2000;
	printf("&&&&&&&&&&&&&&&&&&&&&&&&& seek to %d\n", value);
	vplay_control_player(*pstPlayer, VPLAY_PLAYER_SEEK, &value);

问题75/83/85/88/90，请验证
问题75，请验证。只有025视频seek失败，请另外专为025建立BUG降低优先级延后处理
问题84，改进了机制，会只播放音乐，不解码视频。 -- 026视频播放问题延后解决
问题85，卡住的问题已经解决。 -- AC3不支持问题延后解决。

问题81，我无法重现，请在出现问题的时候抓个audiobox的完整trace.
问题66/69/79下周跟进
建议相关音频视频无法播放问题另外单独建立新BUG管理，并降低优先级。

另外增加的内容：
调整了音频通道启动方式，解决之前有时候出现的xrun问题，可能会对减少切换后杂音有帮助

**03-13**<br>
OpenNextMediaDemuxer() 函数，应该把结束当前和开始下一个严格分开处理，否则逻辑会有点混乱。
外部消息发送到末尾，内部消息的优先级应该高一点，发送到头部，这样只要一个普通的临界区就可以保护好消息的次序了，不会被外部消息插入到连续的两个内部消息中间。
几个需要发送消息给自己的场景
  QPlayer::Play() 失败
      OpenNextMediaDemuxer()失败，发送stop消息
  QPlayer::StepDisplay()　失败，发送stop消息
  当前播放文件结束，发送play消息，结束当前播放下一个
fr_get_float_remain() 函数可以改造一下，如果满，就返回0xffff

**03-12**<br>
增加状态机机制来支持qplayer工作(参数不能太多)：

```cpp
std::list <VPlayerCommand>     *PMesgList;
    this->PMesgList = new std::list<VPlayerCommand>();
	this->PMesgList->empty();
    this->PMesgList->clear();
    delete this->PMesgList;
    this->CurFile = this->PMesgList->front();
    this->PMesgList->pop_front();
    this->PMesgList->push_back(fileInfo);
    this->PMesgList->size()
    this->PMesgList->clear();

	vplay_file_info_t fileinfo;
	int index = 0;

	for(auto it = this->PFileList->begin();it!=this->PFileList->end();it++){
		fileinfo = *it;
		if (memcmp(fileinfo.file, file, strlen(file)) == 0) {
			pthread_mutex_lock(&this->MesgListLock);
			this->PFileList->erase(it);
			pthread_mutex_unlock(&this->MesgListLock);
			LOGGER_INFO("file %s removed!\n", fileinfo.file);
			break;
		}
    }
	for(auto it = this->PFileList->begin();it!=this->PFileList->end();it++){
		fileinfo = *it;
		LOGGER_INFO("InList:%d %s\n", index, fileinfo.file);
		index++;
    }

    return 1;

  int i;
  char lowfile[8];
	for (i=(strlen(file)-4); i <= strlen(file); i++)
       lowfile[i] = tolower(file[i]);
```
**03-11**<br>
！！！！！！！！！！　AC3音频暂时不支持可好？
！！！！！！！！！！　昨天的补丁pause，会卡住，没有复现
！！！！！！！！！！　增加自动播放完毕自动停止的功能
！！！！！！！！！！　双核是否没有真正的发挥作用？　可以把中断引导到不同的内核。那么spi中断是否也可以呢？
spi是否可以使用16bits的处理呢？
现在的jpg机制重新调整之后，应该可以了。
1920x1088 2100x1400.jpg 宽高比不同
通过互斥锁和消息队列结合完成，play/stop/pasue/seek/continue 发送消息并且通过返回变量来得到返回值，所有的命令都加上锁。
QueryMediaFileInfo　需要用到动态变化可能变为空的指针，所以，用消息
或者可以考虑两个队列，一个专门用来保存返回的内容，这样，好像就完美的模拟了进程间rpc机制了。
基本的机制就是：　发送消息，等待自己消息队列中的返回。

！！！！！！！！！！需要考虑处理
          vplay_control_player 的行为，最好还是改为消息的格式来完成。应该增加一些消息，每个命令对应一个消息。
          播放完毕，应该进入stop状态，但是现在没有啊。现在明显的，外部改变全局变量的行为，也会造成不良影响。！！！！！！！！！
          如果所有线程进入pause状态，是否应该不要再打印统计信息呢？
          play命令应该增加返回：
          解析aac失败的文件，测试一下，返回错误。
          对于不支持的或者是解析错误的格式，应该finish，并返回错误代码
          播放出错了之后，及时结束；并且不要因为太多打印而卡顿不休。
          遇到一个audio的xrun，我判断是因为线程优先级比较低，发送了第一个帧之后，后续帧没有跟上，所以，应该保证读取了三个帧之后或者文件结束

int *ptr = (int *)this->VideoBuffer;
printf("%s: header: (0x%x > 0x%x) (%x %x %x %x)\n"
			, __func__, size, size
			, ptr[0], ptr[1], ptr[2], ptr[3]);

`[Switching to LWP 982]`　－－　`info threads` 查看到当前线程为demuxer,　`bt`看到当前出问题的函数是`free()`，从`/usr/lib/libavcodec.so.57`中被调用。 `WorkLoop,534 header:1 0, frames:0`的打印显示，dec线程必然会立刻停止。

**03-10**<br>
QPlayer::Play()函数应该包涵QPlayer::Stop()函数，逻辑上是正常的。

**03-09**<br>
解码器打印
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
  uint64_t currenttime = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
  LOGE("delay too big, cur:%lld %lld %lld, %lld %lld\n"
								, currenttime, m_stPTS.u64timebase, m_stPTS.u64ptsbase
								, m_stPTS.u64lastpts
								, m_u64timestamp[m_s32PicDecodeNum]);
增加以下处理：
  int audio_pause_channel(int handle, int flag)

VplayTimeStamp::
  this->PlayTs = ts; //　pts时间轴
  this->LastGetTs = SysTime; // 系统时间轴
  this->CurSysTs = SysTime;

VplayTimeStamp::UpdateTs
this->VPlayTs.Start();的调用地点，是否现在太早了

如果frame类型动态变化，可以考虑增加新的动态调整机制。
播放过程中，设置IsAudioMute，之后的音视频同步可能会有问题，应该设置的是audiobox的mute，而不是qplayer的mute. 创建通道时候需要判断，播放过程中这个函数直接配置到音频部分去。


**03-06**<br>
1. 解决了seek问题，需要修正libdemux库
2.
bool QPlayer::StepDisplay()
{
	if(this->OpenNextMediaDemuxer() == false) {
		LOGGER_ERR("open next media file error\n");
        return false;
	}
    LOGGER_INFO("Start step display!\n");
	if (!this->IsStepDisplay) {
		this->SetWorkingState(ThreadingState::Pause);
		this->SetWorkingState(ThreadingState::Pause);
		this->SetWorkingState(ThreadingState::Pause);

		this->IsStepDisplay = true;
		this->SetWorkingState(ThreadingState::Start);
		this->PSpeedCtrl->SetWorkingState(ThreadingState::Start);
	}

    return true;
}

**03-05**<br>
测试停止的地方，应该是音频通道创建了不应该的
[2020-03-05 23:50:13.029] INFO<lib/qplayer.cpp,1518>: Decfr:(d:20,l:26),VFr:20(0),AFr:  0(-1),VQ:20,AQ: -1,V:876 800, pos(2043/133285),fault(0 0 40 0 0)
[2020-03-05 23:50:14.846] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:22(0),AFr:  0(-1),VQ:18,AQ: -1,V:876 800, pos(3046/133285),fault(0 0 48 0 0)
[2020-03-05 23:50:15.863] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:26(0),AFr:  0(-1),VQ:20,AQ: -1,V:876 800, pos(4063/133285),fault(0 0 64 0 0)
[2020-03-05 23:50:16.867] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:22(0),AFr:  0(-1),VQ:18,AQ: -1,V:792 800, pos(5066/133285),fault(0 0 72 0 0)
[2020-03-05 23:50:17.870] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:23(0),AFr:  0(-1),VQ:17,AQ: -1,V:792 800, pos(6070/133285),fault(0 0 81 0 0)
[2020-03-05 23:50:18.937] INFO<lib/qplayer.cpp,1518>: Decfr:(d:26,l:26),VFr:26(0),AFr:  0(-1),VQ:17,AQ: -1,V:668 800, pos(7137/133285),fault(0 0 92 0 0)
[2020-03-05 23:50:19.806] INFO<lib/qplayer.cpp,1585>: vplay player control ->2
[2020-03-05 23:50:19.811] INFO<lib/qplayer.cpp,1036>: ~~~~~~~~~ stop player step
[2020-03-05 23:50:19.819] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12160(demuxer)
[2020-03-05 23:50:19.833] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12170(vplayer)

正常的流程：
[2020-03-05 23:50:11.123] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12160(demuxer)
[2020-03-05 23:50:11.136] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12170(vplayer)
[2020-03-05 23:50:11.150] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x2fc320(aplayer)
[2020-03-05 23:50:11.157] <audio_pause_channel,720>: Critical:audio flush channel:0 ok
[2020-03-05 23:50:11.187] INFO<lib/qplayer.cpp,1044>: ~~~~~~~~~ stop player step
[2020-03-05 23:50:11.192] INFO<lib/qplayer.cpp,1381>: release audio codecs


**03-04**<br>
modified:
  /system/videobox/IPU/VDECODER/VDecoder.cpp
  /system/videobox/IPU/VDECODER/VDecoder.h
  /kernel/drivers/infotm/common/fr/fr-core.c
  /kernel/include/linux/fr.h

  cp -fr ./drivers/infotm/common/fr/fr-core.c ~/Downloads/0305patch/
  cp -fr ./include/linux/fr.h ~/Downloads/0305patch/
  /kernel/include/linux/fr.h

销毁audio和video对象的时候，析构函数中stop之
make hlibunitrace-rebuild
**03-03**<br>
加快stop速度的方法：
1. 保证vdecoder已经停止，并且flush所有的视频帧，现在可能不能保证这一点
2. 优先停止读取文件，然后清空两个媒体流，然后清空音频和视频的播放缓存。
3.

上次建议增加的 audio_pause_channel()　函数有bug，所以现在先去掉了调用.　audiobox 启动时候的buffer，切换视频时需要播放完，所以会影响到反应时间，我会之后处理掉audio_pause_channel()函数的bug来解决这个问题。

当前的qplayer，根本没有等待qaudioplay退出就开始了下一个的工作，这是需要马上改变的。

**03-02**<br>
解码器几个bug:
1. 进入stop状态之后，应该保证把之前所有的frame清空，否则，老的frame影响到新的decoder的行为。类似while ((fr_get_float_remain(&stRef) > 0) && m_s32RunState == EM_VDEC_STOP)肯定是有问题的。
2. 之前所述的else if(HeaderUserflag)判断，导致bufferIn可能会指向上一个被访问的frame.
3. 两处可能的死循环
4. if (++nstops == 1)分支中的VDecReset();调用，实在莫名奇妙。
5. 设置状态和解码id的方式太粗暴
6.

解码器应该增加播放速度控制，增加

qlibvplay模块优化
现状：从客户反馈以及我们自己对代码的审核，建议重构qplayer，而qrecorder部分基本保持现状。对qlayer部分，第一步的优化建议
向前兼容，完全保持之前的api接口，解决结构不合理导致的bug和效率问题。

qplayer第一步优化内容：
1. 为threadcore增加新状态,避免每个loop只处理一个帧的低效情况
2. 调整trace机制，方便后续的开发和支持
3. 删除所有timestamp相关的变量和函数，比如 QPlayer::VPlayTs SpeedCtrl::PVPlayTs 以及相关的辅助内容
4. 去除对class Statistics的引用，因为其统计内容大部无用，而且实现方式麻烦，用新的方式替换
5. 基本保持

AddStreamEndDummy()函数中需要一个时间戳，可以直接使用上一个帧加5
建议在解码器部分增加播放速度控制的机制，而不是qplayer


**03-01**<br>
应该是等待所有的视频播放完毕，然后发送播放结束消息。判断的标准，应该是缓冲区中剩余帧为0或者１

播放完毕，应该先关闭原有的demux，然后在没隔一段年时间，判断是否准备就绪。

fr_get_buf()函数原本通过fr_buf_set_state()调用，阻塞等待获取缓存，float类型没有类似的机制，导致出现bug.

[2020-02-29 11:45:57] [   47.223333] !!!!!!!!!!!!!!!!!! failed to alloc float buf:name:dec0-stream remain:19 size:1048576, pbuf:180224 vbuf:3149824!

毕业后先后在迪比特电子、UT斯达康、敏迅通讯从事过硬件、驱动和通信协议软件的开发，奠定了扎实的技术基础。

2011年作为技术核心参与创办上海伟视清数字技术有限公司，整体负责硬盘录像机和摄像机产品的软件开发工作。在领导团队进行开发工作时，非常注重产品性能和稳定性和关键新功能的开发，打下了坚实的产品基础，这保证了伟视清一直到现在都能在安防市场的残酷竞争中保有一席之地。

2017年加入盈方微电子从事BSP开发工作，致力于深入优化自己所涉及的每一个模块，有效的提高了产品稳定性和音频、回声消除、存储等方面的性能

在公司的三年，主要致力于优化自己所涉及的每一个模块，有效的提高了产品性能和稳定性，主要有：
1. 音频系统的重构，AEC功能的评估测试和优化等
2. BSP存储部分的优化，如提高MMC、SPI接口性能和稳定性，重构nftl算法，为fat32增加延迟分配算法等
3. 内核和uboot启动加速优化
4. 设计基于全志xr871和盈方微Q3f的门铃项目Demo，freertos到盈方微Q3f的移植

一种可能的场景：head占用了剩下的刚好1M中的一个PAGE，然后，后面的一个帧获取内存失败。

float部分使用好像有点问题，

## 02-01->...



**02-28**<br>

if (PPGetResult(m_stPPInst) != PP_OK)
{
  continue;
} 有bug吧,进去了就是死循环

while (m_s32RunState == EM_VDEC_PAUSE) //加的位置有点销魂

void QPlayer::UpdateAllStatics()
{
	if(this->PDemuxVideoInfo != NULL) {
		this->stat.UpdateFifoInfo(PACKET_TYPE_VIDEO,this->PVideoFrFifo->GetQueueSize()
			,this->PVideoFrFifo->GetDropFrameSize());
	}
#ifdef ENABLE_AUDIO
	if(this->PDemuxAudioInfo != NULL)
		this->stat.UpdateFifoInfo(PACKET_TYPE_AUDIO,this->PAudioFrFifo->GetQueueSize()
			,this->PAudioFrFifo->GetDropFrameSize());
#endif
    this->stat.UpdatePacketPTS(PACKET_TYPE_AUDIO,this->VPlayTs.GetTs(this->PlaySpeed));
	this->stat.UpdatePacketPTS(PACKET_TYPE_VIDEO, this->PSpeedCtrl->VideoFrame.timestamp);
}

**02-27**<br>
QPlayer::WorkingThreadTask()　函数中，　判断1s时间到的时候，打印状态统计信息。打印的时候去获取数据，而不是每个frame注册改动，太傻了

m_bHeaderflag 和 HeaderUserflag　都是 true的情况下，dec会执行两次动作：
第一次
  SetVDecInput(m_pu8StreamHeader, (u32)m_pu8StreamHeader, m_s32StreamHeaderLen);
第二次
  SetVDecInput(bufferIn.fr_buf.virt_addr, (u32)bufferIn.fr_buf.phys_addr, bufferIn.fr_buf.size);
  但需要注意的是，bufferIn = m_pstDecBuf->GetReferenceBuffer(&bufferIn);　在第一步并没有被执行，所以，bufferIn　使用的是上个frame的数据
**02-26**<br>
和万虎交接显示相关的内容；display2无人使用，主要是兼容各个平台的需要
继续调试float fr的bug

音视频的编解码，应该和读文件放在不同的线程中吧。读文件应该是一个简单任务。

QPlayer::Stop()中，this->PVideoFrFifo->Flush();this->PAudioFrFifo->Flush();都只能清除本地的fr缓存，无法清除videobox audiobox中已经缓存的帧，所以，QAudioPlayer::ThreadPostStopHook()中audio_put_channel()阻塞调用的结果就是，上层需要等待audiobox播放完毕，才能结束qaudioplay线程。如果是qplayer;:stop命令，那么，应该调用audio_pause_channel(CHAN_PAUSE_FLUSH);

vplay_control_player()函数中，应该增加一个event_regisyter的机制；消息中，增加一个传递字符串的消息，然后可以编辑脚本，发送一个个测试命令，比原有的控制台解析更加方便一些。

float类型，drop和nodrop两种，估计是对应enc和dec两种的，fr_get_float()函数需要考虑这两种情况

fr_get_ref()函数中,两次wait_event_interruptible_timeout()应该改成一次， 对应wake_up_interruptible(&fr->serial_update);和fr->serial_inc

**02-25**<br>
继续调试float fr的bug
**02-24**<br>
if((curTs -  this->LastTs) > 30000) 就改变player线程的优先级，看起来很二
QPlayer::Stop(void) 的实现中，音视频的停止效率差，不应该绑定join()动作；同样的，pause等动作也不应该是阻塞等待式的．
感觉，音视频的demux应该使用两个独立的读取线程，而不是现在这样的
qaudioplayer的workingtask, 应该是持续把所有音频数据送到audiobox，而不是中间usleep(1000);
线程间同步，考虑使用signal或者semphore之类的，而不是低效的轮询模式；状态机需要重新整理，太乱了
vplay_delete_player()函数，free(player);之后修改可能导致crash.
ENABLE_AUDIO 这个宏实在定义的莫名其妙
QPlayer::WorkingThreadTask()　一次调用，应该可以读取多个frame
每个线程，应该增加一个cnt和一个step，以确定当前线程或者说对象的工作状态．
create kworker/1:1H, nice: -20, cpumask: 0x2，　这个打印是调试信息，下个版本去掉、kernel/workqueue.c中
SpeedCtrl::WorkingThreadTask()的逻辑，应该是检查fr的缓冲区，有数据的话才尝试写入，否则休眠等待。

无用代码： frfifoloop.cpp qcodecs.cpp
录音代码： mediamuxer.cpp apicalleraudio.cpp apicallerextra.cpp apicallervideo.cpp qrecorder.cpp
放音代码： qaudioplayer.cpp speedctrl.cpp
共用代码： common.cpp threadcore.cpp qmediafifo.cpp

**02-22**<br>
SpeedCtrl类中，调用Prepare()函数，this->SetWorkingState(ThreadingState::Standby);　启动线程．但是在LoopThreadFunction()　函数中，线程首次启动之后usleep(50000);是不合理的．
abctrl apicall -L 1ffff
**02-21**<br>
mkdir -p /mnt/sd0
mount -t vfat /dev/mmcblk0p1 /mnt/sd0
cd /mnt/sd0
sleep 1
cp video.json /root/.videobox/path.json
vplayer

printk(KERN_EMERG "\n\n!!!!!!!!!!! 2 !!!!!!!!!!!!\n\n");

播放完毕之后没有可切换文件和播放完毕之后有，处理是不同的。

new
queue /mnt/sd0/tj.mp4
play

this->PVideoFrFifo->GetQueueSize()

seek 170000

**02-20**<br>
md文档转换为word格式的方法：1. atom中，md转html  2. LibreWriter中，html转docx 3. LibreWriter中，docx中调整所有图片，这样会移除原有的image链接地址，并替换掉图片原有的svg格式

安一周项目kernel启动优化点：
[2020-02-14 22:25:42:191] [    0.533333] imapfb init
[2020-02-14 22:25:42:628] [    0.893333] [dss][abstraction] <error> terminal_configure: Terminal lcd_panel not found.

[2020-02-14 22:25:43:542] [    1.666666] nvp6134_probe 1580
[2020-02-14 22:25:44:855] [    2.946666] [nvp6134_init 1271] camif open...

[2020-02-14 22:25:44:995] [    3.089999] es8388_probe() es8388_reset OK!
[2020-02-14 22:25:45:722] [    3.816666] es8388_set_bias_level

唯一的剩余提速可能调试失败了：　chip_info->ctrl_len　设定为１６位．可以设定为，dma模式下使用16位模式，这样，一次可以拷贝的数据更多，应该可以容纳更快的速度吧．
static void do_force_width(struct pl022 *pl022, int enable_16bits)
{
	int bits;

	struct chip_data *chip = pl022->cur_chip;

	if (enable_16bits) {
		if (chip->n_bytes != 2) {
			bits = 16;
			chip->n_bytes = 2;
			chip->read = READING_U16;
			chip->write = WRITING_U16;
			SSP_WRITE_BITS(chip->cr0, bits - 1, SSP_CR0_MASK_DSS, 0);
			writew(chip->cr0, SSP_CR0(pl022->virtbase));
		}
	} else {
		if (chip->n_bytes != 1) {
			bits = 8;
			chip->n_bytes = 1;
			chip->read = READING_U8;
			chip->write = WRITING_U8;
			SSP_WRITE_BITS(chip->cr0, bits - 1, SSP_CR0_MASK_DSS, 0);
			writew(chip->cr0, SSP_CR0(pl022->virtbase));
		}
	}
}
unsigned int bits = spi->bits_per_word;

**02-19**<br>

软件著作权文档格式：
1. 项目背景
2. 软件功能介绍
3. 软件特性介绍
4. 系统物理结构
5. 系统总结构　：　系统框架图，描述几个主要子模块，系统总的流程图
6. 系统主要子系统
7. 算法设计
8. 接口设计
9. 系统出错处理设计
10. 系统维护设计

**02-17**<br>
张江4标搬家，找电脑和盘点零部件；
**02-14**<br>
音频处理部分，应该增加对时间戳和帧率的显示和监测
env分区的内容：　86 fd ae 36 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

touch /tmp/uboot
time dd if=/dev/spiblock0 of=/tmp/uboot bs=4096 count=1
hexdump /tmp/uboot -n 256

time dd if=/dev/spiblock0 of=/dev/null bs=4096 count=1024
time dd if=/dev/spiblock0 of=/dev/null bs=1024 count=4096
real  0m 12.8 --> 1.58s

cat /proc/kmsg

**02-13**<br>
为了更加自由的使用aec功能，增加调用下面函数，设定aec处理的时候右声道为有效mic通道：
   audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_REFCHAN, 1);

可以尝试下面场景，对比分析一下结果：
1. 底层设置16k采样率，配置 audio_set_aecfreq("default_mic", 16000);
2. 底层设置8k采样率，配置 audio_set_aecfreq("default_mic", 8000);

改变aec的参考音延时，可能会影响到aec效果：
audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_V2DELAY, 400);
audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_V2DELAY, 800);
．．．
audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_V2DELAY, 3000);

**02-12**<br>
软件著作权：　ＩＵＷ　WINDOW平台升级
1. videobox　2. audiobox　3. vplayer　4. vrecorder　5. 无人机软件包　6. 儿童故事机软件包　　7. eventhub　8. IQ调试工具
9. 鱼眼矫正工具　10.智能门铃软件包　11. Sensor bridge　12. FTL　13. FR内存管理　14. 人脸侦测优化　15. mv的移动侦测
16. 影子端口　17. G2D　18. 显示模块　19. 电子防抖　20. 旋转功能　21. H264智能P帧　22. 智能码率控制
 ---- 分类管理 ---- ：
1. videobox　2. audiobox　3. vplayer/vrecorder　4. FR内存管理　5. 电子防抖　6. 旋转功能　7. H264智能P帧　8. 智能码率控制
7. eventhub　8. IQ调试工具　9. 鱼眼矫正工具　10.智能门铃软件包　11. Sensor bridge　12. FTL　14. 人脸侦测优化
15. mv的移动侦测　16. 影子端口　17. G2D　18. 显示模块

我的：　　audiobox　vplayer  vrecorder ftl
万虎的：　FR内存管理  eventhub　G2D　显示模块


eventhub　

贵司文档中提到: "文档提供设计手册的应有软件完整的总体设计描述、总体结构和模块设计、功能分配、各项功能与程序结构关系、软件设计流程图"
请问下，对软件设计说明文档的内容和格式是否有强制要求呢？比如说我现在已经有了一个软件文档，但内容上并不是按照上述的方式组织的，那么我需要重构或重新写文档么？

1）要安装最新的，先要卸载之前的版本：[1]
sudo apt-get remove firefox
2）然后在terminal中运行：
cd /opt/ （在这个目录下解压文件）
sudo tar xvf ~/Downloads/firefox-73.0.tar.bz2
sudo ln -s /opt/firefox/firefox /usr/bin/firefox (把firefox链接到/usr/bin/下面）
3）然后，
cd /usr/share/applications
sudo gedit firefox.desktop
 在firefox.desktop里面写上：
[Desktop Entry]
Name=firefox
Comment=firefox
Exec=/opt/firefox/firefox
Icon=/opt/firefox/browser/chrome/icons/default/default128.png
Terminal=false
Type=Application
Categories=Application;
Encoding=UTF-8
StartupNotify=true
**02-11**<br>

打印env部分配置，以确认当前代码是否有问题：
	printk(KERN_EMERG "envirment: \n");
	for(i=0;i<CONFIG_ENV_SIZE;) {
		printk(KERN_EMERG " %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x"
				" %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x"
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]);
	}
	printk(KERN_EMERG "envirment: \n");

## 01-02->...
**01-20**<br>
  基本模块：　flash/spi/ftl/mtd/block
**01-19**<br>
触摸屏明显存在性能问题：
  [01-19 20:51:36.402] [    3.849999] [gslX681]-Enter gsl_ts_init
  [01-19 20:51:36.402] [    3.856666] [gslX681] Enter gsl_ts_probe
  [01-19 20:51:36.410] [    3.863333] input: gslx681 as /devices/platform/imap-iic.2/i2c-2/2-0040/input/input2
  [01-19 20:51:37.529] [    5.299999] i2c-core: driver [gslx681] using legacy suspend method
  [01-19 20:51:37.548] [    5.303333] i2c-core: driver [gslx681] using legacy resume method
  [01-19 20:51:37.549] [    5.306666] [gslX681]-i2c_add_driver return 0

显卡驱动明显存在优化空间：

已经尝试的优化：
１．uboot提升spi时钟速度之后，加载kernel加快了2s，这个已经实现；
２．kernel压缩算法从xz改成lzo，应该可以提速2s，但因为flash空间不够，无法实现；

make menuconfig 建议优化配置：
建议１：QSDK options-> Libs -> libffmpeg，是否有些codecs可以精简节省大小
建议２：Filesystem images-> squashfs target filesystem, 压缩算法使用xz对加载应用程序到内存的速度，影响很大
建议３：QSDK options-> Apps -> Videobox, 是否有些IPU可以精简掉

make linux-menuconfig 考虑优化配置：
建议１：File systems-> Miscellaneous filesystems-> SquashFS 4.0, 压缩算法从xz改为lzo，还有use 4k，都能提高读取应用程序速度
建议２：确认drivers/infotm/imapx15/display/implementation/module/logo
建议３：如果没有用到sdio wifi，可以关闭 InfoTM MMC2(SDIO) Driver enable
建议４：没必要开 CMA_MIGRATE_OFF

我用你们发过来的linuxconfig信息编译了一下代码，检查我这边内核编译的二进制目标中，下面这些请考虑优化：
1. size: 1850482 1月  20 09:05 ./drivers/infotm/imapx15/display/implementation/module/logo/built-in.o
2. size: 449429 1月  20 09:06 ./net/ipv6/built-in.o
3. size: 542489 1月  20 09:06 ./net/mac80211/built-in.o
4. size: 121007 1月  20 09:06 ./net/xfrm/built-in.o
5. size: 216682 1月  20 09:05 ./fs/ext3/built-in.o
6. size: 165830 1月  20 09:05 ./fs/jffs2/built-in.o
7. size: 113011 1月  20 09:05 ./fs/ntfs/built-in.o
8. size: 564175 1月  20 09:05 ./fs/ext4/built-in.o
9. size: 131880 1月  20 09:05 ./fs/jbd2/built-in.o
10. 62445 1月  20 09:05 ./fs/ext2/built-in.o
11. 98592 1月  20 09:05 ./fs/exfat/built-in.o

**01-18**<br>
**01-17**<br>
**01-16**<br>
上午儿子打电话，一个人到军区大院玩去了，得意洋洋的

.max_speed_hz = 27000000, 可以考虑提升频率

dma调试，可以查看１. 当前目标或者源地址;2. 通道状态 3.中断和其他标记; 3.loop counter 4.

flash_dma_reset()函数中，重新初始化ssp会导致加载uboot和item失败，下一步可以打印所有的ssp寄存器，确认一组正确的值．

ssp 寄存器列表：
  step 1: ( 0,cc7)( 4,  a)( 8, ff)( c,  3)(10,  2)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)
  step 2: ( 0,  0)( 4,  0)( 8,  0)( c,  3)(10,  0)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)
  step 3: ( 0,cc7)( 4,  8)( 8,  0)( c,  3)(10,  2)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)
  step 4: ( 0,cc7)( 4,  8)( 8,  0)( c,  3)(10,  2)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)

dma传输过程中，读取　SSP_SR_0　为 3

**01-15**<br>
调试uboot问题的时候, 可以修改 system_update_upgrade() 函数,
需要10项软件著作权，才可以申请高新技术企业．模块包含1500行以上代码就可以申请
1. audiobox 框架 2. AEC 3. FTL 4. videobox 5. 影子端口 6. FR内存管理 7. 人脸侦测优化 8. sensor bridge
9. 鱼眼矫正 10. 视频播放 11. 视频录像 12. mv的移动侦测

**01-14**<br>
分解任务, 建立了几个bug, 安一周的问题分出去
**01-13**<br>
浏览平台软件release的文档, 了解
**01-12**<br>
周日加班. 早起到六院挂号, 结果周日确实是没有门诊的, 网上的信息真是坑人啊.
晚上公司聚会. jim胆结石, 对酒精也过敏.
好好思考一下, 提供什么样的接口给客户:
  就上层应用而言, 最好是一个单独的image, 但这样一定需要同步提供完整的诊断机制.

  内核和驱动呢? 实际上, 客户不可避免的会对这个部分有修改.
  如何解决上层模块和驱动之间的依赖关系呢? 比如音频开发, 是否几个sound驱动模块增加一个版本号, devices.c也应该去掉关于sound的初始化代码, 而转移到sound的init函数, 在audiobox之类的模块增加对版本的依赖判断, 读取下层驱动版本号, 不匹配的话直接报告. 还有是否每个codecs之类的库也应该增加版本,audiobox会做相应的判断.
  audiobox应该保持多个版本号, 一个作为自身的累加版本(可能qplayer和abctrl对他有依赖), 其他对应各个依赖模块.

给客户的release notes, 版本号应该更加鲜明的指示数据结构的变化.

**01-11**<br>
周六. 国际象棋考级, 武宁小学, 因为失利和丢失一个圆珠笔, 儿子吵着要撞墙, 第三遍时因为喋喋不休被训.
老婆的脚很像是脚底板发炎了, 然后导致手上也有炎症性疼痛, 如果耽搁治疗, 担心会有后遗症.
**01-10**<br>
周五,请假. 带老婆儿子上医院, 小熊的流感终于好了, 可老婆的病没有确诊, 风湿免疫科-发热门诊-感染科-骨科, 一通瞎搞.
**01-09**<br>
研发部: 杨洁琼 庞松华 胡彦艳-财? 杨文正-杨老师-杨总;  陈鹏 员清观 郑万虎
**01-08**<br>
首要任务是, 找到所有的q3f平台功能测试用例和结果预判.
**01-04-05-06-07**<br>
公司搬家
**01-02**<br>
今天同学们基本都走光了, 办公室空荡荡的, 感觉说话都有回声, 有点风萧萧兮易水寒的感慨;

无论来年公司是何种走向, 需要保持初心: 认真思考和整理一下之前三年在公司的点点滴滴. 目标: 在不确定的离开之前, 要真正能够开发掌控一个独立的大型软件模块, 要有成为系统架构师的信心

## 系统架构师相关内容整理

核心思想之一: `去耦合, 去重复`

**模块设计**
1. 分层架构设计: 需要有分离分层的思想,层次之间通过api接口调用,不要产生数据上的耦合;并且注意处理上层多个模块对相同功能的调用接口,不要出现太多的冗余api接口
2. 模块化: 模块功能要划分清晰.大模块使用独立的进程, 线程之间也尽量的模块化,即使不是对象编程, 也应该尽量把一个大的进程分割成若干个独立的小模块. 进程和线程之间通信注意要架构清晰,接口简单去耦合
3. 封装常用功能: 如实现工具类，和帮助类，时间或者定时调用, 线程池, 日志和调试诊断, 自动测试机制, 同时要保存好，（耦合性低）以后开发直接拿出来用。
4. 注册回调框架: 数据和算法多选一的时候, 比如aec部分, 切换不同算法直接使用, 避免每次出现长窜的switch-case语句
5. 事件状态管理框架: 类似eventhub这样的接口, 用于管理系统内部的状态，基本思想上订阅发布机制（也称观察者模式），有了它，代码就不用再去请求一堆状态数据了，只需要把你关注打事件或者状态注册一下，当事件发生时，就主动通知给你了。

进程内拆开的小模块, 尽量能够做到外部能够直接进行单元测试. 比如音频模块下, 可以直接导入外部的配置和音频文件进行测试. 如果能够多个小模块可以从外部配置进行关联测试, 就更好了. 类似与ipc.json文件所定义的. 是否audiobox模块也应该定义类似的解析接口, 根据外部配置文件定义的信息进行功能测试呢? 这个解析直接在audiobox模块实现, 可以更加方便的安排单元测试和自动测试.是否应该继续改造audiobox模块, 作为我之后开发的魔板呢?



## 小熊湿疹

湿热还是寒湿 :    http://www.sohu.com/a/249992438_707230

静安牙防所，早上7点开始排队，7点45开始挂号，8点开始门诊，儿童必须本人到场。
1. 皮肤清洁也很重要，不要怕洗澡，洗完澡之后马上用一些保湿霜润肤
    全身保湿; 应该使用酸性的沐浴，避免碱性肥皂; 秋冬季节干燥，润肤剂尤其要保持使用; 避免冷风或强烈日晒
2. 饮食控制．多食蔬菜和水果，禁止海苔海带海鱼，酸奶，冰淇淋等冷饮，肥肉、奶油蛋糕、巧克力
3. 生活环境控制：最近的换床会否有影响呢? 每周更换床单和枕巾等。
    尽量不要养宠物，尽量不要种鲜花，不要用地毯
    家里也不要养花了。 纯棉的衣服，不要让宝宝穿易刺激皮肤的衣服，如羊毛、丝、尼龙; 修短指甲
4. 主动治疗：是否需要做脱敏治疗呢？
5. 放大镜找螨虫

**得了湿疹吃什么好**<br>
　　番茄。番茄内含丰富的维生素A、维生素B1、维生素B2、维生素C、烟酸，维生素E;还含有苹果酸、柠檬酸，钙、磷、铁及番茄碱等物质。具有生津止咳、健胃消食、凉血平肝、清热等功效。番茄中的果酸对维生素C有保护作用，故而能有效地补充维生素C;番茄碱有抑菌消炎、降低血管通透性作用，所以外用番茄汁治疗湿疹可起到止痒收敛的作用。
　　苦瓜。苦瓜内含奎宁。具有清热解毒、祛湿止痒之功。可用于治疗热毒、疖疮、痱子、湿疹等病症。
　　韭菜。韭菜内含胡萝卜素、维生素B、维生素C及钙。磷、铁、蛋白质、纤维素等。韭菜还有解毒祛湿的功效，故韭菜汁外搽可治湿疹。

钙磷酸酶抑制剂 不含激素，据说效果不错，但比较贵。

主持人：特应性皮炎药物治疗配合润肤剂剂使用频率是什么样的？
顾恒：首先，皮肤干燥是特应性皮炎的诊断标准之一，因此每天使用润肤剂是必不可少的。不同的季节可以选择不同类型的润肤剂，在冬季可以使用油脂性强一点的润肤剂，到了夏季可以使用稍微稀润一点或者油脂性弱一点的润肤剂。如果一些患者病情反复发作，发病比较频繁，可以使用钙调磷酸酶抑制剂这些能够安全有效，且可以长期使用的外用药物治疗。并且在控制住病情后，改用一周2次的长期维持治疗来减少复发频率和严重程度。钙调磷酸酶抑制剂不会出现使用激素类药物的皮肤萎缩、毛细血管扩张不良反应。

正确治疗有五部曲，在经过正确的治疗后，特应性皮炎是可以得到控制和缓解，这样花的代价最小，副反应也是最小。
1.首先，皮肤日常基本护理就是要保护皮肤，使受损的皮肤屏障功能慢慢恢复。通过使用保湿霜或者润肤露都可以起到保护皮肤湿润的功能。另外，皮肤清洁也很重要，不要怕洗澡，洗完澡之后马上用一些保湿霜润肤。
2.其次就是基本的药物治疗，基本的药物治疗就是外用药，对于儿童特应性皮炎患者，一般选用温和的中效或者弱效激素，而不要选用强效激素或者含卤素元素的激素。同时还可以用非激素类药膏，代表就是他克莫司软膏。
3.另外，根据症状，如果瘙痒的非常严重，可以吃一些镇静类的药物，镇静药物可以用西利琴或者罗瑞它丁。如果这些治疗不能完全缓解控制疾病，就需要系统治疗，比如内服激素类药物和免疫抑制剂药物。如果合并细菌感染，则同时需要用一些局部的抗生素软膏进行治疗

## 今年的书单
记录在印象笔记中实在是有些诡异, 转移到这里吧, 每年
