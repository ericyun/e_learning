# 基于BuildRoot集成开发环境

## 0 修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2017/09/14 | 员清观 | 常用操作索引，尽量简短方便使用 |

---
## 99 系统架构相关

**多进程**<br>
  https://www.sohu.com/a/207313547_505803
1.物理模型逼迫你实现模块的解耦 2.方便定位问题 3.方便性能测试 4.方便应对万一需要的分布式部署

**之路**<br>
  https://blog.csdn.net/zxh19800626/category_6265187.html
  https://blog.csdn.net/zxh19800626/article/details/84801636
  https://blog.csdn.net/juS3Ve/article/details/78933048

Elecard StreamEye Tools
CppUTest 单元测试工具
FitNesse 组件测试工具

软件文档的开发可以使用类似敏捷的方式, 增量迭代, 先有一个基本的框架

## 7. QPlayer忽略问题
fr_get_float_remain() 函数可以改造一下，如果满，就返回0xffff


025-空中绞杀者-AVC-FLAC-1920x1080.mkv　seek失败问题
026视频文件，头部为0无法播放的问题
give_me_love_tank.aac 解析aac格式失败

## 6. qlibvplay模块优化
qplayer轻量化，单音频或者单视频或者单图片，不要做太多无用的工作。QPlayer::Prepare()函数中就需要进行处理。

## 5. videobox模块优化

当前的解码器功能不完备：
  1. 消息队列机制和其他太多功能共享，无法阻塞操作，线程同步弱
  2. 打印不完整，调试不方便
  3. 对异常时间戳的容错差
  4. 解码器切换必须复位，可持续开发差
  5. 被ids影响大，时间轴乱序严重

## 4. audiobox模块优化
QPlayer::Seek 的时候，可以考虑直接关闭音频通道，然后重新建立。
QPlayer::Pause　的时候，音频当前只能 audio_pause_device() 函数停止alsa的播放

上层如何确定底层支持音频的位宽呢？现在是每次出错的时候提示客户。应该允许设备参数只指定某项的限制，比如位宽和采样率中间的一项。
上层可以判断音频文件的大小，如果音频帧率比较少，设定alsa的start动作为1个字节。
audiobox提供的通道播放缓存，应该设定为float fr，现在太容易溢出了。因为不知道客户每次放多少个采样点。

下面这些好像是不必要的定义：
    DEMUX_AUDIO_PCM_S16E
    VPLAY_CODEC_AUDIO_PCM_S16E


## 3. 文档管理

文档管理:
  1. 确定需要整理编辑哪些文档
  2. 文档的内容规划和格式要求
  3. 划分主体模块,每个模块的内容如何定义
  4. 工具列表和基本使用文档:
  5. 部门软件开发流程和框架介绍

培训管理:

代码管理: 至少需要考虑客户版本迭代的问题


软件品管:
  1. 测试:单元测试覆盖主要的功能接口, 自动测试, 压力测试
  2. 诊断调试: 整理各种可用的工具和手段,有效的trace
  3.

## 2. 软件质量管理相关
一个比较全面的品质管理文章列表: https://blog.csdn.net/binnacler/category_273848.html

在ANSI/IEEE中提到的软件的6个品质要素如下：
　　正确性：实现的功能达到设计规范并满足用户需求的程度。
　　可靠性：在规定的时间和条件下，维持其性能水准的程度。
　　易用性：用户掌握软件操作所要付出的时间及努力程度。
　　效率：软件执行某项功能所需的计算机资源和时间的有效程度。
　　可维护性：当环境改变或者软件发生错误时，执行修改或者修复所作的努力地程度。
　　可移植性：从一个系统/环境移到另一个系统/环境的容易程度。

## 1. 非功能需求
所谓非功能性需求，是指软件产品为满足用户业务需求而必须具有且除功能需求以外的特性。软件产品的需求可以分为功能性需求和非功能性需求，其中非功能性需求是常常被轻视，甚至被忽视的一个重要方面。其实，软件产品非功能性定义不仅决定产品的质量，还在很大程度上影响产品的功能需求定义。如果事先缺乏很好的非功能性需求定义，结果往往是使产品在非功能性需求面前捉襟见肘，甚至淹没功能性需求给用户带来的价值。

下面对其中的某些指标加以说明。
1、功能性
功能性指与一组功能及其指定的性质有关的一组属性，这里的功能是指满足明确或者隐含的需求的那些功能。具体包括：

    适合性：与规定任务能否提供一组功能，以及这组功能的适合程度有关的软件属性，例如面向任务系统中由子功能构成的功能是否合适，表容量是否合适等等。
    准确性：与能否得到正确或者相符的结果或者效果有关的软件属性。
    互操作性：与其他指定系统进行交互的能力有关的软件属性。
    依从性：使软件遵循有关的标准约定法规及类似规定的软件属性。
    安全性：即与防止对程序技术局的非授权的故意或者意外访问的能力有关的软件属性。如用户权限、动态口令、数据库字段加密等。

对于这组非功能需求来说，绝大部分是满足功能需求的情况，他并不需要采用额外的措施，而安全性是一个例外，它会涉及具体的技术性功能需求。

2、可靠性
可靠性之与在规定的一段时间和条件下软件维持其性能水平的能力有关的一组属性。具体包括：

    成熟性：与有软件故障引起失效的频度有关的软件属性。
    容错性：与在软件故障或违反指定接口的情况下维持规定的性能水平的能力有关的软件属性。如离线录入支持等。
    易恢复性：与在是小发生后重建其性能水平并恢复直接受影响数据的能力，以及为达到此目的所需时间和努力有关的软件属性。如表单数据自动保存等。

这类非功能需求通常是全局的，他除了与系统运行环境、平台选择、代码质量相关之外，还会涉及部分技术性功能需求，他别是容错性、易恢复性的实现都需要一些具体的功能来支持。

3、易用性
易用性是与一组规定或者潜在的用户为使用其软件所需做的努力和对这样的使用所作的评价有关的一组属性。具体包括：

    易理解性：与用户为人质逻辑概念即其应用范围所花的努力有关的软件属性。
    易学习性：与用户为学习软件应用所花的努力有关的软件属性。
    易操作性：与用户为操作和运行控制所花的努力有关的软件属性。如带首字母筛选功能的下拉列表等。

这类非功能需求是与UI设计、联机帮助系统有着直接关系的，易理解性和易学习性通常和界面导航、联机帮助有关，课归纳为界面友好性；易操作性则会和界面元素设计有关。也就是说这类属性会关联到具体的技术性功能需求。

4、效率
效率是指与在规定的条件下软件的性能水平与所使用资源量有关的一组属性。具体如下：

    时间特性：与软件执行器功能时响应和处理时间及吞吐量有关的软件属性。如数据缓存等。
    资源特性：与在软件执行其功能时所使用的资源数量及其使用时间有关的软件属性。如数据压缩等。

这部分实际上就是通常所说的性能需求，他有一大部分是局部性的，在每个用力的描述中应该指出；另外它又会引申出一些相关的技术性功能需求，例如数据缓存等。

5、维护性
维护性是指与进行指定的修改所需的努力有关的一组属性。具体包括：

    易分析性：与为诊断缺陷或者失效原因及为判定待修改的部分所需努力有关的软件属性。如日志记录系统等。
    易改变性：与进行修改排除错误或者适应环境变化所需努力有关的软件属性。
    稳定性：与修改所造成的未预料结果的风险有关的软件属性。
    易测试性：与确认已修改软件所需的努力有关的软件属性。

这部分通常是开发团队最容易投入时间和成本的地方，诸如动态属性支持、UI界面生成、流程引擎等都是为了提高系统的可维护性，因此它显然是会引申出相关的技术性功能需求的。

6、可移植性
可移植性是指与软件可从某一环境转移到另一环境的能力有关的一组属性。具体包括：

    适应性：与软件无需采用有别于为该软件准备的活动和手段就可能适应不同的规定环境有关的软件属性。如全球技术支持等。
    易安装性：与在指定的环境下安装软件所需努力有关的软件属性。如在线更新、安装包自动生成等。
    遵循性：使软件遵循与可移植性有关的标准或约定的软件属性。
    可替换性：与软件在该环境中用来替代指定的其他软件的机会和努力有关的软件属性
