## linux时钟子系统

###  修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2018/04/10 | 员清观 |  |



## 1 C20芯片开发
### 1.1 cpu动态变频


```cpp
  动态变频修改： > CPU Power Management > CPU Frequency scaling > Default CPUFreq governor (userspace)
cd /sys/devices/system/cpu/cpu0/cpufreq/
echo 516000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed
cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq

切换频率的时候，是否需要重新计算jiffies的参数。
static int imapx_cpu0_millivolts[MAX_DVFS_FREQS] = { 1100, 1100,
	1100, 1100, 1100, 1100, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050};
	//1100, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050};
evb板不稳定，修改vdd_core之后解决



meld products/q3f_ring/configs/qsdk_defconfig .config
meld products/q3f_ring/configs/busybox_defconfig output/build/busybox-1.21.1/.config
meld products/q3f_ring/configs/linux_defconfig output/build/linux-local/.config
```


### 1.2
### 1.3
**查询时钟**<br>
`cat /sys/kernel/debug/clk/clk_summary`

**相关代码文件**
```cpp
./kernel/drivers/infotm/
./kernel/drivers/clk
./kernel/arch/arm/mach-apollo3/include/mach/clk.h
./kernel/arch/arm/mach-apollo3/include/mach/clk.h

./kernel/drivers/infotm/q3f/clk/clk-debugfs.c //从中了解如何动态配置mmc的时钟
```

**验证尝试添加新的debugfs**<br>
尝试自己添加新的debugfs来调试现有的驱动模块，包括block等。

**客户在函数中修改sd控制器时钟**
```cpp
    #if 1
    static void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)
        也可以在这个函数中修改时钟的最大值
    static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
        #if defined(CONFIG_APOLLO3_FPGA_PLATFORM) || defined (CONFIG_CORONAMPW_FPGA_PLATFORM)
		mmc_set_clock(host, 15000000);
		#else
		mmc_set_clock(host, mmc_sd_get_max_clock(card)); //把sd卡允许的最大时钟作为参数。
		#endif
```
**spi flash测试**
１．使用extfs，读写都要测试
２．时钟波形对比
３．代码应该禁止NCO模式
４．压力测试，速度测试，给出结论
５．spi flash 改变dummy参数，看看对结果有何影响．

molan测试的几个场景：
3.1. AEC 打开的单边语音传递
    本地ipc播放静音信息或不播放声音，本地pc播放声音，开启aec测试录音
    本地ipc播放声音，本地pc静音，开启aec测试录音
    本地ipc和pc同时播放声音，开启aec测试录音
切换音源：
    语音和音乐

[2018-02-04 08:47:57.480] test:(ok:1149, fail:0)


mkfs.vfat /dev/spiblock1
mkdir /mnt/sd3
mount -t vfat /dev/spiblock1 /mnt/sd3
mmc_test verify -m /mnt/sd3 -r 2400


参数定制：
AEC 模块实际上是由 Analysis,Adaptive filtering,Residual echo suppression,Noise suppression,Synthesis 这些部分组成。首先参考音、混合音会被 Analysis 分成 N 个频率带,之后的处理都会在各自的频率带内并行进行;对每一个频率带,在 Adaptive filtering 中进行自适应滤波,以参考音为自适应目标,自动调节滤波器
参数,使得混合音的滤波结果与参考音一致,同时滤波器还有另外一个输出,就是去除回音的音频数据;在每一个频率带上 Residual echo suppression 评价去除回音的音频数据,如果其信号水平低于某个阈值,将会将此频率带的信号替换为 Comfort noise;Noise suppression 对每个频率带进行噪声抑制;最后将所有的频率带通过 Synthesis
进行合成。在这种框架结构下,AEC 算法有以下特性:(1)可以在每个频率带进行不同的参数设置,来针对某个具体的频率不同的处理;(2)由于是在每个频率带内进行自适应滤波,所以收敛时间相对于全频率的自适应滤波的收敛时间更短,所以某种程度上的回音产生环境的变化会很快被适应,回音消除重新达到最好效果;(3)由于频率带数量较多,部分频率带产生的失常对整体的效果不会产生毁灭性的打击,每个频率带内由于处于临界状态产生的效果大幅变化也不会对整体效果造成大幅影响。
所以在调节参数时,对针对频率带的参数可以适当激进,而对针对整体的参数则需要保守一些。

struct bus_and_dev_clk_info{
    uint32_t dev_id;
    uint32_t nco_en;            /* NCO en  should be ENABLE or DISABLE */
    uint32_t clk_src;           /* APLL, DPLL, EPLL, VPLL, OSC_CLK, XEXTCLK */
    uint32_t nco_value;         /* nco is 8 bit effective  */
    uint32_t clk_divider;       /* clk divider  [4 : 0] */
	uint32_t nco_disable;
};

#define DEV_CLK_INFO(_dev_id, _nco_en, _clk_src,　_nco_value, _clk_divider, disable) \
{\
	.dev_id = _dev_id, \
	.nco_en = _nco_en, \
	.clk_src = _clk_src, \
	.nco_value = _nco_value, \
	.clk_divider = _clk_divider, \
	.nco_disable = disable, \
}

static struct bus_and_dev_clk_info dev_clk_info[] = {
    DEV_CLK_INFO(SSP_CLK_SRC, 0, EPLL, 0, 3, ENABLE),
}

初始化的时候，使用devide模式，所以得到148500000HZ.

SSP,为了保证clk质量，是否应该禁止nco


void mmc0_set_rate(struct dw_mci *host)
{
        const struct dw_mci_drv_data *drv_data = host->drv_data;
        struct dw_mci *mmc_host = host;

        //获取设备时钟源
        host->ciu_clk = clk_get_sys("imap-mmc.0", "sd-mmc0");

        //先设置设备父时钟源是"epll"，然后设置时钟频率为50MHz :: 如何确定父时钟源?
        //最后读取时钟频率看是否设置成功
        clk_set_parent(mmc_host->ciu_clk,clk_get_sys("epll","epll"));
        clk_set_rate(mmc_host->ciu_clk,50000000);
        mmc_host->bus_hz = clk_get_rate(mmc_host->ciu_clk);
        if(mmc_host->bus_hz != 50000000)
                printk("set freq err!\n");

        //打开设备时钟源
        clk_prepare_enable(host->ciu_clk);

        //关闭和释放设备时钟源
        clk_disable_unprepare(host->ciu_clk);
        clk_put(host->ciu_clk);
}



## 3 初始化框架

```cpp
Apoll3查看设备初始化流程，grep "MACHINE_START" -r ./kernel/ | grep "apollo3" ，这是重要的入口部分，然后开始跟踪
    入口文件为： ./kernel/arch/arm/mach-apollo3/mach-apollo3.c

//### x.1 MACHINE_START部分：
grep "#define MACHINE_START" -r ./kernel
./kernel/arch/arm/include/asm/mach/arch.h 中定义了MACHINE_START的宏
MACHINE_START(IMAPX15, "iMAPx15")
	.nr				= 0x8f9,
	.atag_offset    = 0x100,
	.smp			= smp_ops(apollo3_smp_ops),
	.init_early		= apollo3_init_early,
	.init_irq		= apollo3_init_irq,
	.map_io			= apollo3_map_io,
	.init_machine   = apollo3_machine_init,
	.init_time		= apollo3_init_time,
	.init_late		= apollo3_init_late,
	.restart		= apollo3_restart,
	.reserve		= apollo3_reserve,
MACHINE_END
//### x.2 apollo3_init_early
//### x.3 apollo3_init_irq)
//### x.4 apollo3_map_io
//### x.5 apollo3_machine_init
//### x.6 apollo3_init_time
void __init apollo3_init_time(void)
    imapx_clock_init();
        INIT_LIST_HEAD(&register_clk_head); //初始化clock的链表
        imapx_osc_clk_init(); //注册 "osc-clk"
        imapx_pll_clk_init(); //注册父为 osc-clk 的4个pll："apll", "dpll", "epll", "vpll"
        imapx_cpu_clk_init(); //注册父为"apll"的"gtm-clk" "cpu-clk" "apb_pclk"
        imapx_dev_clk_init();  //注册父为"osc-clk" "apll", "dpll", "epll", "vpll" 的 设备clock
        imapx_bus_clk_init(); //注册父为"bus1/3/4/6"的bus clk, 和父为"apb_output"的apb clk
        imapx_vitual_clk_init(); //vitual_clk 无有效内容
        imapx_init_infotm_conf();
        imapx_set_default_parent();

    module_power_on(SYSMGR_CMNTIMER_BASE);
    apollo3_gtimer_init(IO_ADDRESS(SCU_GLOBAL_TIMER), "timer-ca5");
    apollo3_cmn_timer_init(IO_ADDRESS(IMAP_TIMER_BASE),GIC_CMNT0_ID, "imap-cmn-timer");
    apollo3_twd_init();

//### x.7 apollo3_init_late
//### x.8 apollo3_restart
//### x.9 apollo3_reserve

uboot中设置pll
irf->set_pll ( PLL_D, 0x003f );                       // set DPLL to 1536M
irf->set_pll ( PLL_E, 0x2062 );                       // set EPLL to 1188M  --->594M
irf->module_set_clock ( BUS6_CLK_BASE, /*PLL_E*/PLL_D, /*5*/8);

host->biu_clk = clk_get_sys("sdmmc.1", "sdmmc1"); //bus clk , 链接到系统设备控制器，内部
host->ciu_clk = clk_get_sys("imap-mmc.1", "sd-mmc1"); //dev clk，外部，到设备。 SD1_CLK_SRC
两个时钟如何得到如何计算的？作用是什么

host->bus_hz = clk_get_rate(host->ciu_clk);
    外部时钟是ciu么
QUIRK 具体含义，会否对当前问题有影响
dw_mmc的最新代码，会否有更新？

BUS_FREQ_RANGE("apb_output",  300000, 100000); 两个值的单位是khz

时钟数组中，父子关系是固定的？还是动态可设定的？

mmc接口，分频是对应的bus 还是 dev clk

内部时钟设置为100M,然后2分频，会否有好点的表现？因为内部精度较高，可能能够比较好的处理。


卡读延迟 是什么，如何测试得到的。
平均相位差 什么玩意，有什么影响
或者是否有比较长的起始位，可以准确的同步呢？一次128k数据，有32byte的起始位也无所谓。
是否可以根据或者参考sd提供的delay数据进行设定。能否测试得到这个数据？
或者，如果读出现偏差，调整delayline设置，再次读写，从1开始，一直到正确为止。
数据传输开始之前先进行训练，或者出错之后调整。

```

## 4
mount -t vfat /dev/mmcblk0p1 /mnt
mmc_test write_speed -m /mnt -s 2 -n 1

mmc_test write_speed -m /mnt -s 512 -n 4
mmc_test read_speed -m /mnt -s 512 -n 4

## 设置mmc1的时钟
mount -t debugfs none  /sys/kernel/debug
cat /sys/kernel/debug/clk/clk_summary
echo sd-mmc1 >/sys/kernel/debug/clk/configure/name
cat /sys/kernel/debug/clk/configure/freq
echo 49500000 > /sys/kernel/debug/clk/configure/freq

echo sd-mmc1 >/sys/kernel/debug/clk/configure/name
echo 39600000 > /sys/kernel/debug/clk/configure/freq

echo sd-mmc1 >/sys/kernel/debug/clk/configure/name
echo 45700000 > /sys/kernel/debug/clk/configure/freq

## 设置delayline
echo 310101 > /sys/kernel/debug/mmc1/delayline
dd if=/dev/zero of=/dev/mmcblk0p1 bs=512 skip=262144 count=1

echo 410101 > /sys/kernel/debug/mmc1/delayline
dd if=/dev/zero of=/dev/mmcblk0p1 bs=512 skip=262144 count=1

dd if=/dev/mmcblk0p1 of=/dev/null bs=8096 skip=0 count=2000000
dd if=/dev/mmcblk0p1 of=/dev/null bs=512 skip=0 count=1
dd if=/dev/mmcblk0p1 of=/dev/null bs=512 skip=0 count=1
dd if=/dev/zero of=/dev/mmcblk0p1 bs=512 skip=262144 count=1
pc上测试，好像没有什么问题。应该增加time来计算实际速度。
dd if=/dev/zero of=/dev/sdb1 bs=512 skip=262144 count=1
## 设置自动sync的生效时间，方便测试
echo 30 > /proc/sys/vm/dirty_writeback_centisecs
echo 30 > /proc/sys/vm/dirty_expire_centisecs
dd if=/dev/zero of=/dev/mmcblk0p1 bs=512 skip=262144 count=1

dw_mci_slowdown_bus(struct dw_mci_slot *slot)

## 测试结果
1.设置40Mhz，目标卡读写都没有问题
2.设置50Mhz，目标卡读正常，写任何扇区都会出现0x8008数据错误。
3.设置50Mhz，测试其他多张tf卡，都可以正常读写
4.设置50Mhz，调整写delayline从0逐步递增到0x80，仍然报错，应该不是delayline的问题
5.pc上用目标卡制作启动卡时，明显比其他class10的tf卡慢40-60%左右，猜测可能pc降频访问tf卡

## 初步结论：
根本原因应该是目标tf卡无法在50Mhz时钟下正常写入，这是一张故障卡。

## 应对方法：
1. 客户可以将mmc1控制器时钟设置为40M
2. 读写失败时，mmc1驱动自动使用2分频降频

开始分析mmc和block驱动相关处理。
比较制作启动卡的时间，21/24秒 。40MHZ，没有发现问题。50MHZ，部分区域写入出错，读取没哟测试。    调整delayline,读写都没有改善。50MHZ，其他sd卡没有这个问题
## 测试验证一下，时钟对于读写速度上限的影响。40mhz应该是足够了吧？50mhz能够提升性能么？
在tasklet中设置时钟频率，是否安全？

mmc_host mmc0: Bus speed (slot 0) = 49500000Hz (slot req 49500000Hz, actual 24750000HZ div = 1)
mmc_test write_speed -m /mnt -s 512 -n 4
test:0 Write 2048m in 280.854004s, 7.292045mbyte/s!
Average:Write 2048m in 280.854004s,7.292045mbyte/s!

mmc_test read_speed  -m /mnt -s 512 -n 4
test:0 Read 2048m in 188.544998s, 10.862128mbyte/s!
Average:Read 2048m in 188.544998s,10.862128mbyte/s!

mmc_host mmc0: Bus speed (slot 0) = 39600000Hz (slot req 39600000Hz, actual 39600000Hz div = 0)
mmc_test read_speed -m /mnt -s 512 -n 4
Average:Read 2048m in 125.846001s,16.273859mbyte/s!

mmc_test write_speed -m /mnt -s 512 -n 4
Average:Write 2048m in 225.156998s,9.095876mbyte/s!

mmc_host mmc0: Bus speed (slot 0) = 49500000Hz (slot req 49500000Hz, actual 49500000Hz div = 0)
mmc_test read_speed -m /mnt -s 512 -n 4
Average:Read 2048m in 103.801003s,19.730061mbyte/s!

## 数据重传打印：
mmcblk0: error -110 sending stop command, original cmd response 0x900, card status 0x900

## 纠错显示：
[    8.359999] data error: 0x8008
[    8.363333] mmcblk0: error -110 sending stop command, original cmd response 0x900, card status 0xe00
[    8.376666] total 1 data error, recovered...


trace_: 如何打开
trace_mmc_blk_rw_end
pr_debug


host->ciu_clk = clk_get_sys("imap-mmc.1", "sd-mmc1");
ret = clk_prepare_enable(host->ciu_clk);
host->bus_hz = clk_get_rate(host->ciu_clk);

## 跟踪mmc_wait_for_req_done()

mmc_blk_issue_rw_rq() 函数中，调用 mmc_start_req()，返回状态MMC_BLK_RETRY的话，重传数据，最多5次。

增加一个重传标记，在dw_mci_start_command 函数中判断并且重新设置时钟，这样估计比较安全。

怎么在烧录卡中保留debugfs支持？查

有几种int错误，没有被处理，是不会发生，还是没有影响，还是存在缺陷，是否需要增加判断和打印？
增加一个宏，打印信息。

mount -t vfat /dev/mmcblk0p1 /mnt
mmc_test write_speed -m /mnt -s 1 -n 1


host->save_bus_hz = host->bus_hz;

static inline void dw_mci_resume_bus_hz(struct dw_mci *host)
static inline void dw_mci_adjust_bus_hz(struct dw_mci *host)

rm -fr /mnt/rw*
sync
mmc_test write_speed -m /mnt -s 512 -n 4

http://gerrit.in.infotm.com/14675
RM#6043 adjust down mmc-ciu clock when mmc report data error and first retransmition failed.

RM#NONE Adjust audiobox source according to coding standard

增加新的规避机制来处理data error问题:
修改mmc驱动，每次出现data error不结束数据传送而是触发上层重传，第一次以原ciu clock时钟重传，第二次及之后每次重传会先将mmc ciu clock降低10MHZ。如果clock低于20MHZ仍然重传失败，向上层报告错误结束数据传输出错处理。
拔出卡时ciu clock会恢复原始时钟，所以不会插入故障卡降频之后，插入新卡也工作于低频的情况。
客户寄来的瑕疵卡，出现data error之后第一次重传就成功，所以无需执行降频操作，之后能稳定工作在50MHZ.

错误恢复trace如下:
[    5.746666] mmcblk0: error -110 sending stop command, original cmd response 0x900, card status 0xe00
[    5.759999] total 1 data error, recovered...
降频恢复trace如下：
[    5.996666] mmcblk0: error -110 sending stop command, original cmd response 0x900, card status 0xe00
[    6.003333] clk_set_rate sd-mmc1 ,oldrate:49500000, new rate:39500000
[    6.006666] clk_set_rate ok 39500000
[    6.009999] adjust mmc bus, saved ciu clk:49500000, cur ciu clk:39600000
[    6.019999] total 1 data error, recovered...
拔卡恢复时钟trace:
[   23.329999] mmc0: card 0001 removed
[   23.383333] clk_set_rate sd-mmc1 ,oldrate:39600000, new rate:49500000
[   23.389999] clk_set_rate ok 49500000
[   23.393333] resume mmc bus, saved ciu clk:49500000 cur ciu clk:49500000


## 5
### 5.1

## 6
