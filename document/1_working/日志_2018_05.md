# 工作日志

### 修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2017/09/25 | 员清观 | 常用操作索引，尽量简短方便使用 |

## misc
cat /proc/pagetypeinfo cat /proc/vmallocinfo

`nautilus` 可以用来从终端启动文件管理器并切换到当前文件夹

## 当前任务备忘
audiobox_v2文档(不替换原有的文档，或者可以考虑增加一个新章节描述)；motor文档(路径：内部资料，经验分享，内核及驱动)
audiobox增加参数输入，是否开始录音以及定义设备参数和录音缓冲时间
去掉kernel中音频流增加时间戳的操作
abctrl可以考虑增加接口，直接采集audiobox指定fr的信息，这样更加方便，功能强大。这需要有规律的fr命名方式。最好是函数调用得到这些名称
squashfs缺省设置应该改变，4k block，lzo压缩方式
完善audiobox的trace机制，提高覆盖率
getchannel的时候申请一个buffer,putchannel的时候释放，这样，可以直接废弃audio_get_frame、audio_read_frame，这套函数有问题，因为中间很可能会夹杂写文件到sd卡或者网络等操作，有可能导致卡顿，导致xrun
通过alsa或者conf或者item获取当前dev对应的codec，判断非ip6205则不调用route函数 :: /proc/asound/card0/id　这个是否可以呢？
如果在内核中缺省加载dsp，应用通过ioctrl加载firmware，可以节省15ms加载模块时间。延伸开来，普通的模块，实际上开销包括两个部分，加载驱动时间，和驱动初始化时间
audio时钟重新匹配，以支持44100hz的音频
fr的get然后put，实际最好在内核中一次完成，应用层给一个有效buffer就好，数据的拷贝在内核中，一次系统调用就可以完成，节省了上下文的开销。videobox中是否有需要强制占用fr的场景呢？
只有audiobox使用的so，应该静态编译，节省加载时间： libfdk-aac.so libspeexdsp.so libdsp.so libcodecs.so libunitrace.so alsa-lib ，并从rootfs中去掉
audiobox, 去掉speexdsp的可能存在的范例程序；增加一个patch,用来去掉so的编译；后否因为ogg而变得太大呢？
audiobox，能否不加载用得少的codec呢？apu_codec可以考虑在另外的进程中实现，动态加载；speexdsp也可以考虑如此实现；或者，部分必须的功能在内核中实现
audiobox增加命令行功能：直接设定frmask，之后创建的所有通道，为所有使能的fr创建单独的线程，线程参数为音频格式，自动录音。

BR2_PACKAGE_ALSA_LIB_PCM_PLUGINS="all" BR2_PACKAGE_ALSA_LIB_CTL_PLUGINS="all" 这两个是可以裁剪的功能。可以减小alsalib的大小

修改item处理，增加LLI模式，所有平台。
audiobox创建通道失败之后，终止

audiobox，增加消息自定义录音devfr的大小
增加帧率判断，dsp处理能力是有限制的
MMC_TEST，-m参数，应该在help中提供


增加-o参数，指定trace信息路径

## 12-31结束
**12-29**<br>
devfr的类型应该改变; 播放时devfr的大小应该可配置，audiobox命令行参数；播放时channel的参数可以配置。
下一步，pcm通道的参数，应该可以支持更多的buffer个数，更长的period，以保护音频数据流。
**12-28**<br>
现在有能力调整buffer的打消了，dma最大8个，alsa的不受限制
**12-27**<br>
新的控制信息，全部放在struct imapx_runtime_data中，这样，可以保证每个codec一个；或者，只有使能了aec的通道，才有必要使用新的机制。
暂时，把通道映射写入aecv的控制文件中，以后再确定如何调整audiobox代码。
设备aec功能配置，直接使能dma的处理
**12-26**<br>

**12-25**<br>

**12-24**<br>
i2c_2 i2c_3连接到GPIO排线
i2c_0 U9 AXP202 电源管理芯片 地址 0x34
			U11 RTC模块  地址 0x51
i2c_1 codec
**12-18**<br>
调试es8323，启动过程中需要插入延时；去掉aecv2代码中的spin_lock
**12-17**<br>
整理和上传timestamp版本代码；aecv1代码增加ip620x的判断
**12-13**<br>
下一步优化：
１．使用alsa的时间戳代替原有的内核层时间戳/audiobox层时间戳
	这样做除了逻辑更加合理，一个主要原因是i2s配置为16位宽时，原有的时间戳会破坏音频数据
２．audiobox根据sampling_rate，限制sample_size不得小于40ms帧
	过小的sampel_size导致高帧率，更容易导致上层来不及取数据出现xrun，并且开启aec功能时可能会超出dsp处理能力
```cpp
snd_pcm_sw_params_set_tstamp_mode(dev->handle, softwareParams, 1);

extern struct timespec snd_pcm_hw_fast_tstamp(snd_pcm_t *pcm);
struct timespec cur_timestamp;
cur_timestamp = snd_pcm_hw_fast_tstamp(dev->handle);
int tesmp = cur_timestamp.tv_sec*1000 + (cur_timestamp.tv_nsec/1000000);
if(tesmp != dev_buf.timestamp)
printf("timestamp: %lld  timestamp: %d, %d \n"
	, dev_buf.timestamp
	, (int)cur_timestamp.tv_sec, (int)(cur_timestamp.tv_nsec/1000000));
	,
```
**12-12**<br>
#define	SNDRV_CTL_ELEM_IFACE_CARD	((__force snd_ctl_elem_iface_t) 0) /* global control */　可能更适合用作aec使能控制，比system命令开销小。

ip6205左右声道交换
启动aec:
[   39.153333] ~~~~~~1 VALUE: reg 0xe2(0xc13f00c3-->0xc13f00c2)
[   39.159999] ~~~~~~1 VALUE: reg 0xe2(0xc13f00c2-->0xc13f00c0)
[   39.169999] ~~~~~~1 VALUE: reg 0xe2(0xc13f00c0-->0xc13f0080)
[   39.176666] ~~~~~~1 VALUE: reg 0xe2(0xc13f0080-->0xc13f0000)
[   39.186666] ~~~~~~1 VALUE: reg 0xe2(0xc13f0000-->0xc13f0010)
[   39.193333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0010-->0xc13f0030)
[   39.203333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0030-->0xc13f0130)
关闭aec:
[   50.073333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0131-->0xc13f0133)
[   50.083333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0133-->0xc13f0173)
[   50.093333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0173-->0xc13f01f3)
[   50.103333] ~~~~~~1 VALUE: reg 0xe2(0xc13f01f3-->0xc13f01e3)
[   50.113333] ~~~~~~1 VALUE: reg 0xe2(0xc13f01e3-->0xc13f01c3)
[   50.123333] ~~~~~~1 VALUE: reg 0xe2(0xc13f01c3-->0xc13f00c3)


**12-11**<br>
调试#7168;
frname 定制，调整audiobox代码，在dma模块限制sample_size为40ms
**12-10**<br>

**12-07**<br>
调试并上传speexdsp，完整测试了各种算法和aecvx组合下回声消除功能

准备编写audiobox文档:
1. 场景: 增加audio_set_format audio_get_format场景/ audio_enhance_mode /
2. audio_get_channel_ex 支持逻辑通道参数和物理通道参数不同。

**12-06**<br>
static int default_aec_version = AEC_DEFAULT_VERSION;
调试speexdsp
**12-05**<br>
hlibvcp7g代码合并到audiobox，vcp7g和speex代码统一定义；整理上传audiobox trace的更正
**12-04**<br>
修正i2s和ip6205中16位宽的bug
**12-03**<br>
fr1023使用的是外部会环，所以aecv1录音dma_size=2不会问题
dma_size=2, 16bits录音慢播放慢，录音的时候感觉像是被扔掉了一半数据一样。
## 12-03->...
**11-30**<br>
speexdsp.c　alangodsp.c保存统一定义的函数接口，通过宏控制是否编译；　apu_aec.c 中增加统一的aec函数接口，通过宏控制speexdsp和alango的选择。
第一步，拆分vcp7g_dsp.c文件，然后再集成speexdsp的接口进来。
**11-29**<br>
请假
**11-28**<br>
mempool的使用
```cpp
#include <linux/mempool.h>
mempool_t* float_mempool;
static inline mempool_t *mempool_create_kmalloc_pool(int min_nr, size_t size)
bio_split_pool = mempool_create_kmalloc_pool(BIO_SPLIT_ENTRIES, sizeof(struct bio_pair));
struct bio_pair *bp = mempool_alloc(bio_split_pool, GFP_NOIO);
void * mempool_alloc(mempool_t *pool, gfp_t gfp_mask)
void mempool_free(void *element, mempool_t *pool)
```

**11-27**<br>
应该在unitrace的configure.ac文件中，根据`BR2_PACKAGE_HLIBUNITRACE`是否set来增加ENABLE_UNI_TRACE的宏定义。unitrace的模块是一定会被编译的，但是其他模块是否编译进去，应该由config选项`BR2_PACKAGE_HLIBUNITRACE`来确定。HLIBUNITRACE_POST_INSTALL_STAGING_HEADERS宏中增加 `-rm $(AUDIOBOX_BUILDDIR)/.stamp_built` `-rm $(TESTING_BUILDDIR)/.stamp_built`，可以自动触发make时重新编译audiobox和testing模块。

audiobox_trace.h
abctrl.h

**11-26**<br>

dsp加载firmware，从firmware_class.c中无法看出如何确定搜索firmware所在目录，然后更改output/system中目录为dsp2/firmware，仍然出错：modprobe: can't load module ceva-dsp (kernel/drivers/infotm/q3f/char/dsp/ceva-dsp.ko): Operation not permitted；怀疑和模块所在目录有关，于是更改模块代码目录为dsp2，仍然出错：can't load module ceva-dsp (kernel/drivers/infotm/q3f/char/dsp2/ceva-dsp.ko)。跟踪firmware_class，已经知道和CONFIG_FW_LOADER_USER_HELPER有关，而且有uevent产生，所以，查看product目录mdev.conf，发现`cevadsp-tl421	0:0 666 @/etc/mdev/dsp_load_fw`，打开dsp_load_fw文件，修改其中的dsp为dsp2，ok. driver目录回归dsp，仍然ok. 所以，应该是Mdev和system目录需要保持一致。

printk(KERN_EMERG "~~~(%s, %d)~~~\n", __func__, __LINE__);
tl421_fw_cb 函数中，应该可以减少一次拷贝的动作。估计可以减少10ms级别的加载时间。
int kernel_read(struct file *file, loff_t offset,	char *addr, unsigned long count) 函数，关注一下。


**11-23**<br>
q3f开发板上的aecv1和aecv2还需要修改声道填充。

audiobox增加新的函数，扩展dev级别的配置，调试和控制
```cpp
int audio_preprocess_ctl(const char *dev, enum new_audio_command requst, void *para, int len)
{
	int cmd = AB_SET_DEV_VOLUME;
	char rpcname[64];
	char devname[64];
	int result = 0;
	int ret;

	if (!dev) {
		return -1;
	}

	memset(devname, 0, 64);
	sprintf(devname, "%s", dev);
	audio_get_rpcname_by_dev(rpcname, devname);
	AB_EVENT(sc, &cmd, devname, para, &result);
	ret = audiobox_rpc_call_scatter(rpcname, sc,
			AB_EVENT_SIZE(sc));
	if (ret < 0) {
		return -1;
	}

	return *(int *)AB_GET_RESULT(sc);
}
```
**11-22**<br>
集成之前aecv2的代码，尝试ceva-dsp对功能定义宏的依赖。
**11-21**<br>
提交float fr修正：
fix(kernel/fr): fix float fr crash problem when SMP is enabled

when struct fr_buf(storing frame management information) of floating fr reside in CMA, a crash will happen; else if moving it to cacheable memory, it work well. This should be related with cache line coherence of SMP.

change: get struct fr_buf out of CMA memory,  alloc/free it dynamically with kzalloc()/kfree(), and restrict maxinum frame number of floating fr to 160.

Close 6127

**11-20**<br>
float fr, SMP无法正常工作的问题。重现，并且重新设计测试脚本。

RM#6127, setproduct.sh选择Gix15, none, default.

vbctrl stop
mkdir /mnt/sd0
mount -t vfat /dev/mmcblk0p1 /mnt/sd0/
cd /mnt/sd0/
videoboxd /mnt/sd0/player_320_g1.json
./vplayer 320_264_15fps_1track.mkv
new
play 1

json文件需要修改，可以改成：
{
    "dec0":{
        "ipu":"g1264",
        "port":{
            "frame":{
                "w": 320,
                "h": 240
            }
        }
    }
}
或者
{
    "dec0":{
        "ipu":"g1264",
        "port":{
            "frame":{
                "w": 320,
                "h": 240,
                "bind":{"filesink":"in"}
            }
        }
    },

    "filesink": { "ipu": "filesink", "args": { "data_path":"/mnt/sd0/h264Test.h264" }}
}

## 11-05->...
**11-19**<br>
跟踪make的全过程，分析output/root产生规则，邮件回答客户问题：
```cpp
跟踪分析了make的全过程，问题已经确认。

先参考典型的烧录脚本burn.ixl内容，我们将基于此burn.ixl脚本制作烧录卡：
    #images:
    i run 0x08000200 0x08000000 ../../output/images/uboot0.isi
    r flash 0x0  ../../output/images/uboot0.isi
    r flash 0x1  ../../output/images/items.itm
    r flash 0x2  ../../output/images/ramdisk.img
    r flash 0x3  ../../output/images/uImage
    r flash 0x5  ../../output/images/rootfs.squashfs

其中，rootfs.squashfs基于output/system生成，它包含完整的最终商用的rootfs；ramdisk.img基于output/root生成，它只包含烧录相关的内容如busybox、mkfs utilities、upgrade程序以及所有的依赖库。故而，后者大小远小于前者。从烧录卡启动时，内核加载ramdisk.img对应的根文件系统，执行其upgrade程序完成烧录uImage和rootfs.squashfs，然后拔出烧录卡，重启，完成烧录过程。

output/root和output/system生成的根文件系统都是只读的，如果需要产生一个可读写的文件系统，应该通过配置items.itm实现。例如，"part7 config.512.fs.jffs2"将会增加一个新的512k大小的jffs2分区，具体操作请参考items文档。

如果需要配置最终rootfs采用squashfs文件系统，首先通过"make menuconfig"，开启"Filesystem images"-->"squashfs target filesystem"，这样make的时候就会在output/images目录产生rootfs.squashfs；并确认burn.ixl文件中配置了"r flash 0x5  ../../output/images/rootfs.squashfs"，然后制作烧录卡即可。
```

记录一下，金总要的epkg文件生成工具: ~/work/working_folder/gen_epkg.tar
编译:  gcc -o gen_epkg epkg_generator.c;
执行下面命令,产生efuse_cfg_03520110_28e2979a9250_500000.epkg文件 ：./gen_epkg 03520110 28e2979a9250 500000
产生的epkg与之前收到的范例文件内容完全相同

iuw64 的源代码在哪里，毛用

**11-16**<br>
计划开展kernel warning的清理工作，现将目前kernel编译中的warning整理了出来，请见附件表格，其中包含gerrit上编译的4个产品，以及x15和x9的2个产品，共6个产品编译过程中的kernel warning信息。首先从q3fevb_va这个产品开始清理，任务分配如下，后续其他产品的清理工作的分配相同。请根据各自的任务分配情况，将表格中的对应warning处理掉：
- Eric: Kconfig, arch, audio, mmc, DMA, fs
- Can: clock, spi, net, regulator, otg, uvc, env
- Wanhu: display, adc, item, gpio, pwm, rtc, other

**11-15**<br>
lds格式；尝试fft乘法除法优化，但发现是float格式，了解之后发现无法完成; 确认sin/cos的优化已经内置了。
**11-14**<br>
2的幂fft变换速度快点。
**11-13**<br>
fftw3f是由fftw模块生成的，需要在package的fftw.mk文件中添加 `FFTW_CONF_OPT += --enable-float`
两种方法测试故事机aec功能：1. 采集故事机capture和record文件，pc上或者q3f板上解析并对比效果。2. 移植speexdsp到故事机。
**11-12**<br>
160fft效果测试，采样点的分组。
**11-11**<br>
review linux启动流程，文档化
**11-09**<br>
考虑进一步提升性能： 1. 移植到sram 2.DISABLE_FLOAT_API
**11-08**<br>
请假
**11-07**<br>
测试speex各种场景下资源开销，并尝试消噪等参数，无效
**11-06**<br>
集成speex到qsdk，定点的开销只有float的一半，然后尝试确认float相关移植
**11-05**<br>
整理回声消除文档，<br>和-后数字的格式问题，导致平台无法预览文档。

## 10-22->...

**10-30**<br>
**10-30**<br>
能否先用固定的参数消除回声，2s完全收敛之后，再切换到新的匹配参数。这样需要修改算法。或者，打开speex之后再不关闭，这样是否就会总是使用之前已经同步好的参数呢？dsp会否也是如此？dsp会耗电，不知道是否适合。可以尝试使用speex程序一次处理多个文件，第一个文件收敛好之后，会否剩余的文件就不需要再收敛了。
speex算法听起来效果和dsp的差不多。可以使用大的采样帧，虽然收敛时间长了，但一次收敛，永远收益
**10-29**<br>
测试脚本，分别测试单向通话和双向通话的场景。优化了7个音频测试文件，全部16bit, 1声道, 8000采样率，并保持振幅相差不大。
```shell
//#!/bin/sh

recorddir=/mnt/sd0/result/
mkdir $recorddir
counter=0

for musicfile in `ls /mnt/sd0/test?.wav`
do
abctrl play -w 16 -r 8000 -s 8000 -n 1 -d $musicfile -v 100 -y 0 -z 8 &
sleep 1
abctrl record --enable-aec -w 16 -s 8000 -n 1 -t 5 -o ${recorddir}"test"${counter}"_dsp".wav
counter=$(($counter+1))
sync
killall abctrl
sleep 1
done
```

## 10-22->...
**10-27**<br>
audiobox自动测试
为了优化aec测试过程中声音文件的时间同步问题处理，尽量减少测试中大量的手工操作和主观评估，尝试引入自动测试过程：
１．sudo minicom，启动EVB板，确认进入命令行
２．断开minicom链接(ctrl+a, 然后按q键)
３．PC执行脚本开始测试：PC开始播放音源，然后通过执行minicom脚本发送放音和录音命令到EVB板.(测试开始之前应该先启动加载totem进程，以减少PC播放延迟)
totem ./tools/origion.wav &
sudo minicom -S ./aectest.run
附aectest.run脚本内容：
send "mount -t vfat /dev/mmcblk0p1 /mnt"
send "abctrl play -w 32 -s 16000 -n 2 -d /mnt/pcm_16khz_ch2_32b.wav &"
send "abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 20 -o /mnt/record.wav"
exit
４．20秒后录音结束，pesq比较record.wav和origion.wav.

**10-26**<br>
比较的因素：
- 收敛时间
- pesq 或者 RMS振幅
- 调整延时和比较内容部分
- 增加样本个数
- 调整比较时间，15s，60s各自选取几个不同的音源，是否需要
  - 调整音量大小？
  - 频谱？
  - 音乐和语音
  - speex的NN和TAIL应该可以作为参数传递进去看效果

webrtc和speex和dsp，采用相同的处理机制。统一使用采样率8000, 16bit, 单声道。

值得注意的两点：
- 1： 自适应滤波器收敛阶段，期望信号是完全的echo，不能混杂有speech。因为speech和fe是没有关系的，会扰乱W(n)的收敛过程。也就是说要求回声消除算法开始运转后收敛要非常快，最好对方还来不及说话，你一说就收敛好了；收敛好之后，如果对方开始说话，也就是有speech混合过来，这个W(n)系数就不要变化了，需要稳定下来。
- 2：回音路径可能是变化的，一旦出现变化，回声消除算法要能判断出来，因为自适应滤波器学习要重新开始，也就是W(n)需要一个新的收敛过程，以逼近新的回音路径函数F。
基本上来说，上面这两点是两难的，一个需要自适应滤波器收敛后保持系数稳定，以保证不受speech说话干扰，另一个需要自适应滤波器随时保持更新状态，以保证能够追踪变化的回音路径。这样一来，仅从数学算法层面，回声消除已经是难上加难！简单地说，回声消除自适应滤波器的设计具有两个互相矛盾的特性，也就是快速收敛和高度的稳定性，如何同时实现这两项特性，正是设计上的主要挑战。
从应用平台来看，根据笔者多年的经验，可以把回声消除分为两大类：基于DSP等实时平台的回声消除技术和基于Windows等非实时平台的回声消除技术。两者的技术难度和重点是不一样的。有些手机的声学设计是非常不合理的（严重的麦克风扬声器耦合，非线性失真，麦克风底噪等），会使得一些通用的音频算法（回声消除，降噪）无法正常工作
网上搜索回声消除算法对比测试结果时，一般都说speex效果很差。这估计和原始音频文件的质量有关，从Q3F采集到的音频，有下面几个有点：1.回声在1ms左右，延迟非常小；2.录音和放音信号同步极为精确；3.信号失真不大，也没有网络因素影响，尤其是前两者，网上测试一般都是基于网络的语音通讯，都不会满足。

**10-25**<br>
 要注意的是，传给speex回声消除器的两个声音信号，必须同步得非常的好，就是说，在B端，接收到A说的话以后，要把这些话音数据传给回声消除器做参考，然后再传给声卡，声卡再放出来，这有一段延时，这时，B再采集，然后传给回声消除器，与那个参考数据比较，从采集到的数据中把频域和参考数据相同的部分消除掉。如果传给消除器的两个信号同步得不好，即两个信号找不到频域相同的部分，就没有办法进行消除了。
SpeexEchoState *echo_state = speex_echo_state_init(frame_size, filter_length);
  frame_size是每次处理的数据大小。filter_length也称tail_length，自适应滤波器长度。推荐的长度大概的回声时延的3分之一.  遗留问题：filter_length还需要根据场景调整吗？
要求： 1. 收发必须严格同步。2. 收发时延尽量的小。3. filter_length并非越长越好。过长可能导致难以收敛，AEC不起作用。4. speex使用的是线性自适应滤波器，对于非线性失真引入的信号畸变抵抗力差，因此应该尽量避免saturation/clipping

当前简单测试，是否frame_size大些，filter_length小点比较好？这样的前提是，延时很小。后者，可以根据延时得出filter_length

**10-24**<br>
wav文件头部格式解析代码：
```cpp
 private byte[] getWaveFileHeader(int sampleRate, int channels, int bitsPerSample, int bytePerSecond, long fileLenIncludeHeader)
 {
    byte[] wavHeader = new byte[44];
    long totalDataLen = fileLenIncludeHeader - 8;
    long audioDataLen = totalDataLen - 36;

    //ckid：4字节 RIFF 标志，大写
    wavHeader[0] = 'R'; wavHeader[1] = 'I'; wavHeader[2] = 'F'; wavHeader[3] = 'F';

    //cksize：4字节文件长度，这个长度不包括"RIFF"标志(4字节)和文件长度本身所占字节(4字节),即该长度等于整个文件长度 - 8
    wavHeader[4] = (byte)(totalDataLen & 0xff); wavHeader[5] = (byte)((totalDataLen >> 8) & 0xff); wavHeader[6] = (byte)((totalDataLen >> 16) & 0xff); wavHeader[7] = (byte)((totalDataLen >> 24) & 0xff);

    //fcc type：4字节 "WAVE" 类型块标识, 大写
    wavHeader[8] = 'W'; wavHeader[9] = 'A'; wavHeader[10] = 'V'; wavHeader[11] = 'E';

    //ckid：4字节 表示"fmt" chunk的开始,此块中包括文件内部格式信息，小写, 最后一个字符是空格
    wavHeader[12] = 'f'; wavHeader[13] = 'm'; wavHeader[14] = 't'; wavHeader[15] = ' ';

    //cksize：4字节，文件内部格式信息数据的大小，过滤字节（一般为00000010H）
    wavHeader[16] = 0x10; wavHeader[17] = 0; wavHeader[18] = 0; wavHeader[19] = 0;

    //FormatTag：2字节，音频数据的编码方式，1：表示是PCM 编码
    wavHeader[20] = 1; wavHeader[21] = 0;

    //Channels：2字节，声道数，单声道为1，双声道为2
    wavHeader[22] = (byte) channels; wavHeader[23] = 0;

    //SamplesPerSec：4字节，采样率，如44100
    wavHeader[24] = (byte)(sampleRate & 0xff); wavHeader[25] = (byte)((sampleRate >> 8) & 0xff); wavHeader[26] = (byte)((sampleRate >> 16) & 0xff); wavHeader[27] = (byte)((sampleRate >> 24) & 0xff);

    //BytesPerSec：4字节，音频数据传送速率, 单位是字节。其值为采样率×每次采样大小。播放软件利用此值可以估计缓冲区的大小；
    wavHeader[28] = (byte)(bytePerSecond & 0xff); wavHeader[29] = (byte)((bytePerSecond >> 8) & 0xff); wavHeader[30] = (byte)((bytePerSecond >> 16) & 0xff); wavHeader[31] = (byte)((bytePerSecond >> 24) & 0xff);

    //BlockAlign：2字节，每次采样的大小 = 采样精度*声道数/8(单位是字节); 这也是字节对齐的最小单位, 譬如 16bit 立体声在这里的值是 4 字节
    wavHeader[32] = (byte)(bitsPerSample * channels / 8); wavHeader[33] = 0;

    //BitsPerSample：2字节，每个声道的采样精度; 譬如 16bit 在这里的值就是16。如果有多个声道，则每个声道的采样精度大小都一样的；
    wavHeader[34] = (byte) bitsPerSample; wavHeader[35] = 0;

    //ckid：4字节，数据标志符（data），表示 "data" chunk的开始。此块中包含音频数据，小写；
    wavHeader[36] = 'd'; wavHeader[37] = 'a'; wavHeader[38] = 't'; wavHeader[39] = 'a';

    //cksize：音频数据的长度，4字节，audioDataLen = totalDataLen - 36 = fileLenIncludeHeader - 44
    wavHeader[40] = (byte)(audioDataLen & 0xff); wavHeader[41] = (byte)((audioDataLen >> 8) & 0xff); wavHeader[42] = (byte)((audioDataLen >> 16) & 0xff); wavHeader[43] = (byte)((audioDataLen >> 24) & 0xff); return wavHeader;
}
```

**10-23**<br>
继续优化下面音源文件，声音品质到3.0以上：
  ./pesq +8000 origion.aiff ./single_transfer/single_gushiji.wav|grep "Prediction : PESQ_MOS"
      Prediction : PESQ_MOS = 2.293
指定文件长度

**10-22**<br>
abctrl播放音乐文件，应该先去掉头部管理信息，虽然影响不明显，但这的确是一个bug。
测试全部使用8000采样率，16bit，单通道的音频文件。录音音量应该控制在-20db左右？

应该改写pesq代码，增加参数，调整输入文件的偏移，增加对audition保存的pcm格式文件的支持。
  void load_src( long * Error_Flag, char ** Error_Type,SIGNAL_INFO * sinfo) 函数中， Nsamples = (file_size / 2) - header_size; 是否说明应该是16bit的数据流?
想要得到高分，需要使用16bit,两个音源文件应该长度相同，并完全同步。输入参数中，可以按照ms指定长度和delta值。并且将实际比较的文件格式化输出到另外两个文件中。



## 10-15->...
webrtc编译，shell等，smp环境spinlock同步机制
## 10-08->...
**10-14**<br>
**10-13**<br>
**10-12**<br>
**10-11**<br>
**10-10**<br>
开始webrtc的工作
Speex本身的去噪效果不好，而EVRC的不错，如果把EVRC的去噪模块拿到Speex里面使用。经证明是很不错的。
webrtc的开发环境建立比较麻烦;下载的代码是基于vc的,先在windows环境下尝试吧.
**10-09**<br>
对比测试新旧两个aecv2机制,旧机制表现不稳定,40%出现消除不干净;高压测试的时候,20%出现整段消除不掉;
**10-08**<br>
aec对比测试,应该保证环境相同,比如,声音软音量大小,speaker和mic的距离.
上午,一行aecv2判断错误导致浪费了4个小时调试解决问题; 下午,对比前后语音aec处理效果,新机制应该更加干净; 发现一个问题,好像启动之后第一次比较干净,之后就脏了.

## 09-25->...
**09-30**<br>
**09-29**<br>
abctrl unitest setlog -m audiobox -l ffff
**09-28**<br>
```cpp
for(( num=1; num<7; num++)) # method2
do
  echo "num=$num"
done

echo 10 12 |awk '{printf("%d\n", $1+$2)}'
echo | awk '{printf("%s\n", $HOME)}'

//读取文件行并处理
while read line
do
  echo $line
done < filename

cat filename | while read line
do
  echo $line
done

```
**09-27**<br>
10次计算时间的操作，占用6%资源；这不仅仅是资源占用的问题，还会影响到其他tasklet
dma搬运的数据，应该直接在驱动中拷贝到fr中，而不是经过alsa的周转。增加了延时的不确定性，也增加了audiobox卡顿造成的风险。
kernel中aec功能，应该通过命令和参数来控制，而不是通过宏来定义吧。
使能aec功能时，是否应该在dma阶段就直接拆分成两个独立的声道，方便以后处理
提高aec处理效果：
1. 回声和参考音音量大小应该差不多，是否应该用软音量调节参考音的大小
2. 如果播放数据延迟，是否可以自填充一些；或者增加判断，xrun发生时aec参考声道填充0；连续两个capture中断而没有playback中断时，根据playback的dma位置来判断
**09-26**<br>
软音量的设置应该允许最大值超过100，有些原始很小的声音，应该软件放大。
去掉dsp的tone的方法：
1. 增加下面函数来重置dsp，去除tone，需要大概10ms恢复，注意需要关注是否会影响到50ms超时的判断，可以考虑重启timer；但是重启之后需要1s左右的建模时间，所以，估计需要提前缓冲1s的音频数据
2. tone的数据是否固定的？可能只需要6个点就可以完全确定正弦波，处理结果扔掉重新发送packet给dsp处理；定义一个pattern数组
3. 是否可以总结过滤的规则，每固定3s时间，或者每多少个packet
4. 可以考虑综合上面两个方法，快到3s的时候，开始检测数据

```cpp
static int tl421_aec_reset_dsp(unsigned long arg)
{
	int err = 0, val;
	void __iomem *base = tl421->ipc.base;
	int mode = AEC_LOW_PROFILE_MODE;

	tl421_module_poweroff();
	tl421_module_poweron();

	writel(0, base + IPC_MCU_MASK0);
	val = readl(base + IPC_SEM0S);
	writel((val & ~(AEC_MODE_MASK)) | (mode << AEC_MODE_BIT), base + IPC_SEM0S);
	writel(0, base + IPC_COM0);
	writel(0, base + IPC_REP0);
	writel(0, base + IPC_REP1);
	writel(0, base + IPC_REP2);

	tl421_ext_wait(0);
	err = tl421_aec_wait_initiate_complete();
	if(err < 0) {
		err = -EIO;
		goto init_fail;
	}

	writel((1 << AEC_DONE_BIT), base + IPC_MCU_MASK0);
	return 0;

init_fail:
	tl421_module_poweroff();

	return err;
}
static long ceva_dsp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
      if (aec_counter > 0x7ff) {
				aec_counter = 0;
				printk(KERN_EMERG "~~~~~~~reset tl421_module_poweron() \n");
				tl421_aec_reset_dsp(arg);
			}
```
**09-25**<br>
小马的几个建议：
应该去掉所有的 AUD_DBG 信息
void *thread_audio_playback_server(void *arg)
  if (fd < 0) {
		return NULL; //最好不要直接返回
	}
int vcp7g_dsp_capture_process(struct vcp_object *vcp_obj, char * in, char * out, int len) {
  //需要区分aecv1和v2
  //#if 1
			*(spk+i) = *(in_resample_buf+(i*4)) | *(in_resample_buf+(i*4)+1)<<8;
			*(mic+i) = *(in_resample_buf+(i*4)+2) | *(in_resample_buf+(i*4)+3)<<8;
  //#else
  			*(mic+i) = *(in_resample_buf+(i*4)) | *(in_resample_buf+(i*4)+1)<<8;
  			*(spk+i) = *(in_resample_buf+(i*4)+2) | *(in_resample_buf+(i*4)+3)<<8;
  //#endif
void aecv2_fill_left_chan(struct snd_pcm_substream *capture)
  最好和aecv1统一填充右声道

## 09-17->...
**09-23**<br>
```cpp
//Examples
/* step 1: open moto device */
int moto_fd = open("/dev/moto_dev", O_RDWR);

/* step 2: optional, set moto speed at percent ratio, (10 ~ 100)*/
int freq = 100;
ioctl(moto_fd, MOTO_SET_FREQ, &freq);

t_moto_command command;
/* step 3: whirl up 180° then stop*/
command.action = MOTO_CMD_UP;
command.steps = 256;
ioctl(moto_fd, MOTO_ACTION, &command);

/* step 4: whirl up, but we could stop it manually 1s later*/
command.action = MOTO_CMD_UP;
command.steps = 5120;
ioctl(moto_fd, MOTO_ACTION, &command);
sleep(1);
command.action = MOTO_CMD_STOP;
ioctl(moto_fd, MOTO_ACTION, &command);

```

enum MOTO_CMD_ID {
	MOTO_CMD_NOP = 0,
	MOTO_CMD_STOP,
	MOTO_CMD_UP,
	MOTO_CMD_DOWN,
	MOTO_CMD_LEFT,
	MOTO_CMD_RIGHT,
	MOTO_CMD_LEFTUP,
	MOTO_CMD_LEFTDOWN,
	MOTO_CMD_RIGHTUP,
	MOTO_CMD_RIGHTDOWN,
};

int ioctl(int handle, int cmd, int *argdx);
- handle : moto device handler
- cmd :
  - MOTO_SET_FREQ : moto speed
  - MOTO_ACTION : moto commmand, listed in enum MOTO_CMD_ID.
- argdx : command parameter


**09-22**<br>
**09-21**<br>
inline int motor_checkend(int index)
  //always return 0;
**09-20**<br>
待修改驱动：
  void motor_set(unsigned char value) GPIO控制线变更
  int motor_checkend(int index) //读取gpio1_virtul_addr gpio0_virtul_addr，通过gpio电平判断是否已经转动到了极限

static tMotorActDecom motorActionDecomTable[] =
{
	{PTZ_OPT_NULL, 		STOP,		STOP},
	{PTZ_OPT_UP,		KEEP,		BACKWARD},
	{PTZ_OPT_DOWN,		KEEP,		FORWARD},
	{PTZ_OPT_LEFT,		BACKWARD,	KEEP},
	{PTZ_OPT_RIGHT,		FORWARD,	KEEP},
	{PTZ_OPT_LEFTUP, 	BACKWARD, 	BACKWARD},
	{PTZ_OPT_LEFTDOWN, 	BACKWARD, 	FORWARD},
	{PTZ_OPT_RIGHTUP,	FORWARD, 	BACKWARD},
	{PTZ_OPT_RIGHTDOWN, FORWARD, 	FORWARD},
	{PTZ_OPT_AUTO,		STOP, 		STOP},
	{PTZ_OPT_FOCUSFAR,  STOP, 		STOP},
	{PTZ_OPT_FOCUSNEAR, STOP, 		STOP},
	{PTZ_OPT_IRISOPEN, 	STOP, 		STOP},
	{PTZ_OPT_IRISCLOSE, STOP, 		STOP},
	{PTZ_OPT_ZOOMIN, 	STOP, 		STOP},
	{PTZ_OPT_ZOOMOUT,	STOP, 		STOP},
	{PTZ_OPT_POINTPRESET, STOP, 	STOP},
	{PTZ_OPT_POINTRECALL, STOP, 	STOP},
	{PTZ_OPT_POINTCLEAR,  STOP, 	STOP},
	{PTZ_OPT_MENUSHOW, 	  STOP, 	STOP},
	{PTZ_OPT_HNAVIGATE,   RUNNING, 	KEEP},
	{PTZ_OPT_VNAVIGATE,   KEEP, 	RUNNING},
	{PTZ_OPT_STOP, 		  STOP, 	STOP}
};

```cpp
void  bcm6212_gpio_init()
    error = gpio_request(bt_reset, "bcm6212");
    gpio_direction_output(bt_reset, 0);
    msleep(100);
    gpio_set_value(bt_reset, 1);
    msleep(200);
```

QEN_MotorP 使能电压  GPIO52


调试马达的环境：  分支qipc_qiwo_x30_dev setproduct 0   d318 0   960P.json 2   gc2385mipi
  repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b qipc_qiwo_x30_dev

1.下载好最新分支后进入buildroot，执行
git reset --hard 542d9a7a429b2da9ecc2c58b5c9647708a914e9a
因为这分代码的环境是ubuntu18.04，要在较早的ubuntu版本上编译需要回退部分代码。

2.仍然在buildroot目录下修改Config.in
git diff package/Config.in
diff --git a/package/Config.in b/package/Config.in
index 4e216e04..3b575dca 100644
--- a/package/Config.in
+++ b/package/Config.in
@@ -748,7 +748,6 @@ source "buildroot/package/enchant/Config.in"
 source "buildroot/package/icu/Config.in"
 source "buildroot/package/libedit/Config.in"
 source "buildroot/package/libfribidi/Config.in"
-source "buildroot/package/libiconv/Config.in"
 source "buildroot/package/linenoise/Config.in"
 source "buildroot/package/ncurses/Config.in"
 source "buildroot/package/newt/Config.in"
并删除 package/libiconv/Config.in和package/libiconv/libiconv.mk
以上部分是因为在回退代码前做裁剪时裁掉了，我怕影响到分区，所以也去掉了。
3.如果编译完做启动卡，还要修改下gendisk.sh权限，服务器上的这个脚本没有执行权限

ps：我用启动卡启动或者烧录时都遇到有时不识别内核的情况，重新上电试试，或者在不识别内核时敲biu，然后执行res重启


int imapx_asoc_platform_probe(struct device *dev) 函数应该增加一个参数， int aecv2_enable，表示这个设备aec功能被使能
//设置某个参数
static int aecv2_delay_open(struct inode *inode, struct file *file)
{
	return 0;
}
static ssize_t aecv2_delay_read(struct file *file, const char __user *buffer, size_t count, loff_t *data)
{
	printk(KERN_EMERG "preset_offset: 0x%x\n", preset_offset);
	return 0;
}

static ssize_t aecv2_delay_write(struct file *file, const char __user *buffer, size_t count, loff_t *data)
{
	char delay[8];
	if (copy_from_user(&delay, buffer, 4)) {
		return -1;
	}
	delay[5] = 0;
	preset_offset = simple_strtol(delay, NULL, 10);
	printk(KERN_EMERG "preset_offset: %d\n", preset_offset);
	return 4;
}

static struct file_operations aecv2_delay_fops = {
  .open = aecv2_delay_open,
  .read = aecv2_delay_read,
  .write  = aecv2_delay_write,
};

static int __init aec_delay_init(void)
{
	proc_create("aec_delay", 0, NULL, &aecv2_delay_fops);
  	return 0;
}
__initcall(aec_delay_init);

**09-19**<br>

**09-18**<br>
调整代码实现，发现还是有playback数据被破坏的情况，导致回声消除效果不佳。
配合当前的Playbuffer使用； playback的pos正常处理，capture延迟填充，可以增加一个判断，如果当前capture_pos加上offset,调整值到正常范围后，小于playback的pos,就代表需要继续等待

或者，capture和playback都延迟一个period上报。
**09-17**<br>
调试aec2.0代码
## 09-10->...
**09-16**<br>
makefile.am configure.in automake机制的复习
**09-15**<br>
思考aec功能的基本机制，确定两个buffer的偏移计算方式
**09-14**<br>
aec实现改进的考虑，应该可以把dma操作分成两步骤，第二步要达到录音比放音中断晚固定的采样点个数，可以定制插入一个slave_dma的请求；这个请求可以在某个录音或者放音的中断中提出；同时，还需要考虑到，当前tasklet可能带来ms级别的误差

调用 int pl330_dma_getposition(struct dma_chan *chan, dma_addr_t *src, dma_addr_t *dst) 函数，读取capture和playback两个通道的当前指针和当前dma_pos，从而准确确定两者的相对偏移时间。

在 capture的 imapx_audio_buffdone() 函数中，判断，如果状态从单通变为双通，那么判断偏移时间；之后每个capture中断中，根据偏移填充capture数据；务必保证两者的buffer足够大，不要被overrun.

需要知道通道是否启动了aec,所以，需要增加额外的函数来配置参数。现在只是一个aec2.0的宏，绝对不够；如果aec2.0工作正常，应该取消v1.0；需要对端substream的指针。提供填充左声道的函数，基于对端playback substream填充数据；不需要额外的buffer,只需要增加几个索引就好。

**09-13**<br>
abctrl unitest setlog -m audiobox -l 1ffff
abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 77 -z 85 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 5 -o /mnt/sd0/record_1.wav
abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/record_1.wav -v 100
rm /mnt/sd0/record_1.wav
sleep 1

abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 77 -z 85 &
abctrl record -w 32 -s 16000 -n 2 -t 5 -o /mnt/sd0/record_1.wav

modprobe ceva-dsp
audiobox > /dev/null &
abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 77 -z 85 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 5 -o /mnt/sd0/record_1.wav

abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 21 -z 34 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 10 -o /mnt/sd0/record_1.wav


abctrl play -w 32 -f 256 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 21 -z 48 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 20 -o /mnt/sd0/record_1.wav


**09-12**<br>
调试codec,需要频繁改变其内部寄存器实现测试，找到或者实现工具

**09-11**<br>
几个可能需要调整的地方：
1. dma中断模式
2. 是否应该增加delay参数，模拟本地回声延时，不同的产品，回声路径导致的延时不同
3. 验证一下，播放和录音的中断是否时间基本一致，因为它们对应于同一次i2s传输；i2s的传输，是否应该是基本实时的过程，不可能一次传送很多数据，codec慢慢播放
4. 回声处理，如果要求实时，是否应该改为在驱动中完成，而不是经过audiobox转折

dma_size缺省为2，imapx_i2s_set_sysclk()函数中另行设定，一般应该是4；burst_len在imapx_dmadev_request()函数中固定设置为8；所以dma一次搬移32byte数据；基本可以认为，音频的播放和录音是实时的。一个period,

**09-10**<br>
```cpp
void capture_fill_right_chan(uint8_t *pos, uint32_t len)
  p_cap_rd += step; /* just consume it */ //代码是否错误
void dump_playback_data(uint8_t *pos, uint32_t len)
  if (play_sync > SAVED_PERIOD)  //奇怪的逻辑,不是应该直接覆盖,并且保持play_sync不变的么?
void imapx_audio_buffdone(void *data) //中断callback函数中,应该尽量简单,会否导致xrun,或者
  //一次总共传输多少数据,应该不重要;重要的是每个period对应一个中断回调就好
  imapx_pcm_update(substream);//调用层次中,好像包含有usleep()函数,待验证
```

## 09-03->...
**09-09**<br>
解析下面的命令
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-addr2line
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-gprof
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-ranlib
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-readelf
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-size
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-strings
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-ldd
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-strip
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-nm
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-gcov
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-objcopy
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-elfedit
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-objdump
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-gdb

**09-04**<br>
```cpp
//内核中操作文件的方法
static int tl421_printf_dump(char * file_path, unsigned int offset, unsigned int len)
  fp = filp_open(file_path, O_RDONLY, 0644);
  fs = get_fs();	set_fs(KERNEL_DS);
  vfs_read(fp, (char *)&buf, sizeof(uint16_t), &pos);
  filp_close(fp, NULL);
	set_fs(fs);
  //这个函数中包含文件系统在内核内使用的流程，
```

```cpp
int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
  int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
    ret = adap->algo->master_xfer(adap, msgs, num);

  static int imapx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num);
  static uint32_t imapx_i2c_func(struct i2c_adapter *adap);
  static struct i2c_algorithm imapx_i2c_algo = {
  	.master_xfer = imapx_i2c_xfer,
  	.functionality = imapx_i2c_func,
  };
```

**09-03**<br>
## 08-27->...
**08-31**<br>
精简 module_power_on power clock等
增加preuboot0模块，加快uboot0加载过程

新增模块加载uboot0的话，定义好32k,dma只需要一次传输就好，处理可以简化。可以考虑，直接手工定制dma的微指令；dma去掉发送方向代码;dry_run全是0；clear_desc_buf函数改写

```cpp
static int __ref kernel_init(void *unused)
	kernel_init_freeable();
	async_synchronize_full();
	free_initmem();
	mark_rodata_ro();
	system_state = SYSTEM_RUNNING; //会否影响到多线程调度或者中断处理呢？
```

**08-30**<br>

`find . -iname built-in.o -exec ls {} -l \;`

ld各模块大小：
-rw-rw-r-- 1 yuan yuan 258194 8月  30 15:56 ./sound/built-in.o
-rw-rw-r-- 1 yuan yuan 759445 8月  30 15:56 ./fs/built-in.o
-rw-rw-r-- 1 yuan yuan 315940 8月  30 15:55 ./mm/built-in.o
-rw-rw-r-- 1 yuan yuan 45018 8月  30 15:56 ./init/built-in.o
-rw-rw-r-- 1 yuan yuan 115149 8月  30 15:56 ./lib/built-in.o
-rw-rw-r-- 1 yuan yuan 100444 8月  30 15:55 ./arch/arm/mach-q3f/built-in.o
-rw-rw-r-- 1 yuan yuan 25276 8月  30 15:55 ./arch/arm/vfp/built-in.o
-rw-rw-r-- 1 yuan yuan 57474 8月  30 15:55 ./arch/arm/mm/built-in.o
-rw-rw-r-- 1 yuan yuan 93731 8月  30 15:55 ./arch/arm/kernel/built-in.o
-rw-rw-r-- 1 yuan yuan 151809 8月  30 15:55 ./block/built-in.o
-rw-rw-r-- 1 yuan yuan 1367805 8月  30 15:56 ./drivers/built-in.o
-rw-rw-r-- 1 yuan yuan 586877 8月  30 15:56 ./kernel/built-in.o
最后image大小：
-rw-rw-r-- 1 yuan yuan  1088472 8月  30 15:56 uImage
-rwxrwxr-x  1 yuan yuan 2912847 8月  30 15:56 vmlinux*
-rw-rw-r--  1 yuan yuan 3888614 8月  30 15:56 vmlinux.o

**08-29**<br>
有几个问题，不解：
1. system很大，如果必须压缩，freertos怎么办，支持squashfs会否还是很慢
2. 某些驱动本身会化时间
3. 工具链是否需要变化，还是继续使用Linux的，有何区别？
4. 是否可以借用原有的buildroot架构，是否可以为应用程序的重构减少一些负担？由于kernel是基于Kconfig搭建，删除原有的目录就可以自动完成清理工作
5.
**08-28**<br>
初步解析bsp开发流程：
- 确定编译开发环境，定义新的repository作为开发基础
- 实现基本的clock, timer, dma驱动模块，完善中断机制
- 提供OS中间件接口给BSP调用(可选)
- 实现uart和控制台功能，以支持命令行开发调试，后续过程即可并行开发；uart之前采用低效的Polling模式工作
- 逐个实现基本接口： iic, iis, pcm, pwm, gpio, global timer, cmn timer, watchdog, adc, spimul, ssp, rtc, codec, IR ,bt ,usb ,fr ,ftl, ethernet, SD/SDIO/eMMC控制器
- 集成lwip
- 实现ceva-dsp
- 实现音频系统重构
- 实现第三方wifi驱动
- 实现安全子系统
- 实现显示子系统
- 实现视频相关: isp, VENC, FODET, ISPOST, MIPI，不考虑

寻找freertos posix wrapper，否则需要自己编写
全新的开源音频框架 (Audio Development Framework, ADF)，它是基于 FreeRTOS 操作系统，轻量化、可裁剪、高度灵活，支持多种 Codec IC、编解码格式、音乐格式和语音识别服务。

开发时间以单人工作量计, 按照以下几个基本模块来预估:
1. 基础部分: (10 weeks)
    - 编译开发环境
    - clock pmu cmn_timer global_timer 中断
    - uart驱动控制台诊断机制
    - dma
    - fr和cma
2. 存储子系统：(6 weeks)
    - spimul, ssp, flash
    - SD/SDIO/eMMC控制器
    - ftl
3. 音频子系统，作为一个整体来实现, (14 weeks)
    - iic, iis, pcm, audio_codec
    - aec/aac等
    - 替代ALSA的音频框架
    - audiobox cep eventhub 调整
4. misc io: (10 weeks)
    - pwm gpio adc IR bt watchdog usb
5. network: (8 weeks)
    - wifi/ethernet/lwip
OS中间件: (未评估)
显示子系统: (未评估)
安全子系统: (未评估)
视频系统: (未评估)
系统集成: (未评估)

**08-27**<br>
freertos kernel移植基本完成，内核加载、内核启动、中断、tick、任务切换、消息队列等基本机制调试完成, 创建两个互相定时乒乓发送消息的的task, 运行4天没有出现错误

freertos基本移植过程：
1. 下载最新v10.1.0版本
    下载地址： https://sourceforge.net/projects/freertos/
2. 解压之后从中截取如下内容生成新的freertos模块，保存到freertos目录：
  ./FreeRTOS/Source/portable/GCC/ARM_CA9文件夹下，cpu相关部分： portASM.S port.c portmacro.h
  ./FreeRTOS/Source/portable/MemMang文件夹下，动态内存管理：heap_4.c
  ./FreeRTOS/Source/文件夹下c文件，内核核心代码: event_groups.c list.c queue.c stream_buffer.c tasks.c timers.c
  ./FreeRTOS/Source/include文件夹下所有头文件；
  ./FreeRTOS/Demo/CORTEX_A9_Zynq_ZC702文件夹下文件，需要移植中断、timer、tick相关bsp和测试范例，其他内容需要裁剪
3. 使用arm-buildroot-linux-uclibcgnueabihf工具链编译freertos工程，过程中裁剪不必要的demo文件, 编译完成之后进入下一步
4. 添加freertos模块到qsdk工程中，之后调试可以直接执行`make freertos-rebuild`编译
   - 在bootloader/下，添加上述freertos目录
   - 在buildroot/boot/下，添加freertos的config目录，里面包含Config.in和freertos.mk两个文件
5. 调试freertos模块(后面详细描述)
   - 调整makefile
   - 加载中断向量表，设定ARM各工作模式下stack
   - 移植GIC、TIMER模块
   - 增加printf支持
   - 深度裁剪冗余代码
6. 制作启动卡并用来启动freertos demo
  - 在tools/下，添加新的genfreertos.sh脚本，用来构建包含uboot0.isi、items.itm和freertos.isi的启动卡
  - 启动过程: irom -> uboot0 -> freertos

## 08-23->...
**08-26**<br>
**08-25**<br>
**08-24**<br>

**08-23**<br>
GIC相关代码和linux内核部分了解。https://blog.csdn.net/xiafeng1113/article/details/44998179
确定调整timer的clk配置， #define XSCUTIMER_CLOCK_HZ (1536*1000*1000/18UL)，tick基本准确
**08-22**<br>
调整freertos代码，整理代码，包括裁剪掉60多个头文件； 增加vsprintf.c等文件,uclibc库不支持完整的库，或者是我编译选项定义的有问题。
**08-21**<br>
北京，颐和园
**08-20**<br>
北京，长城
## 07-30->...

**08-10**<br>
freertos, 放在iram中,包括中断向量表,这样需要relocate; 估计应该在lds中增加 MEMORY字段,模仿Irom的配置. 只从dram中分配动态的内存. 暂时这样,以后不可以,因为data大小需要扩展的.

**bak_0_repo使用uboot0环境编译出uboot0.isi,拷贝到bak_1_repo作为uboot1.isi使用.**<br>
  make uboot-dirclean;
  make uboot-rebuild; cp -f /home/yuan/work/bak_0_repo/output/images/uboot0.isi /home/yuan/work/bak_1_repo/output/images/uboot1.isi
  ./tools/gendisk.sh /dev/sdb


定义`CONFIG_USE_IRQ`来开启uboot1的中断和堆栈设置

**08-09**<br>
确定工商银行下一个项目.
裁剪uboot到5k和12k两个版本,然后开始移植freertos了.
**08-08**<br>
今天阅读freertos部分代码.
下一步计划:
  1. 在uboot代码中,加载中断向量表,增加中断处理
  2. 增加timer启动停止和中断配置,确认tick功能正常,代码参考irom部分 init_timer()
  3. 集成freertos代码到uboot中

~/work/0sproject/kernel/arch/arm/mach-q3f/include/mach/irqs.h
  //#define IMAP_GIC_CPU_BASE	(IMAP_SCU_BASE + 0x100)

```cpp
static void __init q3f_init_irq(void)
{
	/* start from 29 to enable local timer */
	gic_init(0, 29, IO_ADDRESS(IMAP_GIC_DIST_BASE),
			IO_ADDRESS(IMAP_GIC_CPU_BASE));
	return;
}
```

**08-07**<br>
freertos移植:
  1. 编译;2. 下一步,修改lds;3. 使用uboot0加载
**08-06**<br>
freertos移植:
  编译成功,基于cortex a9和CORTEX_A9_Zynq_ZC702 demo, 中间.s文件编译出错不识别某些指令,增加-mfpu=NEON之后问题解决.
  基于altera的FPGA版本,是一个失误;切换到CORTEX_A9_Zynq_ZC702工程,浪费了一些时间

```cpp
//测试脚本
    while true; do
			videoboxd > /dev/null
			frinfo_ok=`cat /proc/fr_info | grep -c '32.38M'`;echo $frinfo_ok
			echo "step 1"
			echo "Show frinfo_ok : [ $frinfo_ok ]";
			echo "step 2"
			if [ "$frinfo_ok" == "0" ]; then
				echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~initiate videobox failed~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
				break;
			fi
			echo "step 3"
			sleep 1;
			killall videoboxd
			sleep 1;
			echo "step 4"
			cat /proc/meminfo > /dev/null;echo 3 > /proc/sys/vm/drop_caches;cat /proc/meminfo | grep "MemFree"
			echo "step 5"
		done
```

## 07-23->...
**07-27**<br>
本周主要工作内容：
1. 在qiwo门铃上重现videobox申请fr内存失败的问题，并压缩测试条件，基本能保证5分钟之内重现；
2. 在qiwo门铃上移植预留fr内存的新功能，压力测试20小时，申请fr内存失败的问题不再重现
3. 在qiwo门铃上改变CMA迁移算法，原机制先分配最大块的CMA内存，改为先分配满足条件的最小CMA内存块，压力测试1小时，申请fr内存失败的问题不再重现
4. 在qiwo门铃上跟踪问题，发现CMA中内存碎片是由squashfs中管理inode产生的，它从CMA申请的内存无法归还，而同时启动的应用越多，这个inode占用的内存越多，就越容易出现CMA内存不够的问题

下周重现大分辨率拍照测试时申请fr内存失败的问题; jim说最新版本可能改动了一些相关的内容，会导致问题难以重现，所以，可以不测试。

**07-26**<br>
测试，videobox增加参数，控制其执行还是halt,多个halt的程序，应该会占用大量内存，尝试重现场景。

**07-25**<br>
尝试重现qiwo门铃内存分配fr失败问题。
**07-24**<br>

除了足够的fr内存之外，videobox启动还需额外的内存用于程序加载和堆栈等，这个大小缺省是8M，通过ulimit -s 1024可以调整缺省堆栈为1M，那么至少仍然需要3.5M。所以如果应用在videobox之前启动并占用大量内存的情况下，videobox可能因为普通内存不足而启动失败。
//预留34M
cma -f 0 -s 4 -m 3500 -l 1 -t 1 &
//预留35M
cma -f 0 -s 4 -m 3300 -l 1 -t 1 &
sleep 1
cat /proc/meminfo > /dev/null;echo 3 > /proc/sys/vm/drop_caches;cat /proc/meminfo | grep "MemFree"
ulimit -s 1024
videoboxd &

//对比测试1： 允许迁移
//老版本允许迁移videobox终止；新版本cma测试程序终止
cma -f 0 -s 4 -m 5000 -l 1 -t 1 & 直接
sleep 1
videoboxd &

当应用程序申请过多内存时，保护videobox启动，预留足够的fr, 但是mmap内存怎么办？
保护videobox启动，

cma迁移的配置以及预留fr内存的机制，会影响到应用可用内存，测试如下：
//应用程序可用内存测试,保障videobox在3s内完成启动
  //禁止迁移，测试程序可申请4k内存3100次
  cma -f 0 -s 4 -m 3100 -l 1 -t 1 &
  //允许迁移，预留35m，测试程序可申请4k内存3300次
  cma -f 0 -s 4 -m 3300 -l 1 -t 1 &
  //允许迁移，预留34m，测试程序可申请4k内存3500次
  cma -f 0 -s 4 -m 3500 -l 1 -t 1 &
  //允许迁移，无预留fr，测试程序可申请4k内存3700次
  cma -f 0 -s 4 -m 3700 -l 1 -t 1 &
  ulimit -s 1024
  sleep 1
  videoboxd


**07-23**<br>
```cpp
//cma测试程序
//#include <stdio.h>
//#include <stdlib.h>
//#include <unistd.h>
//#include <fcntl.h>
//#include <fr/libfr.h>

int main(int argc, char *argv[])
{
	int opt;
	int blksize = -1;
	int mblknum = -1;
	int cmaflag = 0;
	int fstep = -1;
	char echar;
	int loopcnt = -1;
	int curnum = 0;
	char str[20];
	void * (ptr[1024*32]);
	int total_malloc = 0;
	int total_free = 0;
	int total_fail = 0;
	int mblknum_loc;
	int wait_time = 2000;//seconds
	struct fr_info fr;
	char fr_name[128];

	memset(ptr, 0, sizeof(void*)*4096);

	while((opt = getopt(argc, argv, "s:m:f:l:w:t:"))!=-1) {
		switch (opt) {
		case 's':
			blksize = 1024*atoi(optarg);
			break;
		case 'm':
			mblknum = atoi(optarg);
			break;
		case 'f':
			fstep = atoi(optarg);
			break;
		case 'l':
			loopcnt = atoi(optarg);
			break;
		case 'w':
			wait_time = atoi(optarg);
			break;
		case 't':
			cmaflag = atoi(optarg);
			break;
		case '?':
			echar = (char)optopt;
			printf("argument error, opt char is \' %c \'!\n", echar);
			break;
		}
	}

	if (blksize <= 0 || mblknum <=0 || fstep <0 || loopcnt<=0 || mblknum >= 1024*32) {
		printf("error para value. %d, %d, %d, %d\n", blksize, mblknum, fstep, loopcnt);
		return -1;
	}
	printf("size=%08x, mblknum=%08x, fstep=%08x, loopcnt=%d, waittime=%d cmaflag=%d\n"
		, blksize, mblknum, fstep, loopcnt, wait_time, cmaflag);

		printf("start test loop %d\n", loopcnt);
		while(loopcnt-- > 0) {
			if (cmaflag & 0x1) {
				curnum = 0;
				mblknum_loc = mblknum;
				while (mblknum_loc-- > 0) {
					ptr[curnum] = malloc(blksize);
					if(ptr[curnum])
						memset(ptr[curnum], 1, blksize);
					else {
						total_fail++;
						printf("malloc(%d) failed %d, total: malloc=%d free=%d, fail=%d\n", blksize, ptr, total_malloc, total_free, total_fail);
					}
					if (fstep!=0 && curnum%fstep==0 && ptr[curnum]>0) {
						free(ptr[curnum]);
						ptr[curnum] = 0;
					}

					total_malloc++;
					curnum++;
				}
			}

			if (cmaflag & 0x2) {
				mblknum_loc = mblknum;
				while (mblknum_loc-- > 0) {
					snprintf(fr_name, sizeof(fr_name), "pid%d_%d", getpid(), mblknum_loc);
					if (fr_alloc(&fr, fr_name, blksize, 1) != 0) {
						total_fail++;
					}else
						;//printf("fr_name: %s\n", fr_name);
					total_malloc++;
				}
			}
		}

		if (cmaflag&0x4) {
			curnum -= 1;
			while (curnum > 0) {
				if(ptr[curnum]) {
					free(ptr[curnum]);
					total_free++;
				} else
					break;
				curnum -= 1;
				printf("cmaflag: %d curnum: %d\n", cmaflag, curnum);
			}
		}

		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~End test: cmaflag=%d~~~~~~~~~~~~~~~~~~~~~~~~\n", cmaflag);
		sleep(500);

	return 0;
}

```
## 07-16->...
**07-20**<br>
**07-19**<br>
**07-18**<br>

**07-17**<br>
几种修改方式:
1. 所有的驱动中,dma_alloc_coherent()和dma_free_coherent()调用替换为新的函数接口,只需要在get_dma_ops()中添加一行
2. 所有的驱动中,dma_alloc_coherent()和dma_free_coherent()中dev参数变更为新的api接口对应的dev,set_dma_ops()函数关联两者
3. 驱动和fr分开申请内存
**07-16**<br>
```cpp
mmc_test 6 &测试:
terminate called after throwing an instance of 'std::system_error'
  what():  Resource temporarily unavailable

```
## 07-09->...
**07-13**<br>
确定预留内存方法,测试也发现,上层应用需要借用不到1M的CMA,否则运行错误.所以,节省内存是必须的.
修改kconfig文件的过程中,编译出错,然后就再也恢复不了;两种办法解决问题:1. 代码移植到另外一个目录 2. 比较发现了主要差异, git checkout /kernel/scripts尝试

trace控制
```cpp
extern int 	dmaconti_debug;
extern int 	dmabmp_debug;

//#define dmacontigdebug(fmt, args...) ({				\
	if (unlikely(dmaconti_debug))			\
		printk(KERN_DEBUG	"dma_contig::%s " fmt, __func__, ## args);		\
})

early_param("cma", early_cma);

```
**07-12**<br>
调整分配算法的实现,发现纠结点:预留的fr大小应该设定为多少.
**07-11**<br>
整理和移植bitmap算法的打印信息
**07-10**<br>
videobox启动关闭循环失败,跟踪之后发现是上层的问题;改变测试方法
**07-09**<br>
整理完成内存管理文档,最后使用html格式分享,和md转换最不会丢失信息.讨论完成之后,开始实现.
## 07-02->...
**07-06**<br>
**07-05**<br>
fr分配内存时, flag为 : GFP_KERNEL|__GFP_NOWARN 或者 GFP_KERNEL

**07-04**<br>
为bitmap增加诊断机制,文档化
**07-03**<br>
为bitmap增加诊断机制
**07-02**<br>
整理CMA实现算法
```cpp
//解析代码,一定要确保下面判断是无效的
if (PageHighMem(page))
//解析下面函数,详细
bitmap_find_next_zero_area()

addr = __alloc_from_contiguous(dev, size, prot, &page, caller);
int dma_alloc_from_coherent(struct device *dev, ssize_t size,dma_addr_t *dma_handle, void **ret)
pageno = bitmap_find_next_zero_area(cma->bitmap, cma->count, start, count, mask);
pageno = bitmap_find_free_region(mem->bitmap, mem->size, order);
  //没有对齐的操作,所以,应该使用bitmap_find_next_zero_area的一套接口来实现.

bitmap_find_next_zero_area()

//参考下面的函数来实现,或者,感觉可以直接使用
static void *__alloc_from_pool(size_t size, struct page **ret_page)
	struct dma_pool *pool = &atomic_pool;
	unsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
	align_mask = (1 << get_order(size)) - 1;
	spin_lock_irqsave(&pool->lock, flags);
	pageno = bitmap_find_next_zero_area(pool->bitmap, pool->nr_pages, 0, count, align_mask);
	bitmap_set(pool->bitmap, pageno, count);
	ptr = pool->vaddr + PAGE_SIZE * pageno; 	*ret_page = pool->pages[pageno];
	spin_unlock_irqrestore(&pool->lock, flags); 	return ptr;
static int __init atomic_pool_init(void)
	int bitmap_size = BITS_TO_LONGS(nr_pages) * sizeof(long);
	bitmap = kzalloc(bitmap_size, GFP_KERNEL);
	pages = kzalloc(nr_pages * sizeof(struct page *), GFP_KERNEL);
	ptr = __alloc_from_contiguous(NULL, pool->size, prot, &page, atomic_pool_init);
	for (i = 0; i < nr_pages; i++)			pages[i] = page + i;
	spin_lock_init(&pool->lock);
  pool->vaddr = ptr;		pool->pages = pages;		pool->bitmap = bitmap;		pool->nr_pages = nr_pages;
}
//下面函数改写,增加对应的init函数,控制好所有对应的bitmap.
void *__alloc_from_contiguous(struct device *dev, size_t size, pgprot_t prot, struct page **ret_page, const void *caller)

模仿atomic_pool_init()函数,分配内存部分,好像bitmap已经初始化过
cma_create_area()函数中初始化,和atomic_pool_init()地位相同
cma初始化的时候,每个page增加下面处理:
  __dma_clear_buffer(page, size);
    void *ptr = page_address(page);
  	memset(ptr, 0, size);
  	dmac_flush_range(ptr, ptr + size);
  	outer_flush_range(__pa(ptr), __pa(ptr) + size);//eric : empty function
  __dma_remap(page, size, prot);
    apply_to_page_range(&init_mm, start, size, __dma_update_pte, &prot);
  	dsb();
  	flush_tlb_kernel_range(start, end);
  ptr = page_address(page);
```

----
## 06-25->06-29
**06-28**<br>
请假,带父亲到医院检查心功能.
**06-28**<br>
感觉,可以直接移植最新版本的coherent.c函数中内容,初始化的时候直接增加core_init,保证在普通驱动之前初始化就好.
CONFIG_CMA 估计不能禁止
不是必须用fr的struct device指针作为申请内存时的dev参数,直接使用全局的就好. 在新的驱动文件中定义,core_init函数中申请并且使用系统全局的CMA初始化.



```cpp
struct cma *dma_contiguous_default_area; //包含了

void __init arm_memblock_init(struct meminfo *mi, struct machine_desc *mdesc)
  dma_contiguous_reserve(min(arm_dma_limit, arm_lowmem_limit));

```
void dma_contiguous_early_fixup(phys_addr_t base, unsigned long size);

struct dma_coherent_mem {
	void		*virt_base;
	dma_addr_t	device_base;
	unsigned long	pfn_base;
	int		size;
	int		flags;
	unsigned long	*bitmap;
	spinlock_t	spinlock;
	bool		use_dev_dma_pfn_offset;
};

dma_declare_coherent_memory
dma_init_coherent_memory

__dma_clear_buffer(page, size);
__dma_remap(page, size, prot);
ptr = page_address(page);

如果进入buddy,那么就会有clear和remap的要求,但如果不进入,那么直接计算就可以得到相关的地址信息.

可以直接给common CMA赋予一个

struct device *GLOBAL_CMA;

//#define dma_alloc_coherent(d, s, h, f) dma_alloc_attrs(d?d:GLOBAL_CMA, s, h, f, NULL)

或者修改下面函数就好, dev为NULL的时候,不调用arm_dma_ops,直接

static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
	if (dev && dev->archdata.dma_ops)
		return dev->archdata.dma_ops;
	return &arm_dma_ops;
}

之后需要对比最新版本的情况.

用到的数据结构:
    struct dma_coherent_mem {
	    void		*virt_base;
	    dma_addr_t	device_base;
	    phys_addr_t	pfn_base;
	    int		size;
	    int		flags;
	    unsigned long	*bitmap;
    };
    struct dma_coherent_mem	*dma_mem; /* internal for coherent mem
        mem->size
        mem->bitmap
        mem->device_base
        mem->virt_base
        mem->flags
        dev的用处应该只是获取到这个指针.
    //struct cma *cma_area;		/* contiguous memory area for dma


dma_declare_coherent_memory()函数申请这个指针和对应内存,并且初始化之

**06-27**<br>
**需求**
videobox和客户应用共享使用CMA内存,内存总容量够用的前提下,videobox可能会在某些场景下分配大块连续内存失败.已知场景至少包括:
- 客户高优先级程序和videobox进程同时后台启动,竞争CMA内存,可以参考`RM#6667 videobox 启动出现几率性失败`
- videobox改变分辨率

`RM#6667`问题中david已经确认在内核配置中打开CONFIG_CMA_MIGRATE_OFF的宏,禁止用户程序对CMA内存的抢占,可以避免上述情况的出现. 本文的目标是尝试改善内存管理的方式,允许用户程序占用CMA内存的情况下,避免videobox在剩余内存足够的情况下分配连续内存失败. 客户程序恶意占用过量内存的情况不在本文考虑范围内.

**分析1 内存资源两种统计管理方式**<br>
- bitmap算法,CMA中每一个page都对应bitmap中一个bit,此bit为1代表page已经被分配,为0代表空闲.分配连续内存的时候,在bitmap中寻找第一个连续为0的bit区域,并设置为1;释放内存的时候将此bit区域清0
- 伙伴系统,这是linux内存管理基本算法,不在此介绍;videobox和客户应用共享使用CMA内存的时候,CMA内存初始化时会被释放到伙伴系统中.

**分析2 cma内存申请和释放流程**<br>
下面大概列出申请和释放cma内存的基本调用流程:
```cpp
dma_alloc_coherent(dev, ...)
  |--> dma_alloc_attrs(dev, ...)
    |--> arm_dma_alloc(dev, ...)
      //if (dma_alloc_from_coherent(dev, size, handle, &memory))  return memory;
      |--> return __dma_alloc(dev, size, handle, gfp, prot, false,__builtin_return_address(0)); //dev非空的情况
        |--> return __alloc_from_contiguous(dev, size, prot, &page, caller);
          |--> page = dma_alloc_from_contiguous(dev, count, order);
            pageno = bitmap_find_next_zero_area(cma->bitmap, cma->count,start, count, mask);//从bitmap中找到符合条件的连续内存
            pfn = cma->base_pfn + pageno;
            ret = alloc_contig_range(pfn, pfn + count, MIGRATE_CMA);//从伙伴系统中申请内存
            bitmap_set(cma->bitmap, pageno, count);//在bitmap中标注内存已被占用
            return pfn_to_page(pfn);

dma_free_coherent(dev, ...)
  |--> dma_free_attrs(dev, ...)
    |--> __arm_dma_free(dev, ...)
      if (dma_release_from_coherent(dev, get_order(size), cpu_addr))  return;//dev非空的情况
      |--> __free_from_contiguous(dev, page, cpu_addr, size);
        |--> dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT);
          bitmap_clear(cma->bitmap, pfn - cma->base_pfn, count); //清除bitmap中对应位域
          free_contig_range(pfn, count);//释放内存到伙伴系统
```

`dma_alloc_coherent()`函数第一个参数`dev`确定了它的两种主要使用场景:<br>
- `dev`为`NULL`
  同时使用了bitmap和伙伴系统两种算法管理内存<br>
  申请系统公有的CMA,当前fr和驱动模块都是此种方式<br>
- `dev`为具体设备指针
  仅使用bitmap算法管理内存<br>
  设备独享自定义的私有CMA,当前系统中未使用此种方式<br>

**分析3 改进方向**<br>

videobox分配内存失败后`cat /proc/pagetypeinfo`的显示结果如下:
```
  Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, zone   Normal, type    Unmovable      0      1      2      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type  Reclaimable     70     92     52      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Movable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Reserve      0      0      0      1      0      0      1      1      1      1      0
Node    0, zone   Normal, type          CMA   2161   2160    356      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0

Number of blocks type     Unmovable  Reclaimable      Movable      Reserve          CMA      Isolate
Node 0, zone   Normal            1            1            3            1           10            0
```

用户的应用程序大量抢占CMA的内存后产生过多CMA内存碎片,导致videobox无法申请到足够长的连续内存. 基于此,有两个疑点:
- 碎片过于琐碎,完全没有8或更多page的碎片,怀疑分配算法是否合理
- 伙伴系统有碎片整理的能力,但没有生效,怀疑碎片回收的算法有缺陷

比较系统的跟踪内核相关内存管理部分逻辑之后,我认为现有的cma机制本身如果能够解决上面两个问题,可以满足我们内存使用的需求

**CMA迁移算法bug**<br>
跟踪应用层`malloc()`函数调用流程到`__alloc_pages_nodemask()`

```cpp
__alloc_pages_nodemask()
  |--> get_page_from_freelist()
    |--> buffered_rmqueue()
      |--> __rmqueue()
        page = __rmqueue_smallest(zone, order, migratetype);
        if (unlikely(!page) && migratetype != MIGRATE_RESERVE)
          |--> page = __rmqueue_fallback(zone, order, migratetype);
            for (current_order = MAX_ORDER-1; current_order >= order; --current_order) {
  		        for (i = 0;; i++) {
                migratetype = fallbacks[start_migratetype][i];
                ...
              }
            }
```

应用层调用`__rmqueue_smallest()`申请不到通用内存时,就会调用`__rmqueue_fallback()`从CMA申请内存. 阅读代码时发现逻辑上存在严重问题,检查分配的循环每次从`current_order = MAX_ORDER-1`开始,也就是说每次优先分配最大的内存块,这种逻辑就是个内存粉碎器. 比如我们有10个4M大小的CMA块,10次调用分配之后,哪怕只是分配4k小内存,我们就只剩下10个2M大小的块和大量小碎片;反复大量调用后,最后就只会剩下4k和8k碎片.

简单尝试修改逻辑如下进行测试,不会再出现碎片:
```cpp
  ...
    for (current_order = order; current_order <= MAX_ORDER-1; current_order++) {
    		for (i = 0;; i++) {
        }
    }
```

查看最新linux4.18 kernel,这部分代码也已经被修正,系统优先分配小的CMA块

**碎片整理问题**<br>
这涉及到更复杂的流程,尚未发现问题根源,需要更多时间跟踪. 这应该是超量碎片场景下会出现的问题,修正内存分配算法中逻辑错误之后,没有再次发现

**06-26**<br>

void show_free_areas(unsigned int filter)

void refresh_cpu_vm_stats(int cpu)  计算cpu内存

void drain_zonestat(struct zone *zone, struct per_cpu_pageset *pset)

void zone_page_state_add(long x, struct zone *zone,enum zone_stat_item item)
unsigned long zone_page_state(struct zone *zone,	enum zone_stat_item item)

unsigned long global_page_state(enum zone_stat_item item)
unsigned long zone_page_state(struct zone *zone,enum zone_stat_item item)
void __inc_zone_state(struct zone *zone, enum zone_stat_item item)
__inc_zone_page_state(struct page *page,enum zone_stat_item item)
void __dec_zone_state(struct zone *zone, enum zone_stat_item item)

**06-25**<br>
----
## 06-18->06-22
**06-22**<br>
本周进展:
1.跟踪CMA机制内存alloc过程,发现可移动页不足导致从CMA迁移的时候分配算法不合理,会导致CMA内存出现大量碎片;简单尝试修改算法之后,不再出现碎片,在系统绝大部分内存都被分配出去的场景下,前者为videobox分配内存失败而后者成功;
2.跟踪CMA机制内存free过程,确认了CMA机制中包含对可移动页的碎片整理功能,只是客户的场景中碎片整理失败;暂时停止此方向的跟踪,等确定最终实现方案之后再决定是否继续分析解决;
3.经过简单尝试确定,现有机制的基础上使用dma_declare_coherent_memory()和dma_contiguous_reserve()就可以比较方便的实现fr设备独享CMA


[2018-06-25 11:15:55.966] Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10     11
[2018-06-25 11:15:55.978] Node    0, zone   Normal, type    Unmovable      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:15:55.989] Node    0, zone   Normal, type  Reclaimable      0     10     13      6      0      1      1      0      1      0      1      0
[2018-06-25 11:15:56.000] Node    0, zone   Normal, type      Movable      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:15:56.011] Node    0, zone   Normal, type      Reserve      0      0      0      0      0      0      0      0      0      0      0      1
[2018-06-25 11:15:56.023] Node    0, zone   Normal, type          CMA      0      0      0      0      1      0      3      0      1      0      1      3
[2018-06-25 11:15:56.034] Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:15:56.045]
[2018-06-25 11:15:56.046] Number of blocks type     Unmovable  Reclaimable      Movable      Reserve          CMA      Isolate
[2018-06-25 11:15:56.054] Node 0, zone   Normal            0            1            2            1            4            0
[2018-06-25 11:15:56.063] ~~~~~~~~~~~~~~mes_len: 52~~~~~~~~~~~~~~~
[2018-06-25 11:15:56.080] @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@malloc failed: 3584
[2018-06-25 11:15:56.259] ~~~~~~~~~~~~~~mes_len: 52~~~~~~~~~~~~~~~
[2018-06-25 11:15:59.985] Page block order: 11
[2018-06-25 11:15:59.987] Pages per block:  2048
[2018-06-25 11:15:59.989]
[2018-06-25 11:15:59.989] Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10     11
[2018-06-25 11:16:00.000] Node    0, zone   Normal, type    Unmovable      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:16:00.012] Node    0, zone   Normal, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:16:00.023] Node    0, zone   Normal, type      Movable      0      1      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:16:00.034] Node    0, zone   Normal, type      Reserve      0      0      2      0      1      1      1      1      1      1      1      0
[2018-06-25 11:16:00.045] Node    0, zone   Normal, type          CMA      0      1      0      0      0      0      0      1      1      0      1      2
[2018-06-25 11:16:00.057] Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0      0


**06-21**<br>
设计mmc_test程序,大量分配内存,然后加载videobox的时候,可能因为没有足够的页缓存,有时候20+s才会加载成功程序,然后杀掉mmc_test程序释放内存.

__rmqueue_fallback 的借用顺序也应该调整: 应该在cma已经没有可以借用的时候,再去借用MIGRATE_RECLAIMABLE,现在的代码,是优先借用高order的,同order有限cma的,这样是有问题的.MIGRATE_RECLAIMABLE缺少会导致程序加载速度很慢.

moveable好像从开始就没分配,但显示2个,不知道怎么回事.

我们可以软件配置定义一个上限, 超过这个上限, 不能

记得,海思当时的方案,支持的通道配置变化的时候,需要先释放所有的通道,然后重新分配.
几个方案:
- 兼容之前的CMA方式,解决bug,这是尽量给客户提供更多可用内存的方式,可以考虑让可回收页面占用部分cma内存
- 使用一个cma,禁止客户fallback,使用coherent的bitmap机制管理cma;当前实际上使用的伙伴系统
- 两个cma,一个
实际执行:
- 增加接口,可以让设备申请自己的cma接口
-
**06-20**<br>
migratetype:2 4 current_order:0 a page: c033a000
migratetype:2 4 current_order:0 a page: c0332000
migratetype:2 4 current_order:0 a page: c032a000
migratetype:2 4 current_order:0 a page: c0322000
migratetype:2 4 current_order:0 a page: c031a000
migratetype:2 4 current_order:0 a page: c0312000
migratetype:2 4 current_order:0 a page: c030a000
migratetype:2 4 current_order:0 a page: c0302000
migratetype:2 4 current_order:0 a page: c02fa000
migratetype:2 4 current_order:0 9 page: c02fe000
migratetype:2 4 current_order:0 9 page: c0306000
migratetype:2 4 current_order:0 9 page: c030e000
migratetype:2 4 current_order:0 9 page: c0316000
migratetype:2 4 current_order:0 9 page: c031e000
migratetype:2 4 current_order:0 9 page: c0326000
migratetype:2 4 current_order:0 9 page: c032e000
migratetype:2 4 current_order:0 9 page: c032e000
migratetype:2 4 current_order:0 9 page: c0336000
migratetype:2 4 current_order:0 9 page: c033e000
migratetype:2 4 current_order:0 9 page: c02f6000
migratetype:2 4 current_order:0 8 page: c02f8000
migratetype:2 4 current_order:0 8 page: c0340000
migratetype:2 4 current_order:0 8 page: c0338000
migratetype:2 4 current_order:0 8 page: c0330000
migratetype:2 4 current_order:0 8 page: c0328000
migratetype:2 4 current_order:0 8 page: c0320000
migratetype:2 4 current_order:0 8 page: c0318000
migratetype:2 4 current_order:0 8 page: c0310000
migratetype:2 4 current_order:0 8 page: c0308000
migratetype:2 4 current_order:0 8 page: c0300000
migratetype:2 4 current_order:0 8 page: c02fc000
migratetype:2 4 current_order:0 8 page: c0304000
migratetype:2 4 current_order:0 8 page: c030c000
migratetype:2 4 current_order:0 8 page: c0314000
migratetype:2 4 current_order:0 8 page: c031c000
migratetype:2 4 current_order:0 8 page: c0324000
migratetype:2 4 current_order:0 8 page: c032c000
migratetype:2 4 current_order:0 8 page: c0334000
migratetype:2 4 current_order:0 8 page: c033c000
migratetype:2 4 current_order:0 8 page: c02f4000
migratetype:2 4 current_order:0 8 page: c0326000
migratetype:2 4 current_order:0 8 page: c031e000
migratetype:2 4 current_order:0 8 page: c0316000
migratetype:2 4 current_order:0 8 page: c030e000
migratetype:2 4 current_order:0 8 page: c0306000
migratetype:2 4 current_order:0 8 page: c02fe000
migratetype:2 4 current_order:0 8 page: c02fa000
migratetype:2 4 current_order:0 8 page: c0302000
migratetype:2 4 current_order:0 8 page: c030a000
migratetype:2 4 current_order:0 8 page: c0312000
migratetype:2 4 current_order:0 8 page: c031a000
migratetype:2 4 current_order:0 8 page: c0322000
migratetype:2 4 current_order:0 8 page: c032a000
migratetype:2 4 current_order:0 8 page: c0332000
migratetype:2 4 current_order:0 8 page: c033a000
migratetype:2 4 current_order:0 7 page: c033b000
migratetype:2 4 current_order:0 7 page: c0333000
migratetype:2 4 current_order:0 7 page: c032b000
migratetype:2 4 current_order:0 7 page: c0323000
migratetype:2 4 current_order:0 7 page: c031b000
migratetype:2 4 current_order:0 7 page: c0313000
migratetype:2 4 current_order:0 7 page: c030b000
migratetype:2 4 current_order:0 7 page: c0303000
migratetype:2 4 current_order:0 7 page: c02fb000
migratetype:2 4 current_order:0 7 page: c02ff000
migratetype:2 4 current_order:0 7 page: c0307000
migratetype:2 4 current_order:0 7 page: c030f000
migratetype:2 4 current_order:0 7 page: c0317000
migratetype:2 4 current_order:0 7 page: c031f000
migratetype:2 4 current_order:0 7 page: c0327000
migratetype:2 4 current_order:0 7 page: c02f5000
migratetype:2 4 current_order:0 7 page: c033d000
migratetype:2 4 current_order:0 7 page: c0335000
migratetype:2 4 current_order:0 7 page: c032d000
migratetype:2 4 current_order:0 7 page: c0325000
migratetype:2 4 current_order:0 7 page: c031d000
migratetype:2 4 current_order:0 7 page: c0315000
migratetype:2 4 current_order:0 7 page: c030d000
migratetype:2 4 current_order:0 7 page: c0305000
migratetype:2 4 current_order:0 7 page: c02fd000
migratetype:2 4 current_order:0 7 page: c0301000
migratetype:2 4 current_order:0 7 page: c0309000
migratetype:2 4 current_order:0 7 page: c0311000
migratetype:2 4 current_order:0 7 page: c0319000
migratetype:2 4 current_order:0 7 page: c0321000
migratetype:2 4 current_order:0 7 page: c0329000
migratetype:2 4 current_order:0 7 page: c0331000
migratetype:2 4 current_order:0 7 page: c0339000
migratetype:2 4 current_order:0 7 page: c0341000
migratetype:2 4 current_order:0 7 page: c02f9000
migratetype:2 4 current_order:0 7 page: c02f7000
migratetype:2 4 current_order:0 7 page: c033f000
migratetype:2 4 current_order:0 7 page: c0337000
migratetype:2 4 current_order:0 7 page: c032f000

Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, zone   Normal, type    Unmovable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Movable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Reserve      0      0      2      0      0      1      1      1      0      1      0
Node    0, zone   Normal, type          CMA   1783      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0

Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, zone   Normal, type    Unmovable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Movable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Reserve      2      1      1      0      1      1      0      1      0      1      0
Node    0, zone   Normal, type          CMA      1      1      0      0      0      0      0      1      1      1      1
Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0

cat /proc/pagetypeinfo

**06-19**<br>
**06-18**<br>
----
## 06-11->06-15
**06-15**<br>
内存管理学习

qiwo_lanch_dropcaches()
{
	while [ -f "/tmp/drop" ]; do
		echo 3 > /proc/sys/vm/drop_caches
		usleep 1000
	done
	echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~dropceches stopped!"
}
qiwo_lanch_ceva_dsp()
{
	modprobe ceva-dsp
	touch /tmp/ceva
}
qiwo_lanch_videobox_cur()
{
	videoboxd > /dev/null 2>&1
	touch /tmp/video
}
qiwo_lanch_wifi_cur()
{
	qiwo_load_wifi_driver
	touch /tmp/wifi
}
case "$1" in
  start)
	echo "[ $VERSION ] start qiwo custum script.";

	mount -t vfat /dev/spiblock2 /config
	modprobe Felix clkRate=80000000

	eventhub &

	touch /tmp/keep_power

	echo "start eventhub ."
	#qiwo_lanch_once_wifi
	touch /tmp/drop
	touch /tmp/wifi
	qiwo_lanch_dropcaches &
	while true; do
		#echo "start ceva_dsp ."
		qiwo_lanch_ceva_dsp &
		qiwo_lanch_videobox_cur &

		while [ ! -f "/tmp/ceva" ]; do
			usleep 1000
		done
		while [ ! -f "/tmp/video" ]; do
			usleep 1000
		done

		while [ ! -f "/tmp/wifi" ]; do
			usleep 1000
		done
		modprobe -r ceva-dsp
		#modprobe -r bcmdhd
		kill -9 $(pidof videoboxd)
		rm /tmp/ceva
		rm /tmp/video
		#rm /tmp/wifi

		#dmesg > /tmp/dmesg_info
		usleep 100000
	done

**06-14**<br>
extern int 	dmaconti_debug;
//#define dmacontigdebug(fmt, args...) ({				\
	if (unlikely(dmaconti_debug))			\
		printk(KERN_DEBUG	"dma_contig::%s " fmt, __func__, ## args);		\
})

dmacontigdebug("real alloc switch : %d", real_switch, (int)test1, (int)test2);

dmamapdebug("real alloc switch : %d", real_switch, (int)test1, (int)test2);


内存管理学习
**06-13**<br>
MIGRATE_UNMOVABLE,	MIGRATE_RECLAIMABLE,	MIGRATE_MOVABLE, MIGRATE_CMA,
从只读文件系统加载的程序,申请的内存应该是MIGRATE_MOVABLE,这样应该更好.
内存管理,需要考虑MIGRATE_RECLAIMABLE到MIGRATE_CMA的迁移可能.
**06-12**<br>
内存管理学习
**06-11**<br>
内存管理学习
----
## 06-04->06-08
**06-10加班**<br>
内存管理学习
**06-08**<br>
cma内存的申请和释放，以方便的方式dump出来，包含开始地址，大小等信息，按照顺序打印，列出hole等．

**06-07**<br>
阅读内存管理代码和资料
printk(KERN_EMERG "func:%s, %d~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", __func__, __LINE__);

printk(KERN_EMERG "func:%s, %d~~~~~~~~~~~~~~~~~\n", __func__, __LINE__);
printk(KERN_EMERG "~~~~~~~~~func:%s, %d, (%x %x)\n", __func__, __LINE__
          , (int)test1, (int)test2);
printk(KERN_EMERG "~~~~~~~~~func:%s, %d, (phys:%x addr:%x pgd:%x)\n", __func__, __LINE__
					, (int)phys, (int)addr, (int)pgd);
memblock_dbg("memblock_reserve: [%#016llx-%#016llx] %pF\n",
		     (unsigned long long)base,
		     (unsigned long long)base + size,
		     (void *)_RET_IP_);

**06-06**<br>
阅读内存管理代码和资料

CMA问题，建立测试脚本，mmc_test程序，以多种不同的大小和方式申请内存，测试多种场景下CMA以及整个内存系统的状态变化，分析解决问题．
之后门铃项目中反映50Mhz工作不稳定，uboot容易出现启动失败，这应该是spimul两个时钟非同源导致．
增加记录，每个进程占用的内存．

整体修正：
http://gerrit.in.infotm.com/#/c/15770/

**06-05**<br>
RM #6625 -- BU2: 读写jffs2分区导致下次启动无法挂载文件系统
RM #6272 -- QSDK: [Allchip][BSP] 内核环境中SPI总线时钟无法工作在50MHz
问题分析解决：
之前完全无法工作在50MH，是因为clk.c中配置ssp-clk时，ENABLE 了 NCO　模式，时钟波形质量差．

代码上传：comment #4中已经包含

make app-d318-upgrade-rebuild;make

fix(spimul,spiblock): resolve a squashfs access error problem
this problem get caused by two issues: 1. ssp_clk and spibus_clk of spimul is generated from different PLL, this may cause bus error at high speed transmission; 2.spi_block read cache buffer have a bug which casue memory access out of bound
Close 6722

尝试16kblock size，和下层保持一致； 更新squashfs版本到4.2
印象中，mmc驱动每次数据最大128k；spi接口现在定义16k --> mmc->max_blk_size = 65536;mmc->max_seg_size = 0x1000;之类的设定

**06-04**<br>
[2018-06-05 13:33:05.460] blk:dc8 cnt:24 (105053, 125148) // 8成的数据读取是32个block．
      blk_cnt = ((offset_addr[segments+1] - offset_addr[0]) >> tr->blkshift);
			blk_addr = (block + (offset_addr[0] >> tr->blkshift));
			//ktime_get_ts(&ts_write_start);
			if (tr->read_multisect(dev, blk_addr, blk_cnt, spi_blk->cache_read_buf)) {
				ret = -EIO;
				break;
			}
			//ktime_get_ts(&ts_write_end);
			//printk("infotm %x spi %d %d read %d %d \n", buf, blk_addr, blk_cnt, (ts_write_end.tv_sec - ts_write_start.tv_sec), (ts_write_end.tv_nsec - ts_write_start.tv_nsec));
			for(i=0; i<(segments+1); i++) {
				buf = (char *)buf_addr[i];
				blk_cnt = ((offset_addr[i+1] - offset_addr[i]) >> tr->blkshift);
				memcpy(buf, spi_blk->cache_read_buf+offset_addr[i], blk_cnt<<tr->blkshift);
			}
spiblock_fs_read_multisect() 函数修改，直接读取到本地的buffer中就好，或者，spi部分实现sg dma机制．

可以考虑，跟踪一个完整的squshfs文件加载过程．

需要确定，调整时钟同源之后，boot和kernel阶段192m应该分频到32M？然后就是对pll022的影响？
cd config;touch test;touch drop;sync

uboot中spi读取数据块64k切换到4k，影响8%的效率(115ms--123ms).
int32_t ssp_manager_set_flash_type(uint32_t flash_type)
  spi_manager_g.flash_sector_size = 64*1024;

pl022最大一次读取4k，这才是最大的区别．
是否应该打印所有的flash访问请求呢？或者，最近的若干个．

----
## 05-28->06-01
**06-03加班**<br>
每次dma传输前后，都增加一定的延时，看是否能够解决问题!!!!!
降低分频之前的输入时钟，也许会有影响，之前出现300M输入需要改成150才能使用的情况．而且之前都是使用60M的时钟．
不知道太低会否不好，那么就再试试看4倍频吧．
之前的测试，重新使用低频率试试看．
测试发现，使用单个总线时钟就可以驱动spi接口了．

**06-02加班**<br>

脚本中增加限制，保证videobox在ceva_dsp加载成功之后启动，不清楚两者之间是否存在有某种互斥关系．

禁止mmc0

qiwo_lanch_dropcaches()
{
	while [ -f "/config/test" ]; do
		echo 3 > /proc/sys/vm/drop_caches
		usleep 10000
	done
	echo "dropceches stopped!"
}

请不要忽略：　Bus error

**06-01**<br>
请假，上午去中山医院，下午国际象棋
**05-31**<br>

根据这几天的测试，如下操作可以保证不会出现当前问题：
1. Felix，videoboxd，qiwo_load_wifi_driver保持前台运行
2. 取消drop_caches操作
估计这个问题和内存占用有关，进一步分析需要更多时间．
感觉drop_caches操作应该是清理了cache，导致立刻需要读取填充大量数据，导致问题；总线频率太高，是否同样的情况？不断在各个进程之间颠簸．
单线spi没有这个问题，

下一步：　禁止drop_caches再次尝试
echo 4 > /proc/sys/vm/dirty_background_ratio
echo 8 > /proc/sys/vm/dirty_ratio
printk(KERN_EMERG "fragment_cache: (%d, %d)\n", SQUASHFS_CACHED_FRAGMENTS, msblk->block_size);
禁止squashfs的cache如何？
```cpp
//基本的清理过程，但实际上没有任何意义
free -m
sync
cat /proc/sys/vm/drop_caches
echo 3 > /proc/sys/vm/drop_caches
cat /proc/sys/vm/drop_caches
```
整理清楚：uboot0启动时part和其他传入kernel的参数的管理

感觉有可能是squashfs中存在的一个bug,cache相关的，cache已经被回收，但内核继续索引使用．
最新修改的脚本去掉sleep;
恢复其他所有的脚本，只去掉echo 3 > /proc/sys/vm/drop_caches看看结果如何．

**05-30**<br>
下一步，d318等程序，移动到videobox之后启动，而且应该保证videobox启动完毕．

内核加载程序时增加打印信息，记录时间:
static int do_execve_common(const char *filename,
  if((strcmp(filename, "/usr/bin/audiobox") == 0) || (strcmp(filename, "/usr/bin/videoboxd") == 0)
		|| (strcmp(filename, "/usr/bin/d318") == 0)
		|| (strcmp(filename, "/usr/bin/systemmsg") == 0)
		|| (strcmp(filename, "/usr/bin/d318") == 0))
		printk(KERN_EMERG "~~~~~start exec: %s at [%d]\n", filename, jiffies);

可以考虑同时启动包括videobox在内的多个程序，也许出现几率更高．
  就算是不重现，比较并行启动和串行启动的时间长度．

videoboxd延时
[2018-05-30 09:59:01.204] Ispostv2: ispost_open
[2018-05-30 09:59:01.207] SQUASHFS error: lzo decompression failed, data probably corrupt
时间非常接近，所以，有可能会造成影响．

ispost_open 开始和结束的时候，增加打印
调整代码，改变时钟的时候刚好在读取文件．或者，测试程序后台运行，读取几个典型的大文件．
videoboxd加载之前的900ms延时，真是有毛病．

弄清楚，
1. item文件的part部分是如何解析的
2. ftl的模块化机制
3. mtd功能

几种烧录方式流程：
1. upgrade流程
2. d318-upgrade，客户自定义流程
3. uboot1烧录

**05-29**<br>
make app-d318-upgrade-rebuild;make
mkdir /mnt/sd4
mount -t squashfs /dev/spiblock1 /mnt/sd4
mkdir /mnt/sd3
mount -t vfat /dev/mmcblk0p1 /mnt/sd3
cp -fr / /mnt/sd3
cp -fr -L /usr /mnt/sd3

**05-28**<br>
Unable to read page, block 4f5556, size 1515a
SQUASHFS error: ~~~2 lzo decompression failed: -5, out_len:0x15eb7

读取：
//１．位宽改为每次读取16bits
２．6 dummy cycles 需要确认一下，什么意思
３．试试看降低时钟，看起来好像很难出现，很奇怪，好像复现过，但现在无法重现．
４．尝试去掉 SPI_NOR_QUAD_WRITE SPI_TX_QUAD 这两项
５．sd卡启动，反复读取flash，确认每次读取内容相同．
６．尝试，单线，35Mhz，是否会出现错误．
７．后台运行的程序，尝试全部提到前台来．
８．禁止mmc0初始化，根本没用到，看是否有影响．
９．内存不够，有可能吧，alloc_contig_range test_pages_isolated(41500, 417f8) failed
１０．squashfs上层再次读取并解压
１１．spi驱动层确定读取错误原因
１２．使用高倍率分频(8)，并尝试 imapx_spi_probe()函数中禁止：
    `clk_set_rate(host->extclk, host->master_info->extclk_rate);`
１３．应该考虑调整busclk
１４．尝试polling方式4线测试
１５．尝试kernel中启动wifi和ddk驱动等，或者，kernel启动时初始化相关时钟．
１６．尝试，降低cpu整体时钟．

repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b dev_qsdk
repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b qipc_qiwo_doorbell_dev
repo sync -c
repo start develop --all


**也许倍频因子也有影响，至少应该是４，２会出问题？**
如果是这样，提高原始clk，设置：
  `DEV_CLK_INFO(SSP_CLK_SRC, 0, EPLL, 0, 4, DISABLE),`
  `.extclk_rate = 120000000 /*50MHZ*/`

或者，在底层增加判断，每批数据读取两次，然后进行比较，不同的话，打印错误，以确认问题．　
Dear david,
分支：   qipc_qiwo_doorbell_dev
下载完后做修改两处代码
1.按照如下diff，后修改一个文件
mqd@mqd-OptiPlex-3020:~/2018/qiwo/qipc_qiwo_doorbell_dev_squashfserror/system$ git diff
diff --git a/d318/S22qiwo_ff b/d318/S22qiwo_ff
index 862cf68a..a0c0e2aa 100755
--- a/d318/S22qiwo_ff
+++ b/d318/S22qiwo_ff
@@ -787,8 +787,8 @@ case "$1" in

        echo "[ $VERSION ] qiwo custum script end..."
        sleep 15;
-       cd /ff && ./autotest &;
-    ./autotest_videobox &
    cd /ff && ./autotest &

2.将system/d318/ff/下的autotest用该目录下的autotest-squashfserror替换
编译：　./tools/setproduct.sh   1   doorbell  0   PS5230DVP_NEW.json  0   ps5230dvp
    使能4k block
    make app-d318-upgrade-rebuild;make
    make d318-rebuild;make;./tools/mkburn.sh /dev/sdb
    cat /proc/pagetypeinfo

  	eventhub &
	modprobe ceva-dsp &
	modprobe Felix clkRate=80000000 &

	echo "start eventhub ."

	qiwo_load_wifi_driver  > /dev/null ;
	qiwo_initdir  > /dev/null ;
	qiwo_check_if_to_set_network1  > /dev/null ;
	qiwo_lanch_videobox &
	echo "[ $VERSION ] lanch doorbell ";
	d318 &
	nice -n -20 systemmsg  > /dev/null &
	echo "[ $VERSION ] let doorbell start in backgroud. ";
	qiwo_lanch_audiobox > /dev/null  &
	qiwo_initial_wifi_info > /dev/null  &
	qiwo_nptd_initial > /dev/null &
	echo "[ $VERSION ] qiwo custum script end..."
	touch /tmp/keep_power
	echo "reboot 15s later..."
	sleep 15;
	cat /proc/fr_info
	frinfo_ok=`cat /proc/fr_info | grep -c 'Total: 23.65M'`;echo $frinfo_ok
	process_ok=`ps | grep -c -e 'videoboxd$' -e 'audiobox$' -e 'd318$'`;echo $process_ok
	echo ""
	echo "Show frinfo_ok : [ $frinfo_ok ] ... process_ok : [ $process_ok ]";
	echo ""
	if [ "$frinfo_ok" == "1" ]; then
		if [ "$process_ok" == "3" ]; then
			echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~initiate videobox ok~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
			reboot
		fi
	fi


----
## 05-21->05-25
**05-27**<br>
测试：　
1. 8字节对齐，原代码，问题重现
2. 64字节对齐，问题仍然重现
3. 恢复单线spi接口－－周一检查,没有重现，所以这是4ｌｉｎｅ相关的问题．
4. 尝试polling方式4线测试

**05-25**<br>
17:04开始测试
手机上resetting wifi重新绑定，按门铃按键启动程序，绑定的时候需要保证删除/confit/test文件．绑定完毕，重启，touch /config/test触发测试流程  d318.c qiwo_write_uart 2741  send usart data: aa 15 2 b5 b9 55　//2表示开启测试过程

spi驱动，如果使用全双工协议，那么最好在pl022中完成；怀疑spi-core的机制是否还合适，因为需要经常填充和发送空的消息，这个消息不应该来自于上层，而且为了保证效率，最好避开core的thread上下文，直接在pl022中维持发送和接收链表；
pump_transfers()函数中，调用 spi_get_next_queued_message()函数判断master队列为空，就直接封装简单消息接口；这需要增加 set_up_next_null_transfer()函数；

全双工方式下，发送空消息，或者上层tx_buf中信息；接收到的数据需要判断是否有效，无效就直接丢弃，有效，放到队列中．

上层接口：模仿net,发送和接收定义buffer. 阻塞读取，阻塞发送，

spi驱动层，只需要增加标志位，表明是否填充即可，最多加上有效长度．

spi_get_next_queued_message()函数可以直接取下一消息．

评价包含：
1. 整体评价，如能力，特点，长处等等
2. 突出业绩（如印象最深的，最有价值的等等，不要超过3个）


**05-24**<br>
内存管理基本机制学习;下午4:30－6:00 spi驱动会议；
**05-23**<br>
内存管理基本机制学习
**05-22**<br>
no_scatterlist_test 分支，调试并解决pl330 scatterlist 传输问题
另外一个不对头的地方，tasklet中调用callback,callback中包含有delay,这是不大合适的，考虑工作队列替代．
struct pl330_info *pi = &pch->dmac->pif;
dev_err(pi->dev, "~~~~~~~~ %s:%d!\n", __func__, __LINE__);

**05-21**<br>

fix(spimul): resolve a jffs2 mounting problem from anni project
this was caused by 4-line spi bus working with too small rx burst length, so adjust minimum dma rx burst length to 16 bytes for 4-line spi bus, to speed up dma transfer
Close 6625

mkfs.vfat /dev/spiblock2
umount /dev/spiblock2
mkdir /mnt/sd3
mount -t vfat /dev/spiblock2 /mnt/sd3

cp /bin/busybox /mnt/sd3
cp /mnt/sd3/busybox /mnt/sd0/b2

int len = 0;
if(len > 4096)
 		 pr_err("[spimul] 1~~~~~~~~~~~~~~~~~~~~~rx err:%d %d\n", __LINE__, len);

----
## 05-14->05-18
**05-20加班**<br>
linux驱动，宋宝华版本，前面几章基本过滤
**05-19加班**<br>
pl330文档，spi调整机制的分析．
**05-18**<br>
深入了解pl330机制以及分析测试之后，估计问题可能是因为每次dma搬运的burst数据太少(4bytes)，如果spi接收数据的速率超过dma通道搬运能力，就会出错；尝试降低spi频率到5M，如预期不会出现问题；尝试提升spi频率到60M,同时加大burst长度到64,如预期也不会出现问题．
**05-17**<br>
阅读pl330代码
**05-16**<br>
16字节对齐可以解决问题，继续分析根本原因．开始阅读pl330代码
**05-15**<br>
新硬件上重现问题，尝试比较出错jffs2分区和正常分区在写入相同内容时差别，无法找到分析依据；发现出错时最后数据长度3800，尝试512字节对齐，问题解决
**05-14**<br>
anni分支调试，总是出现jffs2的访问错误，但最后发现是硬件问题，烧录kernel和system失败．kernel启动提示，版本时间是05/11的．
----
## 05-07->05-11
**05-12加班**<br>
p2p基于udp，所以，点到点的数据传输可能会丢失，
    同样，udp包记得是必须按照packet接收，不像tcp收发可以直接放在buffer中，所以，p2p自己额外定义了buffer，必须要尽快接收．
    设备到pc，pc接收非常简单，没有发现丢失数据；pc到设备，数据丢失非常明显，尤其是批量传送的时候
p2p内存耗尽问题：
    １．p2p需要限制接收buffer的大小，否则传输的burst会导致内存耗尽
    ２．及时通知，尽快消耗数据，查询方式可能太慢
创建独立的spi线程，直接从rx缓冲区中获取数据发送．
buffer大小的定义，按照packet的大小比较合适，这样可以增加响应速度．
有一个问题，如果短时间内接收到比较多的packet，xr871来不及通过spi发送到c20，p2p会malloc过多的内存，导致内存耗尽而crash．这个问题我这边无法避免．
|--> 和涂鸦讨论确定，涂鸦将移植MQTT协议相关部分到xr871，音视频封装处理部分到c20，预计5月末完成；配合涂鸦的sdk更改，我们这边需要修改spi和p2p软件，以支持多个session以及每个session支持多个channel的设计．
周五已经实现基本的spi消息机制，在c20和pc之间实现了简单的双向通信demo：c20传递一个文件到pc，同时pc传递一个文件到c20，文件验证没有出现错误．
下一步，等待涂鸦完成sdk移植之后的集成．

**05-11**<br>
anni分支相关登录:
repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b qipc_anni_dev
repo sync -c
git tag //显示所有版本tag
git checkout qsdk_ipc_v3.6.1
repo start develop --all

root anni2013

二. 代码编译:
./tools/setproduct.sh
//# please choose a product from list below:
0   q3520e_nopmu    1   q3520e_nopmu_isp_debug  2   qipc_38f_nopmu
//# your choice: 0
//# configuration written to /home/soyo/soyo_work/ipc/qipc_anni_dev/.config
//# product successfully set to q3520e_nopmu
//# please choose sensor0 configuration:
0   sc2235dvp     x   none
//# your choice: 0
//# please choose product json configration:
0   1080P.json  1   1080P_IQ.json 2   rc.json 3   720P.json 4   960P.json x   default
//# your choice: 0
//# choose configuration successfully to q3520e_nopmu
三. 代码烧录:
1. 编译完将output/images下所有文件拷贝到tf卡
   //cp -rf output/images /media/yuan/Ubuntu\ 16.04\ LTS\ amd64/
   cp output/images/* /media/yuan/Ubuntu\ 16.04\ LTS\ amd64/
   cp output/images/uImage /media/yuan/Ubuntu\ 16.04\ LTS\ amd64/
   sync
   sudo eject /dev/sdb
   cd /media/yuan/Ubuntu\e520_1line 16.04\ LTS\ amd64/
2. 烧录在uboot1阶段敲空格停在命令交互界面，插入TF卡，使用以下命令更新需要更新的镜像文件
vs assign mmc1;vs assign flash;vs erase 10000 10000
//uboot0.isi+items.itm
vs assign mmc1;fatload mmc 1:1 80008000 uboot0.isi;fatload mmc 1:1 80014000 items.itm;vs assign flash;vs erase 0 10000;vs write 80008000 0 10000
//uboot1.isi
fatload mmc 1:1 80008000 uboot1.isi;vs erase 20000 40000;vs write 80008000 20000 40000
//kernel
fatload mmc 1:1 80008000 uImage;vs erase 60000 200000;vs write 80008000 60000 200000
//system
fatload mmc 1:1 80008000 rootfs.squashfs;vs erase 260000 D20000;vs write 80008000 260000 D20000
//app data
vs assign flash;vs erase F80000 80000

vs assign mmc1;vs assign flash;fatload mmc 1:1 80008000 uImage;vs erase 60000 200000;vs write 80008000 60000 200000


26+d2 = F80000

ifconfig eth0 down
ifconfig eth0 192.168.21.108 netmask 255.255.255.0 broadcast 192.168.21.255
ifconfig eth0 up

inet addr:128.168.91.233  Bcast:128.168.91.255  Mask:255.255.255.0

ifconfig eno1 128.168.91.235 netmask 128.168.91.255 broadcast 255.255.255.0


ping 128.168.91.233

**05-10**<br>
下一步调整：　p2p client，发送命令配置xr871的测试参数；c20测试参数从命令行输入
数据传输方式：
１．c20轮询，查询有没有接收到数据，或者能否发送新的数据，有的话就启动过程．暂时按照单向传输实现．
２．xr871检查p2p buffer,和c20交互状态信息，执行c20数据请求

基于spi增加测试命令：数据开始，结束，下一个文件，等等．

测试项目，需要统计传输速率等信息(还需要测试，dma最小块对齐是否256.)：
1. 单元测试：相同大小数据块传输，传送/接收/全双工，参数：数据块大小，数据块个数
2. 单元测试：cmd+data数据块传输，传送/接收/全双工，参数：数据块大小，数据块个数，命令长度
3. 真实数据传输，文件或者指定数据块．

应用场景：
1. c20发送结束，发送命令到xr871，xr871xr871发送cmd到client
2. client发送结束，发送命令到xr871，xr871xr871发送cmd到c20
3. client启动，发送命令启动xr871和c20
4. client同时发送和接收数据，启动发送完毕命令，接收接收完成命令．

c20实现：
1. 读取：循环check然后读取
2.

**05-09**<br>
c20到client传输没哟发现文件，反方向总是出错．跟踪，最后发现消息头部定义不能小于128bytes，可能和xr871的dma配置有关．如果项目立项，那么后续继续跟踪．当前，先使用128的消息头长度．
**05-08**<br>
发送和接收在涂鸦应用中分开实现：
　　如果上层使用轮询方式接收，那么发送和接收，可以分开实现
　　如果采用线程+消息队列的方式，那么最好发送和接收一起，可以提高效率。
　　针对当前的应用，分开实现可行而且比较简单。
完全采用c20主控，这样无论发送还是接收，都需要xr871满足了指定的长度要求，才能传输，这样暂时可以简化代码的设计

printf("reach: <%s,%d>\n", __func__,__LINE__);

c20处理流程：
　　０．启动一个线程
　　１．查询对方收发状态
　　２．如果可以发送就从本地文件中读取内容发送
　　３．有数据就绪就读取并写入目标测试文件
xr871处理流程：
　　０．启动一个线程
　　１．接收一条命令，查询，接收，发送的操作．
　　２．如果可以发送就从本地文件中读取内容发送
　　３．有数据就绪就读取并写入目标测试文件
然后，尝试双工读写数据，明显简化
　　０．启动一个线程
　　１．全双工访问．

**05-07**<br>
上午移植涂鸦sdk，和涂鸦　力波讨论确定api接口含义
初始化：
    tuya_ipc_tranfser_init(&p2p_var);
    start_live();
启动session:
    tuya_ipc_session_start(23, TRANS_MODE_P2P);
发送视频：
    １．初始化视频通道：　ret = tuya_ipc_ring_init(VIDEO_MAIN_CHN, 512*1024);
    ２．循环发送视频帧：tuya_ipc_ring_append_data(VIDEO_MAIN_CHN, videoBuf, len, media_type, pts);
发送音频：
    １．初始化音频通道：　ret = tuya_ipc_ring_init(VIDEO_MAIN_CHN, 512*1024);
    ２．循环发送音频帧：tuya_ipc_ring_append_data(AUDIO_CHN, audioBuf, len, AUDIO_FRAME, pts);
下午和晚上基本都在会议

----
## 05-02->05-06
**05-06加班**<br>
amba bus相关代码解析； 远程桌面剪贴板功能，处理失败，所以转向确认验证了几个通用共享方式：samba/cifs/nfs/ftp

**05-05加班**<br>
今天考虑增加spi全双工传输的支持.
1. 测试，每次大的数据传输之前先额外增加４个字节的收发，看会否影响到正常的处理．
spi传输函数全双工时候，使用动态内存来分配发送buffer，出现错误，spi卡死在dma，可能是需要一定程度的对齐．
如果全部的数据都进行校验，开销太大；如果不校验，那么不安全．所以推荐采用部分校验的方式．命令需要校验，数据帧中的命令ack部分，也应该校验．
每个传输过程可以通过两种方式触发：１．两个方向的申请中断；２．轮询方式，中间可以增加msleep.　后面这种方式虽然效率稍低，但本身视频传送是非对称的，c20发送的数据不会引入延时，而且手机端过来的数据应该对延时有一定的容忍度．

应该在驱动层完成传输过程的操作．
除了数据，前面过程就算是有错，也要执行完毕几个步骤
cmd加上两次ack的方式：
１．cmd，交互信息
２．可控制数据传输 : 中断方式或者延时方式处理错误
  如果任何一方对协商结果有异议，那么就否决数据传输．这一步不方便通过传输的内容来判断，因为内容可能出错．尤其是长度信息出错将会导致失控
    c20不启动传输，或者xr871不触发ready中断．通过超时来实现．也就是说，每次出错付出的代价是一定延时．
    传送请求，启动一次全新的传输；重传请求，不发送data，直接再次重新传输cmd.
  xr871检查到错误:
    c20增加一个请求资源的接口，阻塞等待dma ready中断，重传请求中断也可以终止它，哪个中断先到就处理哪一个．xr871检查到错误就发送重传请求，否则就发送dma ready中断．
  c20检查到错误
    不启动数据传输，产生重传请求中断，xr871接收到中断之后，终止数据dma的配置．

如果协商没有数据需要发送，那么数据部分就作为ack用．增加seqnum的控制，出错重传．xr871在一次传输中，没有数据要发，那么下次轮询的时间间隔可以定义的稍长．

xr871一次基本读写流程：
１．读取当前tcp的读写buffer大小
２．如果有读的，设置好当前send_len
３．读取recv_buffer，如果网络缓冲就绪就发送；如果当前recv_buffer中空，设置recv_enable=1
４．spi读写8同步字节
５．填充send_buffer内容，协调两端数据长度，开始spi传输过程

如果同步字节完毕之后，刚好有新的frame过来，那么延后处理这个frame.

**05-04**<br>
又要开始涂鸦sdk移植，有点头疼．

全志xr871，app软件是基于freertos和lwip的，完整资料可在https://github.com/XradioTech/XR871下载
chip vendor: 全志
chip type: ARM Cortex-M4F
chip Model: xr871
Endian: Little
ToolChain Version:4_9-2015q2
ToolChain Info:　gcc-arm-none-eabi-4_9-2015q2
编译开发环境搭建参照　XR871/03_SDK/XR871_Quick_Start_Guide-CN.pdf 文档

开发可以使用project/wlan_demo工程作为基础。

接入无线路由器，比如接入"TP-LINK_5E87E6"，可以在命令行输入：
net mode sta
net sta config TP-LINK_5E87E6 12345678
net sta enable



范例command TP-LINK_5E87E6　为路由器ssid，密码12345678



chip vendor: Infotm
chip type: ARM Cortex-A5
chip Model: C20
Endian: Little
ToolChain Version:4.7.3
ToolChain Info:　arm-buildroot-linux-uclibcgnueabihf

工具链下载：
Windows:https://launchpad.net/gcc-arm-embedded/4.9/4.9-2015-q2-update/+download/gcc-arm-none-eabi-4_9-2015q2-20150609-win32.exe
Linux:https://launchpad.net/gcc-arm-embedded/4.9/4.9-2015-q2-update/+download/gcc-arm-none-eabi-4_9-2015q2-20150609-linux.tar.bz2

开发过程中，修改default config，可以提高distclean之后的工程配置工作效率
meld products/q3fevb_va_ipc/configs/qsdk_defconfig .config
meld products/q3fevb_va_ipc/configs/linux_defconfig output/build/linux-local/.config

**05-03**<br>
重新整理spi和p2p的测试代码，调试中出现一些弱智问题，浪费了３个小时时间．
可以从c20发送文件到pc，或者c20无限发送数据，这两种模式方便之后的调试．
xr871启动支持下面几种模式：
１．进入命令行之后不执行任何测试
２．链接自己缺省路由测试
３．链接pc server，通过网络获取指定测试路由，然后开始测试
４．rw程序最好可以完成更加复杂一点的测试内容，可以rw程序指定传输的数据长度或者时间

设定两种发送模式：<br>
- 指定文件发送，发送完毕为止，可以设置文件参数, 不指定文件的话就是无限发送
　mmc_test send -f /mnt/sd0/pcm_16khz_ch2_32b.wav -b 16
- 无限发送
　mmc_test send -b 16
