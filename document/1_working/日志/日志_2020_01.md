*# 工作日志

### 修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2019/01/07 | 员清观 |  |

## misc

上海盈方微电子有限公司 江苏路 公司wifi:  OFFICE : 1234abcd
员清观 18616715815  上海长宁区江苏路398号舜元企业发展大厦A座三楼
专利网站：　Waj@

`nautilus .` 可以用来从终端启动文件管理器并切换到当前文件夹

./tools/setproduct.sh   36   nvp6134   mbox_all.json

**确认**<br>
  分工情况:
  近期任务清单: q3f是否需要测试, 整理测试用例,
  redmine管理, 增加权限, 添加bug来管控问题.

**调试性质启动盘:**<br>
  之后的调试性质启动盘,应该格式化为ext4文件系统; 其他场景保持向前兼容, 找一个合适的方式来判断, 或者使用一个独立的脚本.

**理清个人负责模块:**<br>
  van.zhuang - usb otg /frbuffer /usb网口 /uvc /i2c /
  can.cai     - dw_mmc /audio_codec /CCF(common clock framework) /pmu /ether /item /adc /
  bob.yang    - wifi /upgrade /cep.eventhub /display /net /dvfs(cpu_freq)

gitk --author=eric.yun

**karry**<br>
  1. 客户接口  2. 文档管理, 代码管理git gerrit redmine, bug管理  3. TestLink系统, 单元测试管理, 自动测试, 压力测试
  4. 客户接口  5. 研发部门架构  6. 开发流程

**auduiobox:**<br>
  1. abctrl命令支持指定默认trace的保存目录
  2. 增加一个新的命令, 原封不动的传递单元测试命令, 现有abctrl debug 支持的外部配置, 命令和参数完整的传输到audiobox后解析执行, 这样, abctrldebug保持同样的版本, 只需要升级audiobox就好

printk(KERN_EMERG "~~~~~~~~~~~~ step %s,%d: \n", __func__, __LINE__);

wall_clock()　回调函数，是否适合用作音视频同步的需求呢？

专利： AEC主观效果客观评估方案  -- pesq工具的使用，和信噪比
      使用软件参考音时提高SPEEXDSP回声消除效果的方法

rtthread社区： littel_bear0322 aj
RTT 已经支持 Cortex-A7，和 Cortex-A5 相同，可以参考这个 bsp； bsp文件下有imx6ul
参考的 imx6UL 就行

**关于rtos的缺点**<br>
1. 好像无法支持ffmpeg和gstreamer等
2. 无法支持alsa音频框架，需要另找
3. 网络介入，需要wifi芯片支持指定

是否可以使用双系统，rtthread负责基本音视频，linux负责其他呢？
原有的dev/ioctl/sys/proc等，现在不是内核层的东西，而是bsp模块的接口，内核现在只有最简单的一些机制，而且，已经由posix封装的不错了．其他:
- 共享内存直接可以使用全局共享，可以通过宏直接转换，变量名称直接用key加工就好．
-
机器人、电子设计、智能车大赛(包含且不限于Robocon、Robocup 、RoboMaster、智能车大赛等)　
gdb、valgrind、strace

i2c/spi/i2s调试，信号和协议描述，出问题的诊断;

## 02-01->...
选1-2条感受最深的建议，给年轻程序员?
  a、做事做到极致（点评：短短几个字，做起来不容易，不过还是往这个方向靠）
  b、如果在职场持续走的更远：学历和背景真的很重要（少数人无学历多牛逼多牛逼例子看看就行），专业基础能力看似简单，要修炼的足够硬。（点评：道理都懂，可以当初没人告诉我哇，前半句不能改变，后半句还能改变）
  c、程序员生涯上半场拼的是技术和能力，下半场拼的是业务和价值。（点评：嗯~先记下）
  d、不要太贪念于技术，限制自己在技术思维里。被别人教认知不可怕，可怕的是，不懂别人的认知，还抵触别人的认知，认知不同，格局也不同。（点评：默默吸收）
  e、有付费意识，找人帮忙记得适当时候，帮回去。才会让别人更加认可你。（点评：难，现在很多人觉得帮人是应该的，你要搞付费，那不是割我们韭菜）
  f、职业生涯是马拉松，上半场牛逼，不代表下半场牛逼，身体重要，过度加班消耗透支，迟早要还的 （这个建议，我觉得没啥用，很多人该透支，还是透支，网上有句老话：叫你敢加班到11点，就有人就会加到12点）（点评：确实没啥用，都是泪~）

**02-03**<br>
gdb调试：x/32dw 0xxxxxx


gdb attach


**02-03**<br>


./include/linux/fr.h
./arch/arm/mach-apollo/include/mach/fr.h

kernel中fr_get_ref()函数增加的trace:
```cpp
	if ((ret < 0) && (!strncmp(fr->name, "spk", 3) || !strncmp(fr->name, "mic", 3))) {
		printk(KERN_EMERG "name:%p %s switch:%p size:%d serial:%d"
			"(%p %p %p %p) (%d %d %d %d)\n"
			, _ref, fr->name, fr->buf_st_switch, fr->size, fr->serial_inc
			, fr->ring, fr->latest, fr->oldest, fr->cur
			, fr->state, (int)fr->owner_pid, fr->en_oldest, fr->last_serial);
		printk(KERN_EMERG "fr->ring: %d %p %d %d %d\n"
				, fr->ring->serial, fr->ring->virt_addr
				, (int)fr->ring->phys_addr, fr->ring->state, fr->ring->state_change);
		if (fr->cur)
		printk(KERN_EMERG "fr->cur: %d %p %d %d %d\n"
				, fr->cur->serial, fr->cur->virt_addr
				, (int)fr->cur->phys_addr, fr->cur->state, fr->cur->state_change);
	}
```
## 01-01->...
!!!! 本月，期望能够结束 DMA/CACHE/Scatterlist/dma_mapping/tasklet/workqueue/pl022这几个部分的整理
**01-29**<br>
pip3 安装为什么会安装到.local中呢？ 是否应该全部卸载然后安装到正常路径呢？

**01-28**<br>
芯片文档：　Corona02的地址是svn://192.168.1.14/share/Corona02　Q3F的地址是svn://192.168.1.14/share/Q3FD
nftl NFTL 调试常用命令
```cpp
mount -t yaffs2 /dev/mtdblock0 /config
    [QSDK][ALL][BSP][POWER] 为QSDK增加YAFFS2文件系统支持

rm -fr /config/database;umount /config;reboot;
rm -fr /config/database;reboot;

echo ff > /sys/class/nftl_class/nftl_loglevel
echo 3 > /sys/class/nftl_class/chunkmap_table
echo 2 > /sys/class/nftl_class/chunkmap_table
echo 1 > /sys/class/nftl_class/chunkmap_table
echo 0 > /sys/class/nftl_class/chunkmap_table
echo 1 > /sys/class/nftl_class/lateinit

echo 665 > /sys/class/nftl_class/sect_table
echo 305 > /sys/class/nftl_class/sectmap_table

mkfs.ext4 -b 2048 /dev/snndblock5

mount -t vfat  /dev/mmcblk0p1 /mnt;mount -t ext4 -o discard -O ^has_journal /dev/snndblock5 /config;sync
mount -t vfat  /dev/mmcblk0p1 /mnt;mount -t ext4 -o discard /dev/snndblock5 /config;sync

e2fsck -f -E discard -a /dev/snndblock5

echo f5 > /sys/class/nftl_class/nftl_loglevel

mount -t vfat  /dev/mmcblk0p1 /mnt;
mount -t ext4 -o discard /dev/snndblock5 /config

echo 1 > /sys/class/nftl_class/nftl_loglevel

infotm_nftl_blk_t *infotm_nftl_blk = infotm_nftl_info->infotm_nftl_blk;

mutex_unlock(&infotm_nftl_blk->nftl_lock);

/config/database/img # [ 1626.443333] EXT4-fs (snndblock5): re-mounted. Opts: (null)
[ 1626.469999] EXT4-fs (snndblock5): re-mounted. Opts: (null)
[ 1626.496666] EXT4-fs (mmcblk0p2): re-mounted. Opts: (null)

sync完毕之后，开启log，看看是否有很多数据还在更新

cd /config/database/img;rm -fr 1*;rm -fr 2*;rm -fr 3*;rm -fr 4*;rm -fr 5*
sync;echo ff > /sys/class/nftl_class/nftl_loglevel

cd /config/database/img;rm -fr 1*;rm -fr 2*;rm -fr 3*;sync;reboot;
cd /config/database/img;rm -fr 4*;rm -fr 5*;rm -fr 6*;sync;reboot;
cd /config/database/img;rm -fr 7*;rm -fr 8*;rm -fr 9*;rm -fr 0*;sync;reboot;

/mnt/testspinand 6000;/mnt/testspinand 6000;/mnt/testspinand 6000;sync
/mnt/testspinand 6000;/mnt/testspinand 6000;sync
/mnt/testspinand 6000;sync

date;e2fsck -f -E discard -a /dev/snndblock5;date

rm -fr /config/database;sync;

echo 1 > /sys/class/nftl_class/nftl_loglevel
echo ff > /sys/class/nftl_class/nftl_loglevel

rm -fr 1*;rm -fr 2*;rm -fr 3*;rm -fr 4*;rm -fr 5*;sync;
sleep 5;reboot;

mount -t vfat  /dev/mmcblk0p1 /mnt;mount -t ext4 -o discard /dev/snndblock5 /config;sync
echo ff > /sys/class/nftl_class/nftl_loglevel;rm -fr /config/database/;sync

echo 304 > /sys/class/nftl_class/sectmap_table
cat /sys/class/nftl_class/collect_all

sync;rm -fr /config/database;sync
/mnt/testspinand 6000;/mnt/testspinand 6000;sync;rm -fr /config/database;sync

echo ff > /sys/class/nftl_class/nftl_loglevel
mount -t vfat  /dev/mmcblk0p1 /mnt
mount -t ext4 -o discard -O ^has_journal /dev/snndblock5 /config
ls -l /config/database/img/99


umount /config
mkfs.ext4 -b 2048 /dev/snndblock5
mount -t ext4 -o discard -O ^has_journal /dev/snndblock5 /config

echo 1 > /sys/class/nftl_class/nftl_loglevel

echo ff > /sys/class/nftl_class/nftl_loglevel
e2fsck -f -E discard -a /dev/snndblock5

echo f5 > /sys/class/nftl_class/nftl_loglevel
date;time rm -fr /config/database/;sync;date


sh /mnt/onefile_modify.sh
sh /mnt/modify.sh
echo 2 > /sys/class/nftl_class/chunkmap_table

ls -l | grep "^-" | wc -l

测试的时候，请保证：
１．mkfs.ext4 -b 2048 /dev/snndblock5 -- ext4使用2k块，和nand的sector大小保持一致
２．mount -t ext4 -o discard /dev/snndblock5 /config -- 以确保使能trim功能
３．测试时，调用 echo f5 > /sys/class/nftl_class/nftl_loglevel 开启nftl trace

cat /sys/class/nftl_class/collect_all;sync;echo 2 > /sys/class/nftl_class/chunkmap_table

date;dd if=/dev/mtdblock0 of=/tmp/tmp1 bs=8192 count=2048;date
```

**01-27**<br>
当前的pl330机制，一个通道可以添加两个请求(扩大需要修改不少代码)，LLI模式就是反复交替执行，否则就是只执行一次．可以考虑使用两份相同的请求，交替取得结果，处理的同时完成dma传输以提高效率．

是否可以把nand的query结果在pl330里面处理掉呢？直接在dma层的pl022通道增加简化处理，结果保存在pl330的驱动中，可以阻塞查询nand状态，就绪之后直接执行下一步读取操作．
或者，使用中断机制来处理，因为数据不超过fifo．或者，其他所有的长度不超过fifo的命令，都可以使用fifo．这样，64*2的fifo可以支持大多数的简单操作，而超过的，可以使用dma．就查询命令而言，可以直接在中断下半段判断数据是否正常，然后再次写入命令．
在m25p80层，可以使用查询加读取的混合访问方式，pl022层设置地址，查询状态，完成读取．一次操作搞定的话，效率不会特别低．进一步的优化，可以在pl022层预读取机制，处于预读模式时，每次读取完一个page，直接发布下一个page的地址．这样，可以避免上层处理增加的耦合性．下次读取如果是连续的，那么可以直接查询
nand现在一般读取一次，需要三次查询状态才能完成读取一个page

**01-22 DDR驱动整理**<br>
　x9和x15的ddr是32bits数据总线，q3f是16bits数据总线．所以x9如果只接一个16bits的ddr，dram.reduce_flag应该是0x01.
```cpp
//#define MEMC_DRAM_DATA_WIDTH 32    X9的位宽是32bits
//           AXI-36:2 --> HIF-34:0 地址看起来是这么映射的
//           寻址空间计算：　14+10+3 以及16bits数据宽，为28bits寻址能力．如果要求16bytes一个burst对齐，那么HIF提供24bits就好．
//           但是现在的COL8:9怎么安排的？以及HIF25呢？
//           一个burst8，读取16bytes(4bits)
片选线：　(dram.row + 0x6 + 0x6) = 26，这个是固定的设置，与位宽无关．因为根据row计算得到，我们是否可以确定，12bits就是所有的其他
AXI最小4字节，所以低2位无用，映射为HIF少2位,HIF的bit0对应的应该是4bytes

AXI2对应的HIF0,这对应的是4bytes，而非2或1bytes，而COL0对应的是2bytes,所以，HIF0应该对应COL1，所以才需要shift up.

half bus width时，向上移1bit，比如寄存器中col_b6 确定sdram的COL7
当前，一个burst到底传送多少？16/32?16的话，有4bits无用，那么
//row14, 8bank-3bits, col10
//hif0:1不起作用，2
//外部DDR芯片的位宽，影响到hif的映射；half时，需要
  writel((0x1f00 | (dram.row + 0x6)), ADDR_UMCTL2_ADDRMAP0); //HIF26 片选，对应AXI28，控制256Mbytes
  writel(0x060606, ADDR_UMCTL2_ADDRMAP1); //HIF8:10 选择bank
//dram.reduce_flag = 1
  writel(0,      ADDR_UMCTL2_ADDRMAP2); //HIF2:5 --> col2:5 --> COL3:6
  writel(0x0f0f0000, 	ADDR_UMCTL2_ADDRMAP3); //HIF6:7 --> col6:7 --> COL7:8
  writel(0x0f0f, 	ADDR_UMCTL2_ADDRMAP4);
  writel(0x05050505, ADDR_UMCTL2_ADDRMAP5); //HIF11:22 --> ROW0:11
  writel(0x0f0f0505, ADDR_UMCTL2_ADDRMAP6); //HIF23:24 --> ROW12:13

```
UMCTL2文档P770，
  cfg MSTR reg 中： 1. bit12:13 对应dram.reduce_flag    2. bit16:19 burst_rdwr 控制burst len  3. bit24:25 控制rank个数，00对应１rank，11对应2rank，其他值没有意义．


**01-18**<br>
提交耳机检测问题修正；整理之前已经完成的bug，提交．并继续看dma部分的内容．
添加新的giga nand flash，需要修改配置项目：
make linux-menuconfig, 按次序配置：
使能：　> Device Drivers > Memory Technology Device (MTD) support > NAND Device Support
禁止：　> Device Drivers > Memory Technology Device (MTD) support > Self-contained MTD device drivers > Support most SPI Flash chips (AT26DF, M25P, W25X, ...)
使能：　> Device Drivers > Memory Technology Device (MTD) support > Self-contained MTD device drivers > Support Gigadevice SPINAND flash chip
使能：　> Device Drivers > InfoTM special files and drivers > Infotm common drivers support > Infotm Nandflash ftl SUPPORT
使能：　> Device Drivers > InfoTM special files and drivers > Infotm common drivers support > Infotm SPI support > iMAPx 4-Wire SPI  master driver

**01-13-16**<br>
耳机检测问题，需要整理一下机制．

**01-01**<br>
!!! pl022没有设置dma fifo threshld的寄存器,所以固定的一次传输4个fifo data,无法调整,比如强制设定为8,那么后面4次可能会被填充0.

## 12-01->...
**12-31**<br>
调用module_get_clock(APB_CLK_BASE)函数之后出现crash,非常诡异.

int spi_tranfer_16bit(uint8_t *buf, uint32_t len, uint8_t *addr, uint32_t addr_len
		, uint8_t *command, uint32_t com_len)
{
	volatile short tr_value;
	int status1, max_rxshortnum;
	int cnt = 0, rx_index = 0, tx_index = 0;

	//64 bytes aligned, and change to short number
	max_rxshortnum = ((len+63)/64)*(64/2);
	spi_fifo_clear();

	gpio_out(126, 0);

	tr_value = ((*command)<<8) | addr[0];
	writew(tr_value, SSP_DR_0);
	tr_value = ((addr[1])<<8) | addr[2];
	writew(tr_value, SSP_DR_0);
	writew(0, SSP_DR_0);

	while (tx_index < max_rxshortnum) {
		status1 = readw(SSP_RIS_0);
		if (status1 & (0x1 << 3)) {
			cnt = 32;
			while(cnt-- > 0) {
				writew(0x5555, SSP_DR_0);
			}
			tx_index += 32;
		}
		if (status1 & (0x1 << 2)) {
			cnt = 32;
			while(cnt-- > 0) {
				tmp_rx_buffer[rx_index++] = readw(SSP_DR_0);
			}
		}
	}
	while (rx_index < max_rxshortnum) {
		status1 = readw(SSP_RIS_0);
		if (status1 & (0x1 << 2)) {
			cnt = 32;
			while(cnt-- > 0) {
				tmp_rx_buffer[rx_index++] = readw(SSP_DR_0);
			}
		}
	}
	while (rx_index < (max_rxshortnum+3)) {
		status1 = readw(SSP_SR_0);
		if (status1 & (0x1 << 2)) {
			tmp_rx_buffer[rx_index++] = readw(SSP_DR_0);
		}
	}

	gpio_out(126, 1);

	transfer_rx_bytes(buf, len);
	//printf("test \n");

	return 0;
}


**12-25**<br>
!!!!! 需要注意到的是,hisi也只是mpp部分兼容rtos,其他上层应用并没有.复杂系统的上层开发,比如包含gui和网络/usb/...等等多种硬件平台的时候,工作量很大.

hisi平台, 内存管理系统,看看能否在现有的fr机制基础上提供新的接口.
公共视频缓冲池,感觉可以基于float_fr的机制

**12-22**<br> 请假,看牙,下午带儿子上医院看皮肤
**12-21-24**<br>
Q3F当前编译好的IROM的bin文件为88KB,大概浏览了代码框架,我认为按照当前人力资源情况,我们无法安排重构代码级别的工作计划. 如果需要裁剪IROM,只能从整体结构方面来下手.

当前已经完成的评估有:
1. 采用Thumb-2指令集
原有的代码使用ARM指令集,改为Thumb,代码从88k减小到62k
2. 裁剪掉TT模块
这个模块主要是nor/nand/crypto等的测试,独立于irom的启动管理功能,因而应该可以去掉.裁剪后,代码从62k减小到53k
3. 裁剪掉未调用函数
有部分编译进bin的函数没有被实际调用.修改Makefile裁剪,代码从53k减小到51k
4. trace精简
代码中printf()调用一般包含较长字符信息,如果精简,可以进一步减小空间.做了一个粗暴测试,去掉所有的printf()调用,代码从51k减小到41k,打印信息占用的空间确实偏大了,应该优化一下,预估可以减少4k左右,从51k减小到47k.
5. 去掉aeabi的除法
arm的除法库占用2k+的空间,如果实在需要,可以调整代码,使用自定义除法函数的话,预计可以减小2k左右空间.
当前阶段结论: IROM代码最多可以裁剪到48k左右.
和jim讨论, jim认为我们当前暂时不考虑优化IROM代码, 担心会带来不必要的风险.

**12-18-19**<br>
编写AEC时间延迟估算专利文档
**12-17**<br>
spi-imapx代码跟踪,nand传输慢的原因:每次最多2k,一秒8000个spi消息,开销过大了.要解决这个问题,只有采用直接函数接口调用的方式,避开spi工作队列.第一步先在spi驱动层提供发送和接收的直接函数调用,如果有效,第二步可以在spi驱动层封装nand命令.
**12-10-18**<br>
重新设计基于页映射的FTL算法,并写专利,感觉与主流算法相比还是有些特点的.主要是加入了冷热页管理,并且支持全映射
**12-09**<br>
！！！！！！！ 当前的free树是按照时间戳顺序的么?如果不是，那么会否可能导致一个虚拟快分配的连续两个块倒置呢？
！！！！！！！ 应该增加一个pc平台的nftl monitor，才能更加方便的跟踪解决问题． !!!!!!!!!!!!!!
！！！！！！！ blk_queue_physical_block_size()函数，感觉应该传递2k给上层来避免read-modify-write

！！！！！！！ 实际上，第一个sector完全可以作为日志性质，保存系统完整的使用历史，乃至可以提供系统恢复．因为只有alloc新的块，才需要淘汰原有的块．刚刚被淘汰的块，可以保存上一次操作后的相关信息．
！！！！！！！ 专利要点：１．小文件删除２．启动加速３．满时删除性能优化４．空间利用效率５．读写效率６．

**12-08**<br>
  geriit账户  ( jenkins.ps )  密码( 123456 ) 邮箱账户 ( jenkins.ps@infotm.com )  密码( A100s300)
**12-07**<br>
今天测试dma传输的时间，发现16M的spi_dma时间1s，包装data需要额外1s+,　每次传输等待就绪需要额外的2s, 开销实在太大了．
明天测试，等待传输到底是发送了多少次，会否有不必要的开销．
**12-04**<br>
用superblock保存每个phyblk的ec和ts信息，当然，空闲块的ts有意义么？
**12-03**<br>
比较对象：　１．硬件AEC环路　２．上层软件通过算法来同步． -- 我们的思路，用过dma层对齐，增加一个缓冲区，软件AEC
！！！！！！！ block和core层在写入的时候，不应该割裂开，至少，block应该提示，之后某个块连续写入的总sector数，比如，如果连续63个块，可以直接增加一个新的物理块．根据写入的块，预估本次写完之后的物理块状态，采用最佳sector分配策略．

**12-02**<br>
！！！！！！！ 关于断电安全，是否可以通过增加数据恢复功能的方式来保证呢：　保证每次操作有足够的空闲块；手动触发完全同步，每次上层操作完毕，发布同步命令，下层会写入一个校验通过sector(包含新的映射信息)．下次启动，如果没有发现这个sector，就会从上次的结束点恢复现场．这样，下层支持了断电的保护和数据恢复的功能．类似于用户直接备份系统，做不同的切片．对于nandflash和ftl，这是很方便的一个做法，因为老的数据实际都是在的．也许只是需要备份一下每个vtblk对应的实际phyblk+physect，就可以解决问题了．启动需要恢复数据的时候，根据上一个安全映射，把安全映射之后覆盖的老内容重新写入一次就好了．这个功能能够正常运作的前提是，老的内容没有被覆盖，所以，保证每次操作时有足够的空闲块很重要，系统安排足够大的OP是一个必要条件．另外，提前释放足够的块可能会(在空闲块不够，或者频繁修改的场景)导致块的利用效率有所下降，这是需要提前考虑到的．
**12-01**<br>
xrun问题：
__imapx_feed_hungry_buffer() 函数，好像忘记了判断当前数据长度是否足够．至少需要有两个frame才能启动dma
会否是，需要临界区保护一些和中断共享的数据结构呢？
实际上，我这边无论是q3f平台还是x15平台，都无法重现．但仔细观察trace，发现正常和异常trace之间有一些特殊的差别：第一个音频帧送达之后，正常的trace第一个软中断在28ms之后，异常的在140ms之后．由此，猜测是否由于当前中断太多，软中断的处理被延后了4个frame　或者，打印被　if (last_step != prtd->fr_state)　给丢弃了．
imapx_pcm_trigger

## 11-01->...
**11-30**<br>
imapx_pcm_prepare()　被重复调用了，查清楚是什么触发的；另外，是否增加reset我新的buffer层的操作呢？
**11-29**<br>
关于fat32延迟分配算法，在pc上可能没有什么用处．主要是因为两：１．内存大，应用层可以有足够的缓存 2.硬盘有较大缓存机制，也可以缓解这个问题．而使用flash和sd卡的小内存嵌入式系统，还是需要好好优化的．
**11-28**<br>
根本原因：　写入整个映射表后，一些老块被覆盖和释放了，这部分的映射不应该加载，否则导致这些老块的状态被错误改变．

因为mount只是读取304和305,所以可以有针对的调试了．先看看这两个chunk在不同版本下映射配置有什么区别
  echo 304 > /sys/class/nftl_class/sectmap_table
  echo 305 > /sys/class/nftl_class/sectmap_table
[  219.176666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-1,vtblk:304-56 map:15 mask:ffffffffffffffff
[  219.179999] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-2,vtblk:304-1 map:15 mask:ffffffffffffffff
[  219.183333] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-3,vtblk:304-42 map:15 mask:ffffffffffffffff
[  219.186666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-4,vtblk:304-56 map:15 mask:ffffffffffffffff
[  219.189999] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-5,vtblk:304-1 map:15 mask:ffffffffffffffff
[  219.193333] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-6,vtblk:304-42 map:15 mask:ffffffffffffffff
[  219.196666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-7,vtblk:304-56 map:15 mask:ffffffffffffffff
[  219.199999] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-8,vtblk:304-1 map:15 mask:ffffffffffffffff
[  219.203333] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-9,vtblk:304-42 map:15 mask:ffffffffffffffff
[  219.206666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-10,vtblk:304-56 map:15 mask:ffffffffffffffff
[  219.209999] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-11,vtblk:304--32768 map:16384 mask:00c0000000000000
[  219.213333] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-12,vtblk:304-62 map:15 mask:ffffffffffffffff
[  219.216666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-13,vtblk:304-61 map:15 mask:ffffffffffffffff
[  219.219999] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-14,vtblk:304-40 map:15 mask:00f0000030000000
[  219.223333] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-15,vtblk:304-41 map:15 mask:00f0000030000000
[  219.226666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-16,vtblk:304-42 map:15 mask:00f0000030000000
[  219.229999] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-17,vtblk:304-52 map:15 mask:00f0000030000000
[  219.236666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-18,vtblk:304-56 map:15 mask:00f0000030000000
[  219.243333] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-19,vtblk:304-57 map:15 mask:00f0000030000000
[  219.246666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-20,vtblk:304-58 map:15 mask:00f0000030000000
[  219.249999] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-21,vtblk:304-0 map:15 mask:0000000300c00000
[  219.253333] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-22,vtblk:304-1 map:15 mask:0000000300c00000
[  219.256666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-23,vtblk:304-59 map:15 mask:ffffffffffffffff
[  219.259999] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-24,vtblk:304-53 map:15 mask:ffffffffffffffff
[  219.263333] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-25,vtblk:304-60 map:15 mask:ffffffffffffffff
[  219.266666] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-26,vtblk:304--32768 map:0 mask:70c0000000000000
[  219.269999] [nftl]<__class_dump_phyblk_sectmap,1440>phyblk:771-27,vtblk:304-0 map:15 mask:00000003ffffffff

是否由于当前已经被释放的chunk拥有更高的timestamp，导致无法用771的数据更新它们呢？是否应该增加判断，如果这个oldchunk仍然是属于当前的vtblk的映射，就做比较；否则，在load_fullmapping的时候直接设定为-1就好了．

cho 305 > /sys/c[  807.766666] vtchunk: 304 mapping:
[  807.769999] ( 0: 594,17,f) ( 1: 771,22,f) ( 2: 511, 3,f) ( 3: 511, 4,f) ( 4: 511, 5,f) ( 5: 511, 6,f) ( 6: 511, 7,f) ( 7: 511, 8,f)
[  807.783333] ( 8: 511, 9,f) ( 9: 511,10,f) (10: 511,11,f) (11: 511,12,f) (12: 511,13,f) (13: 511,14,f) (14: 511,15,f) (15: 511,16,f)
[  807.793333] (16: 511,17,f) (17: 511,18,f) (18: 511,19,f) (19: 511,20,f) (20: 511,21,f) (21: 511,22,f) (22: 511,23,f) (23: 511,24,f)
[  807.806666] (24: 511,25,f) (25: 511,26,f) (26: 511,27,f) (27: 511,28,f) (28: 511,29,f) (29: 511,30,f) (30: 511,31,f) (31: 511,32,f)
[  807.819999] (32: 511,33,f) (33: 511,34,f) (34: 511,35,f) (35: 511,36,f) (36: 511,37,f) (37: 511,38,f) (38: 511,39,f) (39: 511,40,f)
[  807.829999] (40: 771,14,f) (41: 342,56,f) (42: 771,16,f) (43: 511,59,f) (44: 511,42,f) (45: 511,43,f) (46: 511,44,f) (47: 511,45,f)
[  807.843333] (48: 511,46,f) (49: 511,47,f) (50: 511,48,f) (51: 511,49,f) (52: 771,17,f) (53: 342,48,f) (54: 771,26,0) (55: 771,26,0)
[  807.853333] (56: 771,18,f) (57: 594,18,f) (58: 594,19,f) (59: 594,20,f) (60: 342,45,f) (61: 640,61,f) (62: 641,40,f)
lass/nftl_class/sectmap_table
/ # echo 305 > /sys/class/nf[  807.869999] vtchunk: 305 mapping:
tl_class/sectmap_table
[  807.873333] ( 0: 145,61,f) ( 1: 145,12,f) ( 2: 145,58,f) ( 3: 145,29,f) ( 4: 145,60,0) ( 5: 145,60,0) ( 6: 145,60,0) ( 7: 145,60,0)
[  807.886666] ( 8: 145,60,0) ( 9: 145,62,f) (10: 145,63,f) (11: 761, 1,f) (12: 761, 2,f) (13: 761, 3,f) (14: 761, 4,f) (15: 761, 5,f)
[  807.896666] (16: 761, 6,f) (17: 761, 7,f) (18: 761, 8,f) (19: 761, 9,f) (20: 761,10,f) (21: 761,11,f) (22: 761,12,f) (23: 761,13,f)
[  807.909999] (24: 761,14,f) (25: 761,15,f) (26: 761,16,f) (27: 761,17,f) (28: 761,18,f) (29: 761,19,f) (30: 761,20,f) (31: 761,21,f)
[  807.919999] (32: 761,22,f) (33: 761,23,f) (34: 761,24,f) (35: 761,25,f) (36: 761,26,f) (37: 761,27,f) (38: 761,28,f) (39: 761,29,f)
[  807.933333] (40: 761,30,f) (41: 761,31,f) (42: 761,32,f) (43: 761,33,f) (44: 761,34,f) (45: 761,35,f) (46: 761,36,f) (47: 761,37,f)
[  807.946666] (48: 761,38,f) (49: 761,39,f) (50: 761,40,f) (51: 761,41,f) (52: 761,42,f) (53: 761,43,f) (54: 761,44,f) (55: 761,45,f)
[  807.956666] (56: 761,46,f) (57: 761,47,f) (58: 761,48,f) (59: 761,49,f) (60: 761,50,f) (61: 761,51,f) (62: 761,52,f)

lass/nftl_class/sectmap_table
/ # echo 305 > /sys/class/nftl_class[   65.913333] vtchunk: 305 mapping:
/sectmap_table


**11-27**<br>
nftl算法的优化：
    ～～～～～　64-63机制还是有必要的，看到不正常关机检测再调用e2fsck就好了，可以加快启动时间；
    加速的方案应该可以关闭的
    建立一个基本的块映射，每个vtblk的最新phyblk+fullmapping_sect，如果不包含fullmapping_sect，就直接定义为最后一个sect．这样，最快的加载方式就是，只读取
        １．这个块映射表(坏块映射到-1)，最慢可能需要64个sector.
        ２．块映射定义的若干个sector.
时间开销：
    最快速度就是64 + 800, 就算是1024吧．　应该是0.4s左右的时间．
    fullmapping_sect 是用来建立两个红黑树，完整映射可以在需要读写的时候再来建立
    每次关机，都需要更新这个块映射表
空间开销：
    一个chunk用于映射表，映射信息单独存在宇哥每个映射块，1-1映射不存在这个mapping.


应该先

[QSDK][ALL][BSP][FILESYSTEM]  为QSDK增加YAFFS2文件系统支持
测试：　建立6000文件，删除，然后重启后比较mapping信息是否一致．
64/32位 << >> 的问题 ,数字需要增加ull后缀
(nftl_oob_info->vt_sect_addr == MULTI_CLEAR_SECT_MASK) 居然失败了，数据类型不一致导致的问题

/mnt/testspinand 6000/12000;sync; 然后删除，重启前后都没有发现映射不一致的问题
/mnt/testspinand 6000;/mnt/testspinand 6000;sync; 以前会删除不干净，现在已经正常了．
/mnt/testspinand 6000;/mnt/testspinand 6000;/mnt/testspinand 6000;sync; 晚上尝试一下．

**11-26**<br>
删除文件的过程中，ctrl+z终止，以及断电，测试确认一下，到底是哪一种．
e2fsck -f -E discard -a /dev/snndblock5   仍然是必须的．

关于之前出错之后有乱码而且cpu占用很高而且spi也在工作的情况，我的分析是这样的：由于断电之类的事件，有大量块对应的文件已经被删除，但是在底层仍然为已分配状态，导致空闲块基本耗尽，这会导致文件系统后续操作由于缺乏缓冲池而出现拷贝风暴，cpu开销大而且spi无法结束工作．对这种情况，如果你手头还有对应的板子，可以采取这样的措施：１． echo 2 > /sys/class/nftl_class/chunkmap_table 查看当下块状态 2. e2fsck -f -E discard -a /dev/snndblock5 强制检查文件系统，释放冗余空间 3. echo 2 > /sys/class/nftl_class/chunkmap_table

之后的测试中，为了应对断电的情况，每次开机都需要用discard选项调用e2fsck．


**11-25**<br>
//尝试使用infotm_nftl_wl_dump_phyblk()函数，清除valid_sects 小 的chunk ，避免出现不必要的长链．另外定义一个函数吧，精简，而不直接drop, 统计裁剪之后，再drop.
//alloc_free_chunk() 函数中清理出新chunk的部分，应该主动在主要入口调用，一定避免进入递归调用．
//少于4个的映射还是直接回收了吧. valid_sects变为0是 discard/write_sect，所以这两个地方可以增加回收，避免clear_sects得不到释放
vt_chunk_noodle是否应该换成list_head来管理呢？现在的太怪了．
然后，增加read/write page出错保护，nand flash毕竟不安全，尽量保护一下．

clear_sects当前的使用方式，如果63sector先写入后删除62个，它的值就是全f少一个bit,这时候，新chunk的clear_sects是1，老chunk的valid_sects是1；　　　然后再写入，若干次后，当最老的chunk已经释放，mask的值中，有多个位的1是当前chunk中并没有对应的sects的，也就是说，它需要clear的对象已经不在了．所以，我们释放chunk，关注的不是mask，也不是clear_sects，而是valid_sects.

一种场景就是，写入低32sects，高33sects设置clear_bits，在dump的时候，这个clear_bits已经没有必要存在了．应该找一个合适的场景的清理这种情况．如果mask是最后写入，并且mask中置位的sect都没有实际内容，那么mask就没有必要再写入了．或者，还是增加一个强化compact的函数吧

vt_ctrl_node->vtchunk_clear_mask 如果并不能清除任何有效mapping的sector，那么，直接重新初始化对应的sect就好了．或者，可以用写入(-1,-1,0)的方式．如果不清除，那么，一旦chunk写满63个，就会出现孤零零的一个mask sector，无法安排以致于极限情况会导致空间崩溃．解决这个问题可以采用的算法：
  １．如果需要释放某个phychunk，并发现它包含mask，直接compact整个vtchunk，最后就不需要写入任何的mapping了；缺点是，可能触发某些不必要的拷贝，导致性能和空间浪费；优点：不容易出错．--- 映射的物理块减少到两个的时候再合并吧．如果这时候只有两个，而且合并当前的到最新的，那么可以减少一部分的拷贝，避免拷贝风暴；同时判断，如果最新块可以容纳，就不需要新申请块，否则申请新的块．-- 总的条件就是，clear_mask非0, 块少于３，而且需要申请新的块的时候，直接compact.
  ２．读取当前映射的所有的phychunk的mapping，如果所有的sector和mask没有重叠，那么就可以删除．缺点：很浪费
  ３．每次discard，或者write之后，判断当前的状态．
  如果dump后当前vtchunk只剩下一个chunk，那么就要判断clear_mask的有效性了．

当static的个数达到总chunk的70%-90%左右的时候，直接compact新clear-mask的映射，其他映射仍然照旧．但这样的话，如果基本上已经满的情况discard，好像会造成拷贝风暴．

latest_chunk_root  vt_ctrl_node->vtchunk_clear_mask
首先就是，如果压了之后只剩下一个chunk的情况，肯定不应该再写入新的clear_mask；当然无法避免之前已经写入．


**11-24**<br>
正常删除后，保留了 304-324 564-629

**11-23**<br>
把删除的chunk扔到unlinked目录，是文件系统级别自动建立一个新的目录么？
统一定义一个mapping 64位，然后每次清理chunk只需要写入一个sect就好．
每次valid_sects小的时候，compact+1个discard sect就好了．
少于16个sect的chunk，可以使用sect映射来管理，超混合模式，可以提升小文件管理的效率．
小文件关怀，启动加速．
-rw-r--r--    1 root     root          3597 Jan  1 00:07 img1000.jpg
-rw-r--r--    1 root     root          3201 Jan  1  1970 img1046.jpg
-rw-r--r--    1 root     root          4001 Jan  1  1970 img1050.jpg
看看时间信息为什么这样，是否覆盖导致的．
**11-21**<br>
!!! 如果修改比较多，小文件比较多还需要经常删除，那么，空闲空间一定要留的足够大，否则，会出现大量重复拷贝．
如果不是最新chunk而有效sectors<=3，那么直接回收了;等当前的回收机制比较完备了再增加这个功能．

percentage of NFTL OP ratio

另一个是驱动优化

在所有分区之外，找两个128k物理块，奇数sect写入开机，偶数sect写入关机前的每个物理块映射信息(vtblk ec ts valid)，可以实现快速开机．问题的关键在于，如果确定这个物理块呢？固定位置如何？不能使用文件系统，因为启动的时候fs无法加载；不能使用vtblk，因为它需要先建立映射才能访问．所以，只有固定物理块这种方式．如果这个块坏掉，可以强制向前挪移一个chunk．可以分出4个，从前到后，根据定义找到当前有效的日志块．　其中的ec ts信息可以从chunk的头部获取到，当然如果不读取头部，可以节省一些时间．　每个节点9个字节，可以安排1０个字节．1024chunk，需要1０k共计５个sect来保存这些信息．增加校验和来保证写入数据的一致性．

如果物理chunk比较多，是否应该分成组进行映射呢？如果page特别多，是否也应该
sect级别的映射，加载消耗实在有点大，能否把sect的信息同步更新到最新的chunk呢？　一个vtblk的，64*(2+2+mapping+ts) 不到一个sect. 能否在每次关机的时候，每个vtblk把最新的映射写入到自己的最新sect呢？如果没有更新的话，不需要写入？？好像有点难，或者，每个新的chunk，第一个sect都写入当前的映射信息，这样，加载的时候只需要加载本chunk的映射就好了．

只有脏vtblk才需要刷新映射信息，而且，映射信息和普通数据有不同的oob标识，所以，如果最后一个mapping总是知道的．关机的时候写入，其他时候不需要管了． -- 条件：１．已经mapped过了的，就是可能有更新的；　２．最新的sect中不包含映射类型sect的，关机时填写一个 3.开机时，读取到这个映射sect的时候自动更新信息，然后就不需要读取后面的phychunk了． 4.

bbt也可以保存下来．

所有的p_map_info->block_mapping相关的内容都需要修改．

**11-20**<br>
增加打印指定块和页的oob数据
增加主动回收机制了：　在每次写入或者clear的时候
写入的时候：　如果clear　sectors已经被写入了很多新的，有效的比例增加了；这时候需要确定，是只写入当前数据，还是备份所有数据．　时间点，可以选择在切换页的时候．

写，并且分配新的块的时候：　判断当前页是否需要回收－－如果空内容＞有效内容，直接拷贝过来，释放所有旧的内容；

__vtmapping_add_new_phyblk()函数中压缩一下自己，释放有效内容少于1/3的所有chunk，可以控制在最多保留两个，触发条件呢：
  １．如果空内容多于有效内容
  ２．

是否应该按照real_sector来控制释放？可以保留real_sector最多一个或者两个的chunk，它可以是次新chunk，然后拷贝其他所有的内容到新分配的chunk，由于保留了一个，所以，应该有机会．

如果空内容比较少，按照老的算法来alloc_free()吧．

每次写满，又一次获得新生的机会，确定之后的主要方向

已经锁定了vtblk:305，只要是对这个chunk的访问，就打印trace.

增加断电测试; 可考虑文件访问中间增加更多延时保证每次测试过程一致，然后用二分法确定多少个

**11-19**<br>
可以考虑之后的优化，同一个chunk的数据先缓存，chunk结束的时候，再同步写入．这样可以采用更好的空间管理方式．

突然出现某个chunk故障如何处理：１．读失败 ２．写失败 ３．erase失败 ４．

__infotm_nftl_compact_vtblk() 函数，如果最新的chunk中，没有被clear,那么就没有必要申请新chunk

infotm_nftl_wl_dump_phyblk()函数中，按照当前算法，绝对不会有discard的标记

infotm_nftl_discard_mark_sect()函数中，处理两个valid_sects会否不妥？重新搬移

**11-18**<br>
删除6000文件需要10分钟左右，这是不合理的．

今天的patch有两个问题：１．clear之后再write，是否应该强制更新vtchunk ２．现在是指望着重启之后e2fsck discard无用的信息，但是如果inode的信息没有被更新，那么e2fsck就没有实际意义，是否应该增加1s延时写入呢？

应该尝试一下，创建　删除　创建　重启　的流程下能否正常．


**11-17**<br>
infotm_nftl_wl_dump_phyblk() 函数的效率，仍然值得怀疑．可能存在不断拷贝的情况．应该是，valid_sects超过一定值之后，直接申请新的chunk；或者，如果拷贝能够在最新phychunk内满足，就直接拷贝，如果不能，就申请新的chunk.

新的版本已经就绪，修正了如下几点：
１．去掉了延迟200ms flush的缓存机制，以免可能出现断电情况下数据不一致
２．修复了一个删除不完整块时可能存在的空间泄露
３．修复了alloc_free_chunk()函数出现递归调用陷入死循环的bug，这是最大可能原因

测试的时候，请保证：
１．mkfs.ext4 -b 2048 /dev/snndblock5 -- ext4使用2k块，和nand的sector大小保持一致
２．mount -t ext4 -o discard /dev/snndblock5 /config -- 以确保使能trim功能
３．测试时，调用 echo f5 > /sys/class/nftl_class/nftl_loglevel 开启nftl trace


**11-16**<br>
nftl增加单元测试：
１．删除一半文件，然后重新写入，反复执行100次
２．dd if=/tmp/tmp1 of=/config/tmpmodi_1 count=1 bs=10240 skip=0 seek=0

cp /tmp/tmp1 /config/tmp_1
sync
dd if=/tmp/tmp1 of=/config/tmp_1 count=1 bs=10240 skip=0 seek=0 conv=notrunc
sync
ls -l

@@@@@@  64->63 sectors改动原因：１．加快加载速度２．需要正确的标识删除动作，真正清除对应的chunk，同时保存ec等信息
  或者，可以依靠每次加载文件系统的时候的discard?或者，写入一个新的clear_sect命令？

根据ｕ 80-20 原理，只要文件内容部分的读取高效就可以了．

11-14测试，被free的chunk出现在rb:2，原因是__vtmapping_sect_register()函数中，把free了的chunk又add_dirty()了

关于提高加载速度的问题，是否可以这样：　最新的chunk中，增加日志信息，每当一个phychunk被drop,记录下来它的id和timestamp等信息，更新映射的时候，只需要读取最新的chunk就可以判断这个phychunk是free的了．每个vtblk都可以使用类似的日志功能来实现空间和性能的折中．或者，简化设计，在第一个sect中，保存当前有效的phychunk，可以进一步节省判断时间．

**11-14**<br>
应该可以增加主动回收机制，如果文件系统统计的占用空间，和实际占用空间不同的时候强制回收，取代开机回收．每次写文件，先写数据，然后写文件管理数据结构，最后更新304/305的文件系统管理信息，所以，如果中间断电，主要是数据chunk失踪
**11-13**<br>

(infotm_nftl_info->OP_chunks_num/4) 这么大的最小冗余并不合适，2-4个应该就好了．

    读取数据的时候，可以给一个大buffer，读取了多个sector之后，flush一下来同步上下层的读写操作

引入 infotm_nftl_info->dirty_list 的原因：　红黑树上按照优先级排序，优先级的影响因素之一是valid_sects，每次写入都会影响到这个优先级，我们不可能每次都重新整理红黑树，所以先把这个phychunk扔到dirty_list，等必要的时候，再转移到红黑树上排序．

一个考虑到的优化点：　如果一次写入多个sector，可以在第一个sect_info中加上sect_num，

**11-12**<br>
vdec.c文件中   vdec_irq_handle()　中断处理函数
dwl_x170_linux_irq.c文件中  DWLWaitDecHwReady() 函数启动等待

infotm_nftl_wl_dump_phyblk() 函数，　怎么感觉可能会拷贝到自己身上呢？好诡异．增加判断，这个chunk不应该是最新的．好像还好，他是从older_chunk_root拿出来的．

**11-11**<br>
_infotm_nftl_write_sect() 函数需要改写，部分修改需要 read-modify-write
infotm_nftl_read_vt_sect() 同样，需要处理mapping和buffer不一致的问题；　可以考虑上层给出的接口是sect对齐的，而且上层自己处理mapping


infotm_nftl_update_sect_trace() 可以作为上下同步的手段，_infotm_nftl_write_sect() 应该有一个当前phychunk的buffer，积攒的数据一次写完．

infotm_nftl_init_bounce_buf()　中，应该加大buffer的大小

一个bug: 新的clear机制，新删除的数据，如果还存在老的块，register的时候还是会被提取出来．是否之后要从list末尾开始register呢？
  要不然就改动一下，通过mapping来判断是否已经被清空，而不是之前的chunk/sect id
  被擦除状态是否可以支持两种：１．当前没有任何sect和它对应 2. 当前至少有一个clear_sect对应，可能还有一个被擦除的sect和它对应．它们的共同之处在于 block_mapping==0，
  或者，可以通过phy_chunk_addr来确认是否可以替换，通过phy_sect_addr是否-1来判断是否被擦除
  或者，增加一个新的状态标记好了

**11-10**<br>

!!!!!!!!!!!!!!!!!为了保证文件系统和底层nftl的数据一致性，是否应该去掉原有的cache机制呢？!!!!!!!!!!!!!!!!!

上次我提到的删除文件时断电可能导致数据不同步，已经解决了．启动的时候，执行　e2fsck -f -E discard -a /dev/snndblock5，可以强制修复这个不同步．

e2fsck加上-f选项，因为断电的时候文件系统未必有错，错的是nftl没有同步；增加的-E discard选项，在进行完整的文件系统检查后，尝试丢弃空闲块和未使用的inode块，这也可以处理断电之类的异常终止带来的空间泄露

我在e2xxx的小工具里，测试了一天代码，完工之后才发现，原来工具本身已经实现了，不过网上是查不到这样的配置建议的，所以自己花的时间还是必要的

小熊爸爸:
ext4文件系统的空间管理比较复杂，有三种用处会预留较大空间：a．预先分配inode节点 b. 预留部分物理块 c.预留日志文件的空间．当你将可用空间用完之后，文件系统会从预留的空间中挤出来一些存储块，所以表现就是可用空间为０，但是还可以拷贝．
仅仅测试性质，并不推荐：你可以试试看 mkfs.ext4 -N 10 -m 0 -O ^has_journal /dev/snndblock5，取消了上面三种预留空间，可用空间增大很多．你可以查看一下mkfs.ext4的参数，看看如何针对自己的系统定制．
ext4的可用空间，应该理解为系统要求你尽量不要超过这个上限．所以，之前的空间大小的困扰，应该不是问题．

擦除的搭配可能情况：
  １．　total 大中小　　   63     32    16
  ２．　擦除内容大中小     超过一半，　　一半左右　，　小于1/4
  ３．　最新chunk剩余空间的情况，只需要考虑不够的情况

几个操作的参数，需要文档化：
  e2fsck  /dev/snndblock5
  //可以强制修复断电关机等时候的数据不同步
  e2fsck -f　-E discard -a /dev/snndblock5
  mkfs.ext4 /dev/snndblock5
  mount -t ext4 -o discard /dev/snndblock5 /config

  echo 0 > /sys/class/nftl_class/nftl_loglevel
  dumpe2fs /dev/snndblock5


**11-09**<br>

部分被删除的sect，重新写入新的映射位置和block_mapping；全部被删除的sect．使用dirty标记，转移完毕之后，清除标记．

clear_flag


好像也应该记录本次被影响的sectors的列表，搬运的时候方便搬运．可以为每个增加一个dirty标记．

ext4文件系统的最小块设置，应该是有影响的吧．如果是2k，那么block_mapping的处理就没有关系．

策略：　不管什么策略，应该是快速收敛的，不能导致搬运风暴．
  １．如果某个老的chunk有sector被删除，就直接清理它，残留的有效sect搬运到新的chunk.
  ２．不管，直接写删除的操作到最新chunk，解析时注意就好
  ３．每次删除，都直接分配一个新的chunk，然后从头开始拷贝；或者

如果block_mapping因为clear动作而变化了，也需要重新写入，好像之前没有注意到这点．注意增加处理．如果和文件系统不一致会导致问题．

可以在每个不同的block(512字节)，写入block的virtual mapping地址，这样，测试就有了衡量的标准了．

可以考虑使用图谱来反映vtblk的占用和映射情况，模仿之前实现的fr的mapping变化情况，每次trace显示与上次之间的差异，会否更加直观呢？

__infotm_nftl_compact_vtblk()函数，先取得最新chunk的id，然后，所以没有映射到这个chunk的sector，都重新拷贝．

使用多个脚本完成测试：
  １．写　２．间隔删除　３．间隔增加　４．全部删除看结果有无泄露


**11-08**<br>

需要增加trace:
  1. 查看单个phychunk的映射信息变化(内存管理数据结构，以及实际物理内存中的值(重启后可以看到))
  2. 全部phychunk的映射情况
  3.

write_sect的trace有遗漏的，原来是判断问题导致cnt==1的无法打印

单元测试：
  1. 空的分区，写入对齐长度不同的文件，分析trace是否符合设计逻辑
  2. 修改指定文件(应该明确知道文件的大小和位置情况)
  3. 删除指定文件，然后写入

更新映射应该是以phychunk为单位，add_new的时候，如果这个chunk之前曾经被解析，那么现在就不会再次解析，咦，这样好像也没错，因为新增的chunk本来就没有内容呢

**11-06**<br>
需要解决一个问题ｉ：　vtblk:写入的操作，打印信息丢失了，影响到逻辑分析
增加命令选项，删除所有分区；之前记得先umount

**11-05**<br>
继续nftl问题．
购买100个静电袋和标签;

alloc_free_chunk()函数出问题的概率最大
__vtmapping_drop_empty_phyblk() 函数，为空映射也会保留一个位置，这是不对的
tmp_phy_blk_node->skip_erase_once 好像可以去掉，换成add_free()函数的参数
alloc_free_chunk() 函数中，add_free__infotm_vtblk_cleanup_phyblk()函数前没有加上skip_erase_once设定，但是应该没有导致问题，因为缺省就是0了
__vtmapping_update_phyblk_sectmap() 函数，可以合并入__vtmapping_update_vtblk_sectmap()，逻辑上更好
__vtmapping_sect_register() 函数中，if (new_phy_chunk_node->e_timestamp <= old_phy_chunk_node->e_timestamp) 的判断，看起来有问题．最新chunk内对同一个vt_sect的更新，后面的page应该可以替换前面的．
__vtmapping_add_vtblk_to_rbtree() 的判断，应该调整一下．
//__vtmapping_drop_empty_phyblk()中vt_chunk_node_prev的判断，是否是因为有些chunk刚被分配给vtchunk，还没有来得及写入内容，这时候，不能直接释放？好奇怪，不应该出现这样的逻辑．
是否应该增加逻辑，一个chunk已经不包含有效内容的时刻，直接add_free()呢？
infotm_nftl_info->discard_clear_chunk()的调用不合适吧．但是，以前删除部分sector的操作方式好像并没有很好的应对过，仔细考虑一下．如果chunk全部内容删除，那么好处理；但如果最新chunk里面有被discard的sector，而整个chunk仍然包含有效数据，那么当前机制下就只能通过创建新的chunk的方式来解决．或者用日志形式的操作来弥补，可以增加一个新的sector映射格式，直接清除掉指定范围的sectors(block+nrblock)．在update sectmap的时候，直接
  １．创建新的chunk来拷贝，这种方式最简单，但在某些场景下可能很浪费 2．扔掉所有老的chunk，其有效内容拷贝到最新chunk，然后，最新chunk中无效内容需要写入新的clear sect命令对消．这种方式不适合最新chunk中有很多无效内容的情况．vt_map_node->phy_chunk_addr 增加-2的设置，表示被擦除的内容; -1表示原本没有内容的情况

infotm_nftl_discard_mark_sect()--> __vtmapping_sect_clear() 后面一定跟着这个chunk的 infotm_nftl_discard_clear_chunk()

增加统计当前chunk中的无效内容，作为判断是否满的重要因子．或者，如果最新chunk中无效的内容超过一半，就另外创建新的chunk.

**11-04**<br>
继续电源管理问题

__vtmapping_drop_empty_phyblk() 函数好像必然会保留一个chunk，这可能导致空间的泄露．
  __infotm_nftl_compact_vtblk -- 要求实现1对1的映射．如果不能把所有数据合并写到最新的chunk，就新建一个
  __infotm_vtblk_cleanup_phyblk  -- 不要求1对1映射．把老的chunk的数据写入到最新chunk，可能需要新建一个
    唯一的调用是add_free()函数中把之前使用率最低的老chunk释放，残留内容全部写入到最新chunk中

检查vt_blk_node = infotm_nftl_info->logicmt[phy_chunk_node->vt_chunk_addr].vt_chunk_noodle;　所有的判断，在discard的时候是否会被设置为NULL;

/sys/class/nftl_class/　::    overwrite_table
    boot_table :: 没用，因为现在已经不会在这里建立映射了

把J6上的锡膏吸掉，要用到松香，会增强张力；
把电流表加入J6，系统启动中止，估计是电压不够；item文件中增加　core.voltage   1.250


进入shell:   113 mA
echo mem > /sys/power/state
__raw_writel(0x1, IO_ADDRESS(SYSMGR_RTC_BASE) + SYS_CFG_CMD);
调用后:   54 mA

RTC CONFIGURE: 0　　SWPB-2 键
        0.25  ->  0.15
RTC CONFIGURE: 1  POWERKEY1 键
        0.25  ->  0.09
RTC CONFIGURE: 2
        直接重新启动了

是否应该打印一下，dirty链表和三个红黑树上的内容，以及不被管理的部分

**先显示所有的vt到phy的chunk映射**<br>
cat /sys/class/nftl_class/chunkmap_table

cat /sys/class/nftl_class/boot_table

echo f5 > /sys/class/nftl_class/nftl_loglevel

echo 207 > /sys/class/nftl_class/sectmap_table  然后从有效的映射中找一个vtchunk显示它的所有sect映射
echo 1 > /sys/class/nftl_class/overwrite_table

为了调试，应该打印每个分区的chunk范围

强制打印trace:
    core_pack_log(TRACE_CTRL_WRITE_SECT, -1, -1, -1);
    core_pack_log(TRACE_CTRL_READ_SECT, -1, -1, -1);


echo 1 > /sys/class/nftl_class/nftl_loglevel

认真跟踪一下，是否缺少临界区保护．
  __del_from_tree()  __del_dirty()

__vtmapping_insert_phyblk() 函数最好是用list标准函数改写；


**11-03**<br>
今天开始阅读nftl的代码

echo mem > /sys/power/state
sudo fastboot flash system ./output/images/burn.ius

把J6上的锡膏吸掉，要用到松香，会增强张力；
把电流表加入J6，系统启动中止，估计是电压不够；item文件中增加　core.voltage   1.250

测量vddc-core电流：
  进入shell:   113 mA
  echo mem > /sys/power/state; 执行__raw_writel(0x1, IO_ADDRESS(SYSMGR_RTC_BASE) + SYS_CFG_CMD); 后 54 mA

**11-02**<br>
电源管理：　ip620x q3f_ip620x_enter_lowpower()函数，RTC先进入sleep状态的话无法操作i2c关闭pmu；先关闭pmu的话无法改变RTC状态，以前的平板系统应该是RTC自带GPIO，在RTC进入sleep状态后自动控制pmu进入sleep状态的，所以没有这个问题．RTC不进入sleep状态的话，会有比较高的漏电流(估计是在RTC和芯片其他部分的接口上)

## 10-01->...
**10-29**<br>
repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b dev_buildroot_a9evb


pm进入sleep状态失败：
  m25p80部分的suspend函数无返回
  usb1.0的suspend对应的usb_suspend_device()函数返回-2
  felix和videobox等，必须禁止，否则无法进入suspend

下一步，进入低功耗模式的时候应该测量一下: -- 已经解决问题swpb-2按键控制复位
  POR信号的电平，是否已经拉低呢;ip620x_reset(); 函数不知道能否完成当前场景的模拟 -- 不需要尝试了; swpb-2 可以控制这个场景

已经可以wake,但是kernel的resume过程总是出现错误
  又一次是sd1的恢复出现问题，所以考虑从flash上启动，避免sd卡的影响

ip6205_resume()出现问题，直接return后，可以进入shell了．

sudo fastboot flash system ./output/images/burn.ius



**10-28**<br>

[anyizhou][Imapx15][IIC]: iic3经常出现卡死不工作情况
Anyizhou反映，某OEM客户反馈大概10%左右机器出现因iic3不工作导致的摄像头无视频问题．电子相框功能切换到预览模式出现问题概率最高，但开机也有较低几率出现．
以前曾经出过多个patch修复了几个iic出错场景，但显然，iic仍然不够稳定，这将会给产品化带来很大风险，必须尽快彻底解决问题．
我这边尝试多种方式，始终无法复现问题，只能通过在客户重现发给我trace分析的方式．为此，在iic驱动中增加了完整的trace机制，当出现iic3访问超时的时候，可以把之前iic设备所有的历史操作和状态信息打印出来，协助分析．
分析最后的打印"state:2 10"，2(寄存器IIC_STATUS的值)表示iic3当前处于"No activity状态"，10(寄存器IIC_RAW_INTR_STAT的值)表示不曾检测到"START"信号．而前一个iic的传输是完全正常的．所以，分析此时iic控制器已经出错．
[  150.539999] seq:1581 --214.182293 ---->>>>>
[  150.543333] seq:1581 --214.182315 isr:10 10 W:3c W:84
[  150.546666] seq:1581 --214.182381 isr:200 510 comp!
[  150.549999] seq:1581 --214.182400 -- state:6 510 <<<<<
[  150.553333] seq:1582 --290.616701 ---->>>>>
[  150.556666] seq:1582 --290.616726 isr:10 10 W:ff W:0
[  150.559999] seq:1582 --291.619348 ----error----
[  150.563333] seq:1582 --291.619363 -- state:2 10 <<<<<
之前花费的大量精力，都是用来避免出现iic出错，但现在看来彻底查清问题的根源非常困难．
最终采取的措施是，当iic3出现错误的时候，iic3软复位并重传．客户测试，没有再次发生无法预览的情况．
中间曾经采取power_down()然后power_on()整个iic控制器的方式，但在多个iic总线的同步上容易出问题．所以最终才采用了软复位的方式
代码已经整理完毕上传：  http://gerrit.in.infotm.com/#/c/17615/

**10-27**<br>
阅读iic代码，补齐文档，更新redmine，上传代码
再次开始安装jenkins服务器，以后千万不能再remove openssl这样瞎搞了
**10-26**<br>
为iic驱动增加完整的trace，增加module_reset()解决了iic3出错的恢复问题
**10-23**<br>
出错的时候：
  clk_disable_unprepare(dev->clk);   module_power_down(SYSMGR_IIC_BASE);
  module_power_on(SYSMGR_IIC_BASE);  clk_prepare_enable(dev->clk);

i2c中断的trace机制：
  一个4k的buffer,一个当前索引index，一个当前seq_number
  确定几个检查点，每个点读取当前时间，然后记录行为，然后打印一行到缓存中
  开始发送的时候，当前seq_number递增
  出错的时候，打印当前buffer中所有的内容
  定义单独的函数:
    void pr_store_iic_trace(char* buf)    备份trace
    void pr_dump_iic_trace()              显示已经备份的所有内容

**10-20**<br>
QTS 服务器 jenkins 123456 : ip  192.168.1.152
当出现错误的时候，应该统计当前已经写入txfifo了什么内容，还剩余多少数据没有发送，当前中断状态，曾经有个什么中断，什么处理，等等。把整个流程记录下来。

安一洲iic问题，是否需要增加一个iic强制从错误设备交互死锁中复位的功能呢？一个时序序列．
  今天提到说，之前wait_for_completion_timeout()问题，是同步启动wifi的时候引入的。

**10-19**<br>
我觉的rx_full的阈值，应该设定为1，逻辑上更好，之后重现问题之后要试试看。
为何iic发送失败呢？１．中断禁止了？　２．增加打印当前状态和中断

安一洲6134json配置选择：
  4   camif_enc_nvp6134_1080p.json
**10-15**<br>
清除启动卡上的IUS信息：
  sudo dd if=/dev/zero of=/dev/sdb bs=512 count=1 seek=32k
  sudo mkfs.vfat /dev/sdb1

**10-14**<br>
在teardown中增加命令行检测，但是发现如果本测试失败，检测代码会直接被跳过，最后添加到testcase最前面，检测命令行：：
  testcase.keywords.create('Run Keyword If', args=["'${ret}'=='False'",'Fatal Error'])

出现过多次AAC编译错误的情况，处理措施包括:
  1. specified sample format s16 is invalid or not supported  在linux需要配置fdk-aac库。fdk-aac要注册在最前面，否则使用的时候，会出现类似的错误好像需要先编译使用fdk-aac
  2. rm -fr .ccache目录
  3. 是否因为在1sproject这个软链接中make导致的呢？

**10-13**<br>
  在out目录下，find . -name *.a -exec ls -l {} \;
重新编译irom代码：
  rm -fr build/arm-infotm-eabi-4.3.3/ out/;make apollo2;make;ll out/irom.bin
  原始，                84352
  去掉cmdline支持，      55480
  去掉linkpc支持，       49916
  去掉secure/ius/isi，  43352
  去掉eeprom/ramdisk，  40900

  如果把所有的打印变成条件编译，可能会有1-3k

## 09-01->...
**09-29**<br>
q3f平台上测试使用:  sudo python3 mylib.py -i apollo-2

查看是否字符串编码格式不匹配：
  pip install chardet
  import chardet
  chardet.detect(keydata)

**09-14**<br>
为x9-evb配置电源，编译新版。尝试了添加nand失败；mmc0好像不稳定，不知道是否是因为电源问题，等电池到了再验证一下；
查到nor型号为`w25x256`, 添加norflash支持需要修改items.itm/ devices.c/ product的缺省config文件;

烧录好了之后仍然无法启动，怀疑是uboot代码需要调整

**09-08**<br>
main() -> try_boot() 函数中：
1. 调用try_get_bl(&mask, &id);从flash读取到 mask = 0x9c0,
2. burn(mask); 判断mask的bit7置位表示禁止mmc1接口启动
之前我们的一些产品，据说启动的时候按住某个按键，才会加载烧录卡；否则就直接从flash启动，你知道这是基于什么机制实现的么？IROM会检测某个GPIO的值？
   make menuconfig > Bootloader > Forbid IROM read SD/TF-card
定义的FASTBOOT_CLASS=0xff 255－vendor specific.厂家的自定义类，主要用于一些特殊的设备。如接口转接卡等。

**09-07**<br>
  内核优化：　可以考虑把网络和相关应用，提前完成。可能需要把内核分成两个部分，部分设备和驱动添加到另外一个队列中，延后加载。如果网络启动够快，可以考虑p2p在a53上完成。是否可以内核中启动一个独立的进程，rootfs加载完毕之后，继续低优先级模块的加载。
  实现上可以增加新的设备延迟启动函数，正常初始化驱动，但在`q3f_init_devices()`函数中去掉这部分的devices，延迟到加载rootfs之后。
  需要问下小辉xr871后来的实现情况：１．p2p在哪里完成的？ ２．还是涂鸦么拆分在a53和871两个部分实现是么？　３．
  ~~~~ norflash太小，但nandflash启动速度的问题也比较麻烦，额可以考虑延后加载nftl，毕竟加载扩展的文件系统之前，这部分初始化没什么用。能否调用的时候动态初始化呢？访问到的文件系统需要。
  ddk_sensor等视频相关驱动，好像是驱动和设备在一个文件中的，一起加载的。这个需要拆分实施
**09-05**<br>
mtd->_writev()　mtd->_readv() 增加sg支持以提高mtd设备访问效率
**09-04**<br>
corona
a53双系统？根据业务情况，确定启动freertos还是linux，如何？
需要一个常驻的tcp连接，所以，m3上需要控制wifi.
wifi唤醒a53后，是否可以启动带网络模块的freertos完成心跳功能？业务有要求的话，可以再次启动linux平台。
ap6181只包括wifi；ap6212包括wifi fm bt三个功能；现在需要了解的是，如果主机的sdio等接口float，会否影响工作。
m3的tcp连接信息，能否转移到a53重建？
## 08-01->...
**08-20**<br>
一个巨大的误会是，千万不要在uboot中根据打印信息的进度确定函数走到哪里了。rx_handler()函数中，没有打印完成oem assign 不是消息的问题，不是fastboot工具的协议的问题，不是uboot大小的问题，只是lp_assign()函数崩溃了。

uboot logo:
**08-19**<br>
uboot logo: 定位到prescaler模块，如果不初始化它，就不会有闪的问题。ratio设置为0可以规避，但是，之后启动GUI的时候还是会出现。
**08-18**<br>

**08-16 08-17**<br>
看代码，发呆
**08-14**<br>
上午继续review audio codec
**08-13**<br>
review音频codec属性和几个evb的应用，为codec ip选型做准备。Q3包含一个audio codec。
**08-12**<br>
测试平台，自动下载代码，逆向跟踪如何支持fastboot功能，和kernel下usb-ffs和system下qlibfastboot有关
**08-11**<br>
langpai在kernel阶段lcd黑屏一下，最终判断是bus3时钟被重新配置的时候，出现问题。
跟踪看clk部分的实现，看能否找到诊断思路
**08-10**<br>
review corona功能定义. 文档位置：　svn://192.168.1.14/share/Crona02
imapx_clock_init   q3f_init_irq   imapx15_machine_init
m3:
    没看到M3有DMA控制器
    参考xr871，最高频率192Mhz, 能否尽量提高到150~192Mhz
    是否设计有GPIO管脚支持唤醒功能，比如语音唤醒、wifi唤醒，这在类似的产品中比较常见
a53:
    4 lines spi好像没有留足够的线 ？需要6 pins，只看到ssp0的4 pins
    六通道DMA控制器是否足够？现在常用的有：音频*2 spi0*2 spi1*2 mem-mem拷贝*1等
    会否有双音频接口的需求

    如果只有m3带sd卡，那么大概只方便支持fat文件系统
mailbox，使用中断方式，还是dma传输，多大的buffer，大概访问速度
如果使用srgb接口，要求更高的pixel-clk时钟频率，最高输出时钟频率75MHz，如何？

phy和sd0是功能互斥的，产品需要存储音视频的时候，放弃
4路DVP接口输入情况下，如果需要SRGB输出， PCM0 UART0 UART2 PWM_TOUT2 接口不能使用
4路DVP接口对应需要4个接口么，或者说CAM_DATA0-1 CAM_DATA12-15并不会使用，所以i2c2/4/5是不受影响的？

m3的主要负载: 1. sd 存储音视频 2. sdio 网络链接 3. ssp 代码 4. uart 串口 5. mailbox 6. ADC

ddr不能关闭的话，省电一般；ddr的启动时间可能


## 07-01->...
**07-20**<br>
串口被玩断了，然后因为三根线是漆包线，一直没有联通
郎派的问题:
上午收到平台，串口的接口现在还没有输出，有一个工程师正在看，所以我还没有跟进软件的分析。
从芯片角度，能否增加如下的对比测试验证： 1.VDD_IO VDD_CORE VDD_LPDDR 三个电压的电流(功耗)情况对比测试 2.正常情况下芯片表面的温度情况。 另外就是我们是否可以做几个尝试，看芯片的表现有何变化： 降低core/DDR的频率、以及降低core/DDR的电压。

通过完成一些组合测试，可以帮助芯片部门定位问题情况。

启动之后降低cpu频率。

另外，去年贵司报告类似问题的时候描述过： 本次生产5000套PCBA，测试中有53PCS不良，其中18PCS经维修判定是Q3S内部短路造成，大电流1PCS，DRAM错误的2PCS，DDR错误的12PCS，其他20PCS。烦请贵公司分析原因，并更换同数量的新主控Q3S。谢谢！！！

我想请问，当时是如何判断18PCS是Q3S内部短路的，以及如何判断12PCS是DDR错误的？

控制core频率的是： soc.cpu.freq    -300，实际频率为 1032+(-300) = 732
控制DDR频率的是：  dram.freq        444

希望能够先用 -708 和 100 作为参数测试一下效果

## 06-01->...
**06-29**<br>
上午，应该增加uboot阶段寄存器打印功能；另外，对比我的3510E和C25表现差别，看看到底为了什么缘故。
终于发现，c25不行，3510e 3520e都没有问题

**06-28**<br>
上午重装win10电脑，在ubuntu上安装virtualbox，终于解决了bios配置和sudo问题导致的失败
下午，在uboot中增加i2s_init()函数，尝试在uboot阶段播放声音。代码就绪。
**06-23**<br>
上午，11点左右给小蚁整理的nand flash完毕；安一洲的板子tf插槽仍然有问题。
发现发回给安一洲的板子实际是好的，因为我把uboot的mmc驱动给关闭了，但irom的mmc驱动为何不能正常工作呢？
QTS的工具里面有个转换脚本，将sh还是txt文件转换成robot文件

**06-22**<br>
giga nand flash烧录item文件失败，上午发现vtblk 0被映射到了0x3ff，然后erase nand 失败。估计是硬件问题。下午考虑了各种方案，最终都失败；继续整理代码。
**06-20**<br>
陈登-导航 套用了和客户相同的寄存器配置，但是我这边仍然有声音。请客户发板子过来测试
开始给小蚁整理nand flash的东西
**06-17**<br>
小蚁平台，１．板子通过wifi链接路由器失败，但手机可以，最后发现是路由器禁止了icmp，而板子使用了icmp协议。２．ota升级后env丢失的机器客户寄回来了一台，根据开机log看，确实整个env 部分被擦掉。我们的机器码也保存在env，env被擦掉后机器人就没法用了，机器人和服务器交互就是靠机器码来识别的。现在已经解决，在reboot 的时候加了不允许有写flash的机制，两台机器人老化了一晚上，分别老化了310次ota升级，没有出问题，周末继续老化观察，应该解决了

**06-16**<br>
安一洲平台，芯片上有些NC 的脚，外部能不能接地，以增加芯片的散热．以前我们不用的这种脚，都可以接地，以增加散热。和芯片确认，这些pad和内部电路是不相连的，所以可以接地
**06-15**<br>
安一洲平台，工作时，电流越来越大的问题：　
１．我短时测试了一下，确实有这样的趋势，判断应该和温度的上升有关，因为断电然后立刻重启之后电流仍然会保持比较高，断电休息几分钟之后再启动电流就降下去一些。那么有两种可能：1. 给cpu的供电电压随时间在升高，导致cpu耗电增加 2. cpu温度上升导致的耗电增加。麻烦对比测量一下cpu开始的几个供电电压，我们先定位一下问题。
２．我查了一下一般的显卡和pc cpu的情况，都会存在随着芯片温度上升功耗同步增大的情况。这是一种正常情况。



**06-08**<br>
招聘需要慎重，单单口头效果不行。两个办法：１．增加笔试；２．上机解决问题

## 04-01->...
**04-08**<br>
今日体会：
  1.驱动部分每个模块应该增加初始化和外部控制的相应trace，方便问题的分析和定位
  2.每个模块trace可以动态开关
  3.内核增加对自己每个模块工作状态的记录，可以方便的查询；否则就要提供足够详尽的文档，描述如何查看每个模块
**04-07**<br>
eventhub基本搞定，估计会解决掉客户的问题，今天继续功耗问题。解决eventhub问题的基本体会是，所有的分支都应该加上trace.按照消息流动的次序增加trace
**04-06**<br>
加班，eventhub的eventhub.c改变数据结构
**04-04**<br>
加班，eventhub的libevent.c改变数据结构
**04-03**<br>
int event_destory_msgqueue()
    int msgid = -1;
    msgid = msgget(getpid(), 0777);
    if (msgid > 0)
        msgctl(msgid, IPC_RMID, NULL);
    return 0;
**04-02**<br>
http://res.xyirobot.com/kr3/cnword/pronunciation/xiaoyi_588zofelwis.mp3
http://res.xyirobot.com/kr3/cnword/pronunciation/1726hvpdetli.mp3

echo 3 > /proc/sys/vm/drop_caches
cat /proc/meminfo

精简掉所有不用的驱动模块。
spi1 mmc2

我这边优化了一下内核之后，可以大概节省4.5M内存出来。
items.itm文件中增加：  cevadsp.enable    0 ；新增这项配置是为了在uboot和kernel中去除为cevadsp分配的内存
int calc_dram_M(void)
spl_printf("dram_size: %d\n", dram_size);

unsigned char __initdata __800_480_bmp[] = {

modified: bootloader/apollo2/src/boot_main.c
modified: kernel/arch/arm/mach-q3f/mach-q3f.c
modified: kernel/drivers/infotm/q3f/display/implementation/module/logo/kernel_logo_800_480.h

items.itm文件中增加：  cevadsp.enable    0 ；新增这项配置是为了在uboot和kernel中去除为cevadsp分配的内存

**04-01**<br>
希望下一步，可以直接在基于同一个代码编译不同的product,用什么办法呢？1.软连接代码到不同的目录不知道是否可行呢？ 可行的。
  make menuconfig -> Filesystem images -> tar the target filesystem -> Compression method (随意)


    /dev/ttyUSB1
串口的设置
    | A -    Serial Device      : /dev/ttyUSB0                              |
    | B - Lockfile Location     : /var/lock                                 |
    | C -   Callin Program      :                                           |
    | D -  Callout Program      :                                           |
    | E -    Bps/Par/Bits       : 115200 8N1                                |
    | F - Hardware Flow Control : No                                        |
    | G - Software Flow Control : No                                        |

## 03-01->...
stop
delete
media
new
queue /mnt/sd0/MKV023_AAC.mkv
play

new
queue /mnt/tj.mp4
play
queue /mnt/sd0/MKV005_Cooker.mkv
play
queue /mnt/sd0/030-AVC-PCM-1920x1088.MOV
play
queue /mnt/025-airkiller_AVC-FLAC-1920x1080.mkv
play
queue /mnt/026-MPEG-4--AAC-720x480.mkv
play
queue /mnt/027-pandera-AVC-AAC-1920x1080.mov
play
queue /mnt/028-MPEG-4--Qdesign2-640x480.mov
play
queue /mnt/MKV026_AAC.mkv
play
new
queue /mnt/sd0/Video_20_1080P_VC1_AAC_8M_24F.mkv
play

new
queue /mnt/MKV026_AAC.mkv
play

new
queue /mnt/sd0/tj.mp4
play


stop
delete


photo
new
queue /mnt/sd0/1.jpg
play

queue /mnt/pao_mo.aac
play
queue /mnt/give_me_love_tank.aac
play
queue /mnt/17452--AAC 64 44.1tian_lan_lan.aac
play
queue /mnt/yi_ge_ren_shi_yi.aac
play

videoboxd
sleep 1
vplayer

**03-31**<br>
电脑:
登录名:         yuan
密码:        infotm1bsp

邮箱:
登录名:   eric.yun@infotm.com
密码:         Infotm123

REDMINE帐号
登录名:        eric.yun
密码:         mPRCAAFVMH

gerrit登录地址:
登录名:        eric.yun
密码:           637004

工作服务器:
登录名:  ssh eric.yun@192.168.0.14
密码:           123456


先安装jre（已有jre的跳过） 打开终端输入java -version，如果java未安装，则会提示找不到java指令，然后建议你安装列出的软件包，建议选择安装openjdk的jre。 安装完成后再输入java -version，测试一下jre是否安装成功...sudo apt install openjdk-9-jre-headless

创建一个启动器，类型为应用程序，名称随便填，命令写java -jar /home/yuan/SmartIM-App.jar。注意jar的路径要是绝对路径哦。 然后就能像在windows下面一样双击运行了，是不是很方便？

java -jar /home/yuan/SmartIM-App.jar

功耗问题：
双核固件					单核固件
条件：光PCBA
名称	电压（V）	电流（mA）	备注		名称	电压（V）	电流（mA）
总电源输入	12	　263			　总电源输入	12	　　249
VCC-CPU	　1.2	600		　　	VCC-CPU	  1.2	　　500
					             　VCC-DDR	　 1.56	　140
					               　VCC-3V   3.4	　 190	最大到230
卡在root 的正版 100mA， 整板，包括指示灯，
不启动应用是300mA。 整板，包括指示灯，
启动正常的390mA， 整板，包括指示灯，
耗电问题三大重点：１．显示fb的dma ２．wifi部分的工作　３．sensor相关

功耗问题：
  echo standby > /sys/power/state
  echo freeze > /sys/power/state
  echo standby > /sys/power/state
  CONFIG_PM  CONFIG_PM_SLEEP
  搜索　 struct dev_pm_ops 可以得到更加全面的功耗情况。
  SET_SYSTEM_SLEEP_PM_OPS(pl022_suspend, pl022_resume)

功耗管理这部分我还不熟悉。

按照我的理解：　暂时不考虑cpu降频，因为根据测试结果做出简单计算，一个核100mA(1.2v)，cpu其他部分400ms，优先考虑功能模块的管理情况，尤其是这些模块还直接控制着它连接的设备的工作状态。

浏览了一些驱动模块，大部分都包含省电模式的代码，在我的EVB上尝试了一下，"echo freeze > /sys/power/state"应该是可以用来进入省电模式，但我这边出错直接返回了，请刘工先在板上试下，给我你们板子出错的trace.

双核版本，在内核启动的若干个点，比如每次初始化一个新的设备，等待一段时间，测试电流。

module_power_on(SYSMGR_PWM_BASE);


方便的话再做一个测试：卡在boot阶段时候VCC-CPU的电流。我主要是需要一个判断基准，来确定思路。

第一个，显示模块
如果你们最看重的是屏幕显示时间的话，有两个建议：
１．mdec和vdec_g1和videobox，全部延时到屏幕显示之后启动
２．当前doorbell进程中tuya的操作，是否阻塞了启动的流程，从而延后了屏幕显示时间呢？如果是，能否后台启动一个线程来启动tuya？tuya大部分都是网络操作，io多而cpu占用少，和gui刚好相反。

read_sect
spiblock_normal_read_multisect
read_page

**03-30**<br>
配置8388:
codec.model  	es8388
codec.clk 		imap-audio-clk
codec.ctrl		i2c.1
codec.data  	i2s.0
sound.speaker 	pads.108

开机时间：
  １．Starting mdev new...　应该可以拉倒后面
  ２．

kernel 4秒

[03-30 17:02:57.046] [    2.946666] [gslX681]-Enter gsl_ts_init
[03-30 17:02:57.046] [    2.949999] [gslX681] Enter gsl_ts_probe
[03-30 17:02:57.046] [    2.949999] input: gslx681 as /devices/platform/imap-iic.2/i2c-2/2-0040/input/input2
[03-30 17:02:57.076] [    4.059999] i2c-core: driver [gslx681] using legacy suspend method
[03-30 17:02:57.076] [    4.059999] i2c-core: driver [gslx681] using legacy resume method
[03-30 17:02:57.076] [    4.059999] [gslX681]-i2c_add_driver return 0


你找到static struct amba_device *amba_devs[]，从中把imap_ssp1_device注释掉吧，省点系统启动时间和内存资源

```cpp
mount -t debugfs none  /sys/kernel/debug
cat /sys/kernel/debug/clk/clk_summary

   clock                        enable_cnt  prepare_cnt  rate
---------------------------------------------------------------------
 osc-clk                        5           5            12000000
    vpll                        1           1            792000000
       ddr-phy                  0           0            396000000
    epll                        11          11           1188000000
       mipi-dphy-pix            0           0            1188000000
       mipi-dphy-ref            0           0            27843750
       mipi-dphy-con            0           0            27843750
       ids1-tvif                0           0            148500000
       ids1-ods                 0           0            237600000
       ids1-eitf                0           0            148500000
       ids0-tvif                1           1            148500000
       ids0-ods                 1           1            148500000
       ids0-eitf                1           1            51652173
       bus6                     4           4            169714285
          sdmmc2                1           1            169714285
          sdmmc1                1           1            169714285
          sdmmc0                0           0            169714285
          usb-otg               0           0            169714285
          usb-ehci              1           1            169714285
          usb-ohci              1           1            169714285
       bus3                     0           0            1188000000
          gpu                   0           0            1188000000
       bus2                     0           0            297000000
          crypto-dma            0           0            297000000
          gps                   0           0            297000000
          ids1                  0           0            297000000
       bus1                     1           1            297000000
          ids0                  1           1            297000000
       uart                     1           2            297000000
       uart3                    1           1            297000000
       uart2                    1           1            297000000
       uart1                    1           1            297000000
       uart0                    1           1            297000000
       nand-ecc                 0           0            396000000
    dpll                        6           6            1536000000
       crypto                   0           0            153600000
       sata-phy                 0           0            1536000000
       clk-out1                 0           0            1536000000
       clk-out0                 0           0            1536000000
       audio-clk                1           1            61440000
       spdif                    0           0            61440000
       sd-mmc2                  1           1            96000000
       sd-mmc1                  1           1            96000000
       sd-mmc0                  0           0            96000000
       isp-osd                  0           0            256000000
       bus7                     0           0            256000000
          eth                   0           0            256000000
          sata                  0           0            256000000
          nandflash             0           0            256000000
       bus5                     0           0            153600000
          camif                 0           0            153600000
          tsif                  0           0            153600000
          mipi-csi              0           0            153600000
          isp                   0           0            153600000
       bus4                     2           2            348000000
          venc                  1           1            348000000
          vdec                  2           2            348000000
       usb-ref                  3           3            24000000
       hdmi                     0           0            24000000
    apll                        7           7            564000000
       dmic                     0           0            56400000
       touch screen             1           1            564000000
       camo                     1           1            8812500
       apb_pclk                 12          14           70500000
          tsc-ctrl              1           1            70500000
          uart-core             0           0            70500000
          keyboard              0           0            70500000
          simc1                 0           0            70500000
          simc0                 0           0            70500000
          cmn-timer1            0           0            70500000
          cmn-timer0            1           1            70500000
          watch-dog             0           0            70500000
          spi2                  0           0            70500000
          spi1                  1           1            70500000
          spi0                  1           1            70500000
          i2c3                  1           1            70500000
          i2c2                  1           1            70500000
          i2c1                  1           1            70500000
          i2c0                  1           1            70500000
          pwm                   1           1            70500000
          pwm4                  0           0            70500000
          pwm3                  0           0            70500000
          pwm2                  0           0            70500000
          pwm1                  0           0            70500000
          pwm0                  0           0            70500000
          ps2-1                 0           0            70500000
          ps2-0                 0           0            70500000
          sysm                  0           0            70500000
          rtc                   0           0            70500000
          cpu-core              0           0            70500000
          dma                   1           1            70500000
          gpio                  0           0            70500000
          spdif-core            0           0            70500000
          pcm1                  0           0            70500000
          pcm0                  0           0            70500000
          iis                   1           1            70500000
       smp_twd                  1           1            70500000
       cpu-clk                  1           1            564000000
       gtm-clk                  1           1            70500000
```
/mnt/MKV026_AAC.mkv
/mnt/tj.mp4
./stress --vm 1 --vm-bytes 35M &
./stress --io 1 --vm 1 --vm-bytes 40M &
abctrl apicall -L 1ffff
mount -t vfat /dev/mmcblk0p1 /mnt
cd /mnt
vplayer


video_rec.json

pl022->dma_cb_flag = 1; 应该换成是atomic的。

```cpp
	struct spi_message *msg = pl022->cur_msg;
	struct dma_chan *chan = pl022->dma_rx_channel;
	dma_addr_t src, dst;
	int delta = 0;

	if (pl022->use_rx_sglist) {
		if (test_cnt++ > 100) {
			terminate_dma(pl022);
			configure_dma(pl022);
			test_cnt = 0;
			printk(KERN_EMERG "reset_dma!!\n");
			return;
		}

		chan->device->device_dma_getposition(chan, &src, &dst);
		delta = (int)dst - (int)sg_phys(pl022->rx_sgl);
		if (delta != pl022->rx_sgl->length) {
			terminate_dma(pl022);
			configure_dma(pl022);
		}
	}
```

**03-28**<br>
mkfs.fat /dev/spiblock2

mount -t ext2 /dev/spiblock2 /mnt

最后出现的打印是符合预期的：
  e0:1,1170 1170,1170 116f,1170 116f.825c3ff8 825c4000


**03-27**<br>
下面几个问题：
  １．　IMAPX_SSP0_TX,IMAPX_SSP0_RX,　感觉pl330的发布顺序乱了，很奇怪
  ２．　发送完毕之后，如果后面因为上层控制不好，导致还有message，现在处理机制是否有问题呢
  ３．　双份读取？？ spiblock_fs_read_multisect, 1033 (20544 8)　---- seg:1 blk:20544 nblk:8 read 6073 us
```cpp
pl330_update()
  _start(thrd);
  _callback(rqdone, PL330_ERR_NONE);
    dma_pl330_rqcb();
      tasklet_schedule(&pch->task);
        pl330_tasklet()
          pl330_chan_ctrl(pch->pl330_chid, PL330_OP_START);
          free_desc_list(&list);
```
有时候只看到rx的callback，没有tx的，是否应该两个都有了再启动下一次传输呢？

一个pl330基本流程：
[    4.359999] sid:1->0 32 1
[    4.359999] sid:0->1 1024 0
[    4.363333] _start id:0 err:1 step:1!!! _start()函数在中断中被调用 当前状态：PL330_STATE_STOPPED
[    4.363333] _start id:1 err:1 step:1!!!
[    4.363333] peri:1
[    4.363333] dma_pl330_rqcb
[    4.363333] peri:0
[    4.363333] dma_pl330_rqcb
[    4.366666]    eid:1->0 1 1
[    4.369999]    eid:0->1 1 0


wait_for_completion_timeout()　函数也许可以实现重传。

pl022_unprepare_transfer_hardware()函数中，可能之后需要增加一些出错处理。
pl022_runtime_suspend() pl022_runtime_resume()　这两个动态开关的玩意，会否有影响呢？

重要线索：
    不是应该先发送，后接收么？现在的过程好像不是这样子：应该是1 0 1 0
    然后会否两者之间的时间差比较大，导致溢出呢？
[2020-03-27 14:36:12] [    4.089999] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.089999] sid:0 32
[2020-03-27 14:36:12] [    4.093333] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.093333] sid:1 1024
[2020-03-27 14:36:12] [    4.096666] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.096666] eid:0 1
[2020-03-27 14:36:12] [    4.099999] pl330_chan_ctrl, 2123, die 2!!!
[2020-03-27 14:36:12] [    4.099999] add blk err: 228 161 20
[2020-03-27 14:36:12] [    4.103333] pl330_chan_ctrl, 2123, die 2!!!
[2020-03-27 14:36:12] [    4.106666] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.106666] pl330_chan_ctrl, 2123, die 0!!!
[2020-03-27 14:36:12] [    4.106666] sid:0 32
[2020-03-27 14:36:12] [    4.106666] eid:1 1024


**03-26**<br>
make linux-menuconfig:
    为squashfs使能"Use 4K device block size?"选项
items.itm文件中：
    system.11231.fs 改成 system.11231.normal
kernel部分：
    modified:   drivers/dma/pl330.c
    modified:   drivers/infotm/common/ftl/spi_ftl/spi_block.c
    modified:   drivers/infotm/common/spi/spi-pl022.c
    modified:   drivers/mtd/devices/m25p80.c
    modified:   include/linux/dmaengine.h
system部分：
    modified:   qlibupgrade/ius_util.c
    modified:   qlibupgrade/libupgrade.c
    modified:   qlibupgrade/spiblk_util.c

kernel部分：
    modified:   drivers/infotm/common/fr/fr-core.c
    modified:   include/linux/fr.h

**03-25**<br>
spi-block.c 文件
  mtd->erasesize : 64k
  spi_info->writesize : 512
  mtd->size : 16777216
  spi_info->bootblock : 69
  spi_info->normalblock : 204

	printk(KERN_EMERG "spi_info :: (%d %d %d %d %d) (%d %d)\n"
		, spi_info->accessibleblocks, size_in_blk
		, mtd->erasesize, spi_info->writesize, (int)mtd->size
		, spi_info->bootblock, spi_info->normalblock);

**03-23**<br>
考虑一下，那些应用应该在pc建立模拟器呢：
  FTL算法的进一步开发应该移植到pc平台更加方便一些，除了调试更加方便快捷，还可以更加方便的制造各种测试场景。
  minigui?

增加_suspend()和_resume()两个函数，可以用来控制数据传输的开始和结束。在这中间的所有的sub_m25p80_read()函数调用，转换为一次统一传输。m25p80增加一个全局变量的spi_message，一条spi_message可以支持最高8个transfer(和pl022匹配)

制作文件系统的参数，-b 改变的话对性能应该有影响：
  mksquashfs/opt/Hisi/Hi3519/Hi3519V101_SDK_V1.0.2.0/osdrv/pub/rootfs_uclibc_big-little3519_wqw.sqhfs -b 65536 -comp xz

当前配置命令，好像使用的默认逻辑块大小128k：
/home/yuan/work/x15_cus1/output/host/usr/bin/mksquashfs /home/yuan/work/x15_cus1/output/system /home/yuan/work/x15_cus1/output/images/rootfs.squashfs -noappend -comp

针对nandflash访问问题，应该增加写后校验，增加坏块管理，增加读次数检测。

**03-21**<br>
下面这个地址，有代码可以挪用：
  https://www.cnblogs.com/mengfanrong/p/5239633.html

**03-18**<br>
改变线程优先级:
  struct sched_param sched;
  sched.sched_priority = 90;
  pthread_setschedparam(pthread_self(), SCHED_RR, &sched);

开发一个系统资源监控器，cpu/mem/中断/flash/sdio/wifi/eth/.../等等的统计信息。

bootloader/apollo2
kernel/arch/arm/mach-q3f/devices.c 　中，和　spi_nand_gd5f_flash_info　定义相关的部分
kernel/drivers/infotm/common/spi_nftl/
kernel/drivers/mtd/devices/giga_spinand/

**03-17**<br>
ffmpeg出错callback函数机制，可以选择控制每个操作允许的错误上限，不知道最终是否可行。
```cpp
 #define DEMUX_STOP_DET_ERR       -2
 #define DEMUX_START_DET_ERR      0
 #define DEMUX_FRAME_ERROR_THLD   20  //if demux_get_frame() have too much error, exit.
 #define DEMUX_INIT_ERROR_THLD    300 //if demux_init() have too much error, exit.
static int DemuxIntCallback(void *ctx)
{
    //static int test_counter = 0;
    //printf("%d\n", test_counter++);
    if (ProcDemuxErrorCnter++ < ProcDemuxErrorThld)
        return 0;
    pthread_testcancel();
    return 1;
}
ProcDemuxErrorThld = DEMUX_INIT_ERROR_THLD;
    ProcDemuxErrorCnter = 0;
    pDemux =  demux_init(file->file, DemuxIntCallback);

  ProcDemuxErrorThld = DEMUX_FRAME_ERROR_THLD;
    ProcDemuxErrorCnter = 0;
    ret = demux_get_frame(this->DemuxInstance, &frame);
```

软件著作权文档格式：
1. 项目背景
2. 软件功能介绍
3. 软件特性介绍
4. 系统物理结构
5. 系统总结构　：　系统框架图，描述几个主要子模块，系统总的流程图
6. 系统主要子系统
7. 算法设计
8. 接口设计
9. 系统出错处理设计
10. 系统维护设计

音频文档格式：　背景和介绍　需求和功能设计　主要系统模块设计　算法和数据结构　通道管理流程　通道数据流程　软件测试

videobox_repath("/root/.videobox/jpeg.json");
init_photo_player_info(&playerInfo);
videobox_repath("/root/.videobox/video.json");
init_player_info(&playerInfo, 0);

make menuconfig 这个要关掉
　# BR2_LINUX_KERNEL_INSTALL_TARGET is not set

调试发现：　seek之后，之前的所有frame的时间戳信息都是无效的，应该要设置
!!!!!!!!!!!!!!!  /mnt/sd0/030-AVC-PCM-1920x1088.MOV 这个文件的音频格式根本不需要codec的。
SetWorkingState()　存在机制性问题，线程无论如何，不应该自己确定状态。
!!!!!!!!!!!!!!!!!!! 音频和视频AQ VQ差别很大的时候，是否播放不同步的问题比较严重呢？

0316 -- 新的patch。和周六上午提交的patch相比，增加了和刘工周六调试完毕的几个fix，然后只是把tab转成了4个空格以统一代码风格。现在代码策略就是先稳定下来。

photo
new
queue /mnt/sd0/3.jpg
play


**03-14**<br>
　#define VBERR_FR_INTERRUPTED "get fr buffer interrupted"

	sleep(2);
	vplay_media_info_t stMediaFileInfo;
    memset(&stMediaFileInfo, 0, sizeof(stMediaFileInfo));
	vplay_control_player(*pstPlayer, VPLAY_PLAYER_QUERY_MEDIA_INFO, &stMediaFileInfo);
	value = (int)stMediaFileInfo.time_length - 2000;
	printf("&&&&&&&&&&&&&&&&&&&&&&&&& seek to %d\n", value);
	vplay_control_player(*pstPlayer, VPLAY_PLAYER_SEEK, &value);

问题75/83/85/88/90，请验证
问题75，请验证。只有025视频seek失败，请另外专为025建立BUG降低优先级延后处理
问题84，改进了机制，会只播放音乐，不解码视频。 -- 026视频播放问题延后解决
问题85，卡住的问题已经解决。 -- AC3不支持问题延后解决。

问题81，我无法重现，请在出现问题的时候抓个audiobox的完整trace.
问题66/69/79下周跟进
建议相关音频视频无法播放问题另外单独建立新BUG管理，并降低优先级。

另外增加的内容：
调整了音频通道启动方式，解决之前有时候出现的xrun问题，可能会对减少切换后杂音有帮助

**03-13**<br>
OpenNextMediaDemuxer() 函数，应该把结束当前和开始下一个严格分开处理，否则逻辑会有点混乱。
外部消息发送到末尾，内部消息的优先级应该高一点，发送到头部，这样只要一个普通的临界区就可以保护好消息的次序了，不会被外部消息插入到连续的两个内部消息中间。
几个需要发送消息给自己的场景
  QPlayer::Play() 失败
      OpenNextMediaDemuxer()失败，发送stop消息
  QPlayer::StepDisplay()　失败，发送stop消息
  当前播放文件结束，发送play消息，结束当前播放下一个
fr_get_float_remain() 函数可以改造一下，如果满，就返回0xffff

**03-12**<br>
增加状态机机制来支持qplayer工作(参数不能太多)：

```cpp
std::list <VPlayerCommand>     *PMesgList;
    this->PMesgList = new std::list<VPlayerCommand>();
	this->PMesgList->empty();
    this->PMesgList->clear();
    delete this->PMesgList;
    this->CurFile = this->PMesgList->front();
    this->PMesgList->pop_front();
    this->PMesgList->push_back(fileInfo);
    this->PMesgList->size()
    this->PMesgList->clear();

	vplay_file_info_t fileinfo;
	int index = 0;

	for(auto it = this->PFileList->begin();it!=this->PFileList->end();it++){
		fileinfo = *it;
		if (memcmp(fileinfo.file, file, strlen(file)) == 0) {
			pthread_mutex_lock(&this->MesgListLock);
			this->PFileList->erase(it);
			pthread_mutex_unlock(&this->MesgListLock);
			LOGGER_INFO("file %s removed!\n", fileinfo.file);
			break;
		}
    }
	for(auto it = this->PFileList->begin();it!=this->PFileList->end();it++){
		fileinfo = *it;
		LOGGER_INFO("InList:%d %s\n", index, fileinfo.file);
		index++;
    }

    return 1;

  int i;
  char lowfile[8];
	for (i=(strlen(file)-4); i <= strlen(file); i++)
       lowfile[i] = tolower(file[i]);
```
**03-11**<br>
！！！！！！！！！！　AC3音频暂时不支持可好？
！！！！！！！！！！　昨天的补丁pause，会卡住，没有复现
！！！！！！！！！！　增加自动播放完毕自动停止的功能
！！！！！！！！！！　双核是否没有真正的发挥作用？　可以把中断引导到不同的内核。那么spi中断是否也可以呢？
spi是否可以使用16bits的处理呢？
现在的jpg机制重新调整之后，应该可以了。
1920x1088 2100x1400.jpg 宽高比不同
通过互斥锁和消息队列结合完成，play/stop/pasue/seek/continue 发送消息并且通过返回变量来得到返回值，所有的命令都加上锁。
QueryMediaFileInfo　需要用到动态变化可能变为空的指针，所以，用消息
或者可以考虑两个队列，一个专门用来保存返回的内容，这样，好像就完美的模拟了进程间rpc机制了。
基本的机制就是：　发送消息，等待自己消息队列中的返回。

！！！！！！！！！！需要考虑处理
          vplay_control_player 的行为，最好还是改为消息的格式来完成。应该增加一些消息，每个命令对应一个消息。
          播放完毕，应该进入stop状态，但是现在没有啊。现在明显的，外部改变全局变量的行为，也会造成不良影响。！！！！！！！！！
          如果所有线程进入pause状态，是否应该不要再打印统计信息呢？
          play命令应该增加返回：
          解析aac失败的文件，测试一下，返回错误。
          对于不支持的或者是解析错误的格式，应该finish，并返回错误代码
          播放出错了之后，及时结束；并且不要因为太多打印而卡顿不休。
          遇到一个audio的xrun，我判断是因为线程优先级比较低，发送了第一个帧之后，后续帧没有跟上，所以，应该保证读取了三个帧之后或者文件结束

int *ptr = (int *)this->VideoBuffer;
printf("%s: header: (0x%x > 0x%x) (%x %x %x %x)\n"
			, __func__, size, size
			, ptr[0], ptr[1], ptr[2], ptr[3]);

`[Switching to LWP 982]`　－－　`info threads` 查看到当前线程为demuxer,　`bt`看到当前出问题的函数是`free()`，从`/usr/lib/libavcodec.so.57`中被调用。 `WorkLoop,534 header:1 0, frames:0`的打印显示，dec线程必然会立刻停止。

**03-10**<br>
QPlayer::Play()函数应该包涵QPlayer::Stop()函数，逻辑上是正常的。

**03-09**<br>
解码器打印
  struct timespec ts;
  clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
  uint64_t currenttime = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
  LOGE("delay too big, cur:%lld %lld %lld, %lld %lld\n"
								, currenttime, m_stPTS.u64timebase, m_stPTS.u64ptsbase
								, m_stPTS.u64lastpts
								, m_u64timestamp[m_s32PicDecodeNum]);
增加以下处理：
  int audio_pause_channel(int handle, int flag)

VplayTimeStamp::
  this->PlayTs = ts; //　pts时间轴
  this->LastGetTs = SysTime; // 系统时间轴
  this->CurSysTs = SysTime;

VplayTimeStamp::UpdateTs
this->VPlayTs.Start();的调用地点，是否现在太早了

如果frame类型动态变化，可以考虑增加新的动态调整机制。
播放过程中，设置IsAudioMute，之后的音视频同步可能会有问题，应该设置的是audiobox的mute，而不是qplayer的mute. 创建通道时候需要判断，播放过程中这个函数直接配置到音频部分去。


**03-06**<br>
1. 解决了seek问题，需要修正libdemux库
2.
bool QPlayer::StepDisplay()
{
	if(this->OpenNextMediaDemuxer() == false) {
		LOGGER_ERR("open next media file error\n");
        return false;
	}
    LOGGER_INFO("Start step display!\n");
	if (!this->IsStepDisplay) {
		this->SetWorkingState(ThreadingState::Pause);
		this->SetWorkingState(ThreadingState::Pause);
		this->SetWorkingState(ThreadingState::Pause);

		this->IsStepDisplay = true;
		this->SetWorkingState(ThreadingState::Start);
		this->PSpeedCtrl->SetWorkingState(ThreadingState::Start);
	}

    return true;
}

**03-05**<br>
测试停止的地方，应该是音频通道创建了不应该的
[2020-03-05 23:50:13.029] INFO<lib/qplayer.cpp,1518>: Decfr:(d:20,l:26),VFr:20(0),AFr:  0(-1),VQ:20,AQ: -1,V:876 800, pos(2043/133285),fault(0 0 40 0 0)
[2020-03-05 23:50:14.846] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:22(0),AFr:  0(-1),VQ:18,AQ: -1,V:876 800, pos(3046/133285),fault(0 0 48 0 0)
[2020-03-05 23:50:15.863] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:26(0),AFr:  0(-1),VQ:20,AQ: -1,V:876 800, pos(4063/133285),fault(0 0 64 0 0)
[2020-03-05 23:50:16.867] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:22(0),AFr:  0(-1),VQ:18,AQ: -1,V:792 800, pos(5066/133285),fault(0 0 72 0 0)
[2020-03-05 23:50:17.870] INFO<lib/qplayer.cpp,1518>: Decfr:(d:24,l:26),VFr:23(0),AFr:  0(-1),VQ:17,AQ: -1,V:792 800, pos(6070/133285),fault(0 0 81 0 0)
[2020-03-05 23:50:18.937] INFO<lib/qplayer.cpp,1518>: Decfr:(d:26,l:26),VFr:26(0),AFr:  0(-1),VQ:17,AQ: -1,V:668 800, pos(7137/133285),fault(0 0 92 0 0)
[2020-03-05 23:50:19.806] INFO<lib/qplayer.cpp,1585>: vplay player control ->2
[2020-03-05 23:50:19.811] INFO<lib/qplayer.cpp,1036>: ~~~~~~~~~ stop player step
[2020-03-05 23:50:19.819] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12160(demuxer)
[2020-03-05 23:50:19.833] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12170(vplayer)

正常的流程：
[2020-03-05 23:50:11.123] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12160(demuxer)
[2020-03-05 23:50:11.136] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x12170(vplayer)
[2020-03-05 23:50:11.150] INFO<lib/threadcore.cpp,178>: State changed To:3, thread 0x2fc320(aplayer)
[2020-03-05 23:50:11.157] <audio_pause_channel,720>: Critical:audio flush channel:0 ok
[2020-03-05 23:50:11.187] INFO<lib/qplayer.cpp,1044>: ~~~~~~~~~ stop player step
[2020-03-05 23:50:11.192] INFO<lib/qplayer.cpp,1381>: release audio codecs


**03-04**<br>
modified:
  /system/videobox/IPU/VDECODER/VDecoder.cpp
  /system/videobox/IPU/VDECODER/VDecoder.h
  /kernel/drivers/infotm/common/fr/fr-core.c
  /kernel/include/linux/fr.h

  cp -fr ./drivers/infotm/common/fr/fr-core.c ~/Downloads/0305patch/
  cp -fr ./include/linux/fr.h ~/Downloads/0305patch/
  /kernel/include/linux/fr.h

销毁audio和video对象的时候，析构函数中stop之
make hlibunitrace-rebuild
**03-03**<br>
加快stop速度的方法：
1. 保证vdecoder已经停止，并且flush所有的视频帧，现在可能不能保证这一点
2. 优先停止读取文件，然后清空两个媒体流，然后清空音频和视频的播放缓存。
3.

上次建议增加的 audio_pause_channel()　函数有bug，所以现在先去掉了调用.　audiobox 启动时候的buffer，切换视频时需要播放完，所以会影响到反应时间，我会之后处理掉audio_pause_channel()函数的bug来解决这个问题。

当前的qplayer，根本没有等待qaudioplay退出就开始了下一个的工作，这是需要马上改变的。

**03-02**<br>
解码器几个bug:
1. 进入stop状态之后，应该保证把之前所有的frame清空，否则，老的frame影响到新的decoder的行为。类似while ((fr_get_float_remain(&stRef) > 0) && m_s32RunState == EM_VDEC_STOP)肯定是有问题的。
2. 之前所述的else if(HeaderUserflag)判断，导致bufferIn可能会指向上一个被访问的frame.
3. 两处可能的死循环
4. if (++nstops == 1)分支中的VDecReset();调用，实在莫名奇妙。
5. 设置状态和解码id的方式太粗暴
6.

解码器应该增加播放速度控制，增加

qlibvplay模块优化
现状：从客户反馈以及我们自己对代码的审核，建议重构qplayer，而qrecorder部分基本保持现状。对qlayer部分，第一步的优化建议
向前兼容，完全保持之前的api接口，解决结构不合理导致的bug和效率问题。

qplayer第一步优化内容：
1. 为threadcore增加新状态,避免每个loop只处理一个帧的低效情况
2. 调整trace机制，方便后续的开发和支持
3. 删除所有timestamp相关的变量和函数，比如 QPlayer::VPlayTs SpeedCtrl::PVPlayTs 以及相关的辅助内容
4. 去除对class Statistics的引用，因为其统计内容大部无用，而且实现方式麻烦，用新的方式替换
5. 基本保持

AddStreamEndDummy()函数中需要一个时间戳，可以直接使用上一个帧加5
建议在解码器部分增加播放速度控制的机制，而不是qplayer


**03-01**<br>
应该是等待所有的视频播放完毕，然后发送播放结束消息。判断的标准，应该是缓冲区中剩余帧为0或者１

播放完毕，应该先关闭原有的demux，然后在没隔一段年时间，判断是否准备就绪。

fr_get_buf()函数原本通过fr_buf_set_state()调用，阻塞等待获取缓存，float类型没有类似的机制，导致出现bug.

[2020-02-29 11:45:57] [   47.223333] !!!!!!!!!!!!!!!!!! failed to alloc float buf:name:dec0-stream remain:19 size:1048576, pbuf:180224 vbuf:3149824!

简历相关
毕业后先后在迪比特电子、UT斯达康、敏迅通讯从事过硬件、驱动和通信协议软件的开发，奠定了扎实的技术基础。

2011年作为技术核心参与创办上海伟视清数字技术有限公司，整体负责硬盘录像机和摄像机产品的软件开发工作。在领导团队进行开发工作时，非常注重产品性能和稳定性和关键新功能的开发，打下了坚实的产品基础，这保证了伟视清一直到现在都能在安防市场的残酷竞争中保有一席之地。

2017年加入盈方微电子从事BSP开发工作，致力于深入优化自己所涉及的每一个模块，有效的提高了产品稳定性和音频、回声消除、存储等方面的性能

在公司的三年，主要致力于优化自己所涉及的每一个模块，有效的提高了产品性能和稳定性，主要有：
1. 音频系统的重构，AEC功能的评估测试和优化等
2. BSP存储部分的优化，如提高MMC、SPI接口性能和稳定性，重构nftl算法，为fat32增加延迟分配算法等
3. 内核和uboot启动加速优化
4. 设计基于全志xr871和盈方微Q3f的门铃项目Demo，freertos到盈方微Q3f的移植

一种可能的场景：head占用了剩下的刚好1M中的一个PAGE，然后，后面的一个帧获取内存失败。

float部分使用好像有点问题，

## 02-01->...

**02-28**<br>

if (PPGetResult(m_stPPInst) != PP_OK)
{
  continue;
} 有bug吧,进去了就是死循环

while (m_s32RunState == EM_VDEC_PAUSE) //加的位置有点销魂

void QPlayer::UpdateAllStatics()
{
	if(this->PDemuxVideoInfo != NULL) {
		this->stat.UpdateFifoInfo(PACKET_TYPE_VIDEO,this->PVideoFrFifo->GetQueueSize()
			,this->PVideoFrFifo->GetDropFrameSize());
	}
　#ifdef ENABLE_AUDIO
	if(this->PDemuxAudioInfo != NULL)
		this->stat.UpdateFifoInfo(PACKET_TYPE_AUDIO,this->PAudioFrFifo->GetQueueSize()
			,this->PAudioFrFifo->GetDropFrameSize());
　#endif
    this->stat.UpdatePacketPTS(PACKET_TYPE_AUDIO,this->VPlayTs.GetTs(this->PlaySpeed));
	this->stat.UpdatePacketPTS(PACKET_TYPE_VIDEO, this->PSpeedCtrl->VideoFrame.timestamp);
}

**02-27**<br>
QPlayer::WorkingThreadTask()　函数中，　判断1s时间到的时候，打印状态统计信息。打印的时候去获取数据，而不是每个frame注册改动，太傻了

m_bHeaderflag 和 HeaderUserflag　都是 true的情况下，dec会执行两次动作：
第一次
  SetVDecInput(m_pu8StreamHeader, (u32)m_pu8StreamHeader, m_s32StreamHeaderLen);
第二次
  SetVDecInput(bufferIn.fr_buf.virt_addr, (u32)bufferIn.fr_buf.phys_addr, bufferIn.fr_buf.size);
  但需要注意的是，bufferIn = m_pstDecBuf->GetReferenceBuffer(&bufferIn);　在第一步并没有被执行，所以，bufferIn　使用的是上个frame的数据
**02-26**<br>
和万虎交接显示相关的内容；display2无人使用，主要是兼容各个平台的需要
继续调试float fr的bug

音视频的编解码，应该和读文件放在不同的线程中吧。读文件应该是一个简单任务。

QPlayer::Stop()中，this->PVideoFrFifo->Flush();this->PAudioFrFifo->Flush();都只能清除本地的fr缓存，无法清除videobox audiobox中已经缓存的帧，所以，QAudioPlayer::ThreadPostStopHook()中audio_put_channel()阻塞调用的结果就是，上层需要等待audiobox播放完毕，才能结束qaudioplay线程。如果是qplayer;:stop命令，那么，应该调用audio_pause_channel(CHAN_PAUSE_FLUSH);

vplay_control_player()函数中，应该增加一个event_regisyter的机制；消息中，增加一个传递字符串的消息，然后可以编辑脚本，发送一个个测试命令，比原有的控制台解析更加方便一些。

float类型，drop和nodrop两种，估计是对应enc和dec两种的，fr_get_float()函数需要考虑这两种情况

fr_get_ref()函数中,两次wait_event_interruptible_timeout()应该改成一次， 对应wake_up_interruptible(&fr->serial_update);和fr->serial_inc

**02-25**<br>
继续调试float fr的bug
**02-24**<br>
if((curTs -  this->LastTs) > 30000) 就改变player线程的优先级，看起来很二
QPlayer::Stop(void) 的实现中，音视频的停止效率差，不应该绑定join()动作；同样的，pause等动作也不应该是阻塞等待式的．
感觉，音视频的demux应该使用两个独立的读取线程，而不是现在这样的
qaudioplayer的workingtask, 应该是持续把所有音频数据送到audiobox，而不是中间usleep(1000);
线程间同步，考虑使用signal或者semphore之类的，而不是低效的轮询模式；状态机需要重新整理，太乱了
vplay_delete_player()函数，free(player);之后修改可能导致crash.
ENABLE_AUDIO 这个宏实在定义的莫名其妙
QPlayer::WorkingThreadTask()　一次调用，应该可以读取多个frame
每个线程，应该增加一个cnt和一个step，以确定当前线程或者说对象的工作状态．
create kworker/1:1H, nice: -20, cpumask: 0x2，　这个打印是调试信息，下个版本去掉、kernel/workqueue.c中
SpeedCtrl::WorkingThreadTask()的逻辑，应该是检查fr的缓冲区，有数据的话才尝试写入，否则休眠等待。

无用代码： frfifoloop.cpp qcodecs.cpp
录音代码： mediamuxer.cpp apicalleraudio.cpp apicallerextra.cpp apicallervideo.cpp qrecorder.cpp
放音代码： qaudioplayer.cpp speedctrl.cpp
共用代码： common.cpp threadcore.cpp qmediafifo.cpp

**02-22**<br>
SpeedCtrl类中，调用Prepare()函数，this->SetWorkingState(ThreadingState::Standby);　启动线程．但是在LoopThreadFunction()　函数中，线程首次启动之后usleep(50000);是不合理的．
abctrl apicall -L 1ffff
**02-21**<br>
mkdir -p /mnt/sd0
mount -t vfat /dev/mmcblk0p1 /mnt/sd0
cd /mnt/sd0
sleep 1
cp video.json /root/.videobox/path.json
vplayer

printk(KERN_EMERG "\n\n!!!!!!!!!!! 2 !!!!!!!!!!!!\n\n");

播放完毕之后没有可切换文件和播放完毕之后有，处理是不同的。

new
queue /mnt/sd0/tj.mp4
play

this->PVideoFrFifo->GetQueueSize()

seek 170000

**02-20**<br>
md文档转换为word格式的方法：1. atom中，md转html  2. LibreWriter中，html转docx 3. LibreWriter中，docx中调整所有图片，这样会移除原有的image链接地址，并替换掉图片原有的svg格式

安一周项目kernel启动优化点：
[2020-02-14 22:25:42:191] [    0.533333] imapfb init
[2020-02-14 22:25:42:628] [    0.893333] [dss][abstraction] <error> terminal_configure: Terminal lcd_panel not found.

[2020-02-14 22:25:43:542] [    1.666666] nvp6134_probe 1580
[2020-02-14 22:25:44:855] [    2.946666] [nvp6134_init 1271] camif open...

[2020-02-14 22:25:44:995] [    3.089999] es8388_probe() es8388_reset OK!
[2020-02-14 22:25:45:722] [    3.816666] es8388_set_bias_level

唯一的剩余提速可能调试失败了：　chip_info->ctrl_len　设定为１６位．可以设定为，dma模式下使用16位模式，这样，一次可以拷贝的数据更多，应该可以容纳更快的速度吧．
static void do_force_width(struct pl022 *pl022, int enable_16bits)
{
	int bits;

	struct chip_data *chip = pl022->cur_chip;

	if (enable_16bits) {
		if (chip->n_bytes != 2) {
			bits = 16;
			chip->n_bytes = 2;
			chip->read = READING_U16;
			chip->write = WRITING_U16;
			SSP_WRITE_BITS(chip->cr0, bits - 1, SSP_CR0_MASK_DSS, 0);
			writew(chip->cr0, SSP_CR0(pl022->virtbase));
		}
	} else {
		if (chip->n_bytes != 1) {
			bits = 8;
			chip->n_bytes = 1;
			chip->read = READING_U8;
			chip->write = WRITING_U8;
			SSP_WRITE_BITS(chip->cr0, bits - 1, SSP_CR0_MASK_DSS, 0);
			writew(chip->cr0, SSP_CR0(pl022->virtbase));
		}
	}
}
unsigned int bits = spi->bits_per_word;

**02-19**<br>

**02-17**<br>
张江4标搬家，找电脑和盘点零部件；
**02-14**<br>
音频处理部分，应该增加对时间戳和帧率的显示和监测
env分区的内容：　86 fd ae 36 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

touch /tmp/uboot
time dd if=/dev/spiblock0 of=/tmp/uboot bs=4096 count=1
hexdump /tmp/uboot -n 256

time dd if=/dev/spiblock0 of=/dev/null bs=4096 count=1024
time dd if=/dev/spiblock0 of=/dev/null bs=1024 count=4096
real  0m 12.8 --> 1.58s

cat /proc/kmsg

**02-13**<br>
为了更加自由的使用aec功能，增加调用下面函数，设定aec处理的时候右声道为有效mic通道：
   audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_REFCHAN, 1);

可以尝试下面场景，对比分析一下结果：
1. 底层设置16k采样率，配置 audio_set_aecfreq("default_mic", 16000);
2. 底层设置8k采样率，配置 audio_set_aecfreq("default_mic", 8000);

改变aec的参考音延时，可能会影响到aec效果：
audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_V2DELAY, 400);
audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_V2DELAY, 800);
．．．
audio_set_single_devpara("default_mic", DEV_SETTING_INDEX_AEC_V2DELAY, 3000);

**02-12**<br>
软件著作权：　ＩＵＷ　WINDOW平台升级
1. videobox　2. audiobox　3. vplayer　4. vrecorder　5. 无人机软件包　6. 儿童故事机软件包　　7. eventhub　8. IQ调试工具
9. 鱼眼矫正工具　10.智能门铃软件包　11. Sensor bridge　12. FTL　13. FR内存管理　14. 人脸侦测优化　15. mv的移动侦测
16. 影子端口　17. G2D　18. 显示模块　19. 电子防抖　20. 旋转功能　21. H264智能P帧　22. 智能码率控制
 ---- 分类管理 ---- ：
1. videobox　2. audiobox　3. vplayer/vrecorder　4. FR内存管理　5. 电子防抖　6. 旋转功能　7. H264智能P帧　8. 智能码率控制
7. eventhub　8. IQ调试工具　9. 鱼眼矫正工具　10.智能门铃软件包　11. Sensor bridge　12. FTL　14. 人脸侦测优化
15. mv的移动侦测　16. 影子端口　17. G2D　18. 显示模块

我的：　　audiobox　vplayer  vrecorder ftl
万虎的：　FR内存管理  eventhub　G2D　显示模块


eventhub　

贵司文档中提到: "文档提供设计手册的应有软件完整的总体设计描述、总体结构和模块设计、功能分配、各项功能与程序结构关系、软件设计流程图"
请问下，对软件设计说明文档的内容和格式是否有强制要求呢？比如说我现在已经有了一个软件文档，但内容上并不是按照上述的方式组织的，那么我需要重构或重新写文档么？

1）要安装最新的，先要卸载之前的版本：[1]
sudo apt-get remove firefox
2）然后在terminal中运行：
cd /opt/ （在这个目录下解压文件）
sudo tar xvf ~/Downloads/firefox-73.0.tar.bz2
sudo ln -s /opt/firefox/firefox /usr/bin/firefox (把firefox链接到/usr/bin/下面）
3）然后，
cd /usr/share/applications
sudo gedit firefox.desktop
 在firefox.desktop里面写上：
[Desktop Entry]
Name=firefox
Comment=firefox
Exec=/opt/firefox/firefox
Icon=/opt/firefox/browser/chrome/icons/default/default128.png
Terminal=false
Type=Application
Categories=Application;
Encoding=UTF-8
StartupNotify=true
**02-11**<br>

打印env部分配置，以确认当前代码是否有问题：
	printk(KERN_EMERG "envirment: \n");
	for(i=0;i<CONFIG_ENV_SIZE;) {
		printk(KERN_EMERG " %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x"
				" %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x"
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]
			,env_data[i++],env_data[i++],env_data[i++],env_data[i++]);
	}
	printk(KERN_EMERG "envirment: \n");

## 01-02->...
**01-20**<br>
  基本模块：　flash/spi/ftl/mtd/block
**01-19**<br>
触摸屏明显存在性能问题：
  [01-19 20:51:36.402] [    3.849999] [gslX681]-Enter gsl_ts_init
  [01-19 20:51:36.402] [    3.856666] [gslX681] Enter gsl_ts_probe
  [01-19 20:51:36.410] [    3.863333] input: gslx681 as /devices/platform/imap-iic.2/i2c-2/2-0040/input/input2
  [01-19 20:51:37.529] [    5.299999] i2c-core: driver [gslx681] using legacy suspend method
  [01-19 20:51:37.548] [    5.303333] i2c-core: driver [gslx681] using legacy resume method
  [01-19 20:51:37.549] [    5.306666] [gslX681]-i2c_add_driver return 0

显卡驱动明显存在优化空间：

已经尝试的优化：
１．uboot提升spi时钟速度之后，加载kernel加快了2s，这个已经实现；
２．kernel压缩算法从xz改成lzo，应该可以提速2s，但因为flash空间不够，无法实现；

make menuconfig 建议优化配置：
建议１：QSDK options-> Libs -> libffmpeg，是否有些codecs可以精简节省大小
建议２：Filesystem images-> squashfs target filesystem, 压缩算法使用xz对加载应用程序到内存的速度，影响很大
建议３：QSDK options-> Apps -> Videobox, 是否有些IPU可以精简掉

make linux-menuconfig 考虑优化配置：
建议１：File systems-> Miscellaneous filesystems-> SquashFS 4.0, 压缩算法从xz改为lzo，还有use 4k，都能提高读取应用程序速度
建议２：确认drivers/infotm/imapx15/display/implementation/module/logo
建议３：如果没有用到sdio wifi，可以关闭 InfoTM MMC2(SDIO) Driver enable
建议４：没必要开 CMA_MIGRATE_OFF

我用你们发过来的linuxconfig信息编译了一下代码，检查我这边内核编译的二进制目标中，下面这些请考虑优化：
1. size: 1850482 1月  20 09:05 ./drivers/infotm/imapx15/display/implementation/module/logo/built-in.o
2. size: 449429 1月  20 09:06 ./net/ipv6/built-in.o
3. size: 542489 1月  20 09:06 ./net/mac80211/built-in.o
4. size: 121007 1月  20 09:06 ./net/xfrm/built-in.o
5. size: 216682 1月  20 09:05 ./fs/ext3/built-in.o
6. size: 165830 1月  20 09:05 ./fs/jffs2/built-in.o
7. size: 113011 1月  20 09:05 ./fs/ntfs/built-in.o
8. size: 564175 1月  20 09:05 ./fs/ext4/built-in.o
9. size: 131880 1月  20 09:05 ./fs/jbd2/built-in.o
10. 62445 1月  20 09:05 ./fs/ext2/built-in.o
11. 98592 1月  20 09:05 ./fs/exfat/built-in.o

**01-18**<br>
**01-17**<br>
**01-16**<br>
上午儿子打电话，一个人到军区大院玩去了，得意洋洋的

.max_speed_hz = 27000000, 可以考虑提升频率

dma调试，可以查看１. 当前目标或者源地址;2. 通道状态 3.中断和其他标记; 3.loop counter 4.

flash_dma_reset()函数中，重新初始化ssp会导致加载uboot和item失败，下一步可以打印所有的ssp寄存器，确认一组正确的值．

ssp 寄存器列表：
  step 1: ( 0,cc7)( 4,  a)( 8, ff)( c,  3)(10,  2)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)
  step 2: ( 0,  0)( 4,  0)( 8,  0)( c,  3)(10,  0)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)
  step 3: ( 0,cc7)( 4,  8)( 8,  0)( c,  3)(10,  2)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)
  step 4: ( 0,cc7)( 4,  8)( 8,  0)( c,  3)(10,  2)(14,  0)(18,  8)(1c,  0)(20,  0)(24,  0)(28,  0)

dma传输过程中，读取　SSP_SR_0　为 3

**01-15**<br>
调试uboot问题的时候, 可以修改 system_update_upgrade() 函数,
需要10项软件著作权，才可以申请高新技术企业．模块包含1500行以上代码就可以申请
1. audiobox 框架 2. AEC 3. FTL 4. videobox 5. 影子端口 6. FR内存管理 7. 人脸侦测优化 8. sensor bridge
9. 鱼眼矫正 10. 视频播放 11. 视频录像 12. mv的移动侦测

**01-14**<br>
分解任务, 建立了几个bug, 安一周的问题分出去
**01-13**<br>
浏览平台软件release的文档, 了解
**01-12**<br>
周日加班. 早起到六院挂号, 结果周日确实是没有门诊的, 网上的信息真是坑人啊.
晚上公司聚会. jim胆结石, 对酒精也过敏.
好好思考一下, 提供什么样的接口给客户:
  就上层应用而言, 最好是一个单独的image, 但这样一定需要同步提供完整的诊断机制.

  内核和驱动呢? 实际上, 客户不可避免的会对这个部分有修改.
  如何解决上层模块和驱动之间的依赖关系呢? 比如音频开发, 是否几个sound驱动模块增加一个版本号, devices.c也应该去掉关于sound的初始化代码, 而转移到sound的init函数, 在audiobox之类的模块增加对版本的依赖判断, 读取下层驱动版本号, 不匹配的话直接报告. 还有是否每个codecs之类的库也应该增加版本,audiobox会做相应的判断.
  audiobox应该保持多个版本号, 一个作为自身的累加版本(可能qplayer和abctrl对他有依赖), 其他对应各个依赖模块.

给客户的release notes, 版本号应该更加鲜明的指示数据结构的变化.

**01-11**<br>
周六. 国际象棋考级, 武宁小学, 因为失利和丢失一个圆珠笔, 儿子吵着要撞墙, 第三遍时因为喋喋不休被训.
老婆的脚很像是脚底板发炎了, 然后导致手上也有炎症性疼痛, 如果耽搁治疗, 担心会有后遗症.
**01-10**<br>
周五,请假. 带老婆儿子上医院, 小熊的流感终于好了, 可老婆的病没有确诊, 风湿免疫科-发热门诊-感染科-骨科, 一通瞎搞.
**01-09**<br>
研发部: 杨洁琼 庞松华 胡彦艳-财? 杨文正-杨老师-杨总;  陈鹏 员清观 郑万虎
**01-08**<br>
首要任务是, 找到所有的q3f平台功能测试用例和结果预判.
**01-04-05-06-07**<br>
公司搬家
**01-02**<br>
今天同学们基本都走光了, 办公室空荡荡的, 感觉说话都有回声, 有点风萧萧兮易水寒的感慨;

无论来年公司是何种走向, 需要保持初心: 认真思考和整理一下之前三年在公司的点点滴滴. 目标: 在不确定的离开之前, 要真正能够开发掌控一个独立的大型软件模块, 要有成为系统架构师的信心

## 系统架构师相关内容整理

核心思想之一: `去耦合, 去重复`

**模块设计**
1. 分层架构设计: 需要有分离分层的思想,层次之间通过api接口调用,不要产生数据上的耦合;并且注意处理上层多个模块对相同功能的调用接口,不要出现太多的冗余api接口
2. 模块化: 模块功能要划分清晰.大模块使用独立的进程, 线程之间也尽量的模块化,即使不是对象编程, 也应该尽量把一个大的进程分割成若干个独立的小模块. 进程和线程之间通信注意要架构清晰,接口简单去耦合
3. 封装常用功能: 如实现工具类，和帮助类，时间或者定时调用, 线程池, 日志和调试诊断, 自动测试机制, 同时要保存好，（耦合性低）以后开发直接拿出来用。
4. 注册回调框架: 数据和算法多选一的时候, 比如aec部分, 切换不同算法直接使用, 避免每次出现长窜的switch-case语句
5. 事件状态管理框架: 类似eventhub这样的接口, 用于管理系统内部的状态，基本思想上订阅发布机制（也称观察者模式），有了它，代码就不用再去请求一堆状态数据了，只需要把你关注打事件或者状态注册一下，当事件发生时，就主动通知给你了。

进程内拆开的小模块, 尽量能够做到外部能够直接进行单元测试. 比如音频模块下, 可以直接导入外部的配置和音频文件进行测试. 如果能够多个小模块可以从外部配置进行关联测试, 就更好了. 类似与ipc.json文件所定义的. 是否audiobox模块也应该定义类似的解析接口, 根据外部配置文件定义的信息进行功能测试呢? 这个解析直接在audiobox模块实现, 可以更加方便的安排单元测试和自动测试.是否应该继续改造audiobox模块, 作为我之后开发的魔板呢?

## 热 恋 -- 刘永康

  死   后
假如我死后
你可会来到我的坟头
站立成一棵柔弱的柳
柳的露珠浇湿了相思
发的柳丝揉拂着悲愁
啊，那株倾心伴我身旁的弱柳

假如你死后
我定会走向你的坟头
默默如一块石碑停伫
泪不流洒话不出口
风不移动雨不回眸
啊，这块心上刻你名字的石头

## 陶笛
sf的歌单：　《天空之城》《森林公主》《798的天空》《雪的梦幻》《舒伯特小夜曲》《远处的星光》

12孔SF陶笛也不错，适合五年级以下的孩子（他们手小）SF的F调指法 演奏的曲子是 降B调，伴奏曲少，可以吧C调伴奏降调。MVbox 有这个功能 。

美丽的梦想家 -- 出自宗次郎的专辑《世界のうた こころのうた》，让心灵安静的音乐，太陶冶。
情笛 --- 著名陶笛演奏家周子雷编曲，优雅的东方韵律，说不尽亘古及今的无穷岁月
来自泥土的呼唤
心海 --- 心海沉浮，潮起潮落中有积极和快乐，也有坚强和跨越。
Try To Remember --- 陶笛的空灵，回到最单纯的时光，一个人静静听，感受旋律中的温暖
Motherland


## 小熊宝贝
有几件事情，我是这么考虑的：
１．国际象棋，我最近优先赶赶进度，争取自己进步点，能进入有兴趣状态，可以和他对弈
２．陶笛，我是期望在假期前我能稍微有点进展，这样如果能够吸引儿子感兴趣，假期他可以多一件事情．他要是不感兴趣，我就自己坚持玩下去
３．脾胃调理，这个我们最近两个星期是否研究研究，如果找到合适的，尽早带他到医院看看．
４．OK镜，最好能在寒假前确定下来．如果可以戴，那么把磨合的时间点放在假期会否比放在平时好点？
５．皮肤，暂时先观望一下吧．我30块买了一包20个医用手套，洗澡的时候给他用．
６．房子，这个这个，可能要辛苦老婆多操心了，我就不加班了

2017入学:
1.从小学一年级入学到小学毕业大约减少2万人。
2.五年级到六年级小学由于外地学生回流,人数减少大约2万人。
3.初中预备班到初三大约减少2万左右。
4.高中入学率55%左右。

委属高中（1所）：上海中学（四校之一）
市重点高中（即市示范性高中）（4所）：南洋模范中学（八大之一）、位育中学、市二中学、南洋中学
市重点分校或校区（1所）：市二梅陇

**湿疹**<br>
洗手,凉白开去除氯胺,加白醋中和PH值(计算好兑换比例);
洗澡,水温尽量不要高;减少洗澡次数;减少洗澡时间;洗头和洗澡分开,看能否干洗
测试ph值: 1.凉水(每周测试一次) 2.热开水 3.凉开水 4. 洗澡水 5.
维生素C 是否可以用于去除水中的氯;
白醋和氯是否会反应生成有害物质
安装净水器或者使用净水壶
常吃油炸食物的人，其皮肤病的发病率远远高于不吃或极少进食油炸食物的人群。缺乏维生素、矿物质、纤维素等营养，持久食用也会对身体造成风险。这些食物中含有较高的油脂和氧化物质，经常进食易导致血热、血燥，诱发皮肤病。

这是一种过敏性的局部皮肤炎表现，真菌感染、过敏症状、精神压力、湿热的天气等都可能引发。

化学清洁剂的伤害也是一个很重要的原因，洗衣粉、洗洁精这些化学清洁剂会破坏皮肤的屏障功能，天气和体质的内因，遇上清洁剂的刺激，就容易诱发汗疱疹。
金银花有着清热解毒的功效，在炎热的夏季可以经常看见用金银花泡茶喝的人，能够缓解人体内各地方的炎症问题，起到抗菌消炎的作用

适度保湿 : 1、皮肤是抵御外部真菌的前线战士，洗手时避免用过热的水，使用温和的清洁产品、洗手后将手擦干，但不宜过度清洁。2、可使用温和保湿成分护手霜，在洗手后使用。

勤动动
避免吸烟、喝酒、熬夜习惯
  长期生活在湿热环境中; 长期情绪压抑; 经常吃辛辣，油腻，烧烤，煎炸，冰冷食物

血糖，血脂过高都可以归结为湿气重浊。

祛湿的四大禁忌: 凉食冷饮 经常吹空调 熬夜 嗜酒

两种除湿方向:
  第一种，这种方法其实就是中医说的淡渗利湿，服用茯苓、泽泻、薏米、赤小豆、莲子等都属于这种方法，这些药物或食物都有比较好的效果，但这种方法也有致命的缺点，即能除掉已经生成的湿，不能防止湿邪的再次形成，在一定程度上来说解决不了根本问题。
  第二种方法，疏通气机。前面说了湿邪的本质特征就是缓，什么能克制缓呢？当然是急。在五脏中，肝木是急的，脾土是缓的，所以五行生克中的木能克土就是这个意思。一个慢性子的人整天懒得动，这时要让一个急性子的人带动他一下。这样第二种方法的具体实施就是健脾疏肝，健脾是为了增强懒人的实力，让他有力气运动；疏肝是让机体的节奏变快一些，整个气机流动起来，这样一来湿邪就祛除了。健脾可以选用六君子汤，疏肝可选用香附、苏梗、郁金、白芍等药物.现代的这种湿和古代不一样，古人劳作的多，湿邪多由外部侵入，属于外湿，用第一种方法效果非常好。现代人湿的根源是懒，所以第二种方法更为合适.

**内湿的形成和防治**<br>
**形成**
过食肥甘，嗜烟好酒；恣食生冷，内伤脾胃，致使脾失健运，不能为胃行其津液。
喜静少动，素体肥胖；情志抑郁，气机不利，致津液输布障碍，聚而成湿。
纵欲过度，房事不节；肾阳虚衰，脾失温煦，致脾阳虚津液不化，而湿浊内生。
**防**
少吃甜食、肉类、动物油，可以使人体气血顺畅，而水湿输布顺畅；
戒烟限酒，不损肺及脾胃，则水液输布、运化正常；
坚持适当运动。动则为阳，水湿痰饮皆为阴邪，唯气血流畅运行方可使阴邪不滞留体内；
乐观豁达，保持良好情绪，肝气调达，气机疏泄正常，则脾胃不受肝克，而气机顺畅，痰湿运化正常；
节欲养精，肾气充足，则元阳充足而能温煦脾胃，使津液水湿运化如常。
**药**
对于肝气犯胃而引起的脾胃功能失调如胃脘胀满，攻撑作痛，脘痛连胁，胸闷嗳气，喜长叹息，大便不畅或黏腻者，可用舒肝和胃丸治疗。如反酸胃痛，胃内烧灼感者，可用加味左金丸治疗。


调理脾胃：　　　　 https://www.sohu.com/a/276020792_565194
湿热还是寒湿 :    http://www.sohu.com/a/249992438_707230

静安牙防所，早上7点开始排队，7点45开始挂号，8点开始门诊，儿童必须本人到场。
1. 皮肤清洁也很重要，不要怕洗澡，洗完澡之后马上用一些保湿霜润肤
    全身保湿; 应该使用酸性的沐浴，避免碱性肥皂; 秋冬季节干燥，润肤剂尤其要保持使用; 避免冷风或强烈日晒
2. 饮食控制．多食蔬菜和水果，禁止海苔海带海鱼，酸奶，冰淇淋等冷饮，肥肉、奶油蛋糕、巧克力
3. 生活环境控制：最近的换床会否有影响呢? 每周更换床单和枕巾等。
    尽量不要养宠物，尽量不要种鲜花，不要用地毯
    家里也不要养花了。 纯棉的衣服，不要让宝宝穿易刺激皮肤的衣服，如羊毛、丝、尼龙; 修短指甲
4. 主动治疗：是否需要做脱敏治疗呢？
5. 放大镜找螨虫

**得了湿疹吃什么好**<br>
　　番茄。番茄内含丰富的维生素A、维生素B1、维生素B2、维生素C、烟酸，维生素E;还含有苹果酸、柠檬酸，钙、磷、铁及番茄碱等物质。具有生津止咳、健胃消食、凉血平肝、清热等功效。番茄中的果酸对维生素C有保护作用，故而能有效地补充维生素C;番茄碱有抑菌消炎、降低血管通透性作用，所以外用番茄汁治疗湿疹可起到止痒收敛的作用。
　　苦瓜。苦瓜内含奎宁。具有清热解毒、祛湿止痒之功。可用于治疗热毒、疖疮、痱子、湿疹等病症。
　　韭菜。韭菜内含胡萝卜素、维生素B、维生素C及钙。磷、铁、蛋白质、纤维素等。韭菜还有解毒祛湿的功效，故韭菜汁外搽可治湿疹。

钙磷酸酶抑制剂 不含激素，据说效果不错，但比较贵。

主持人：特应性皮炎药物治疗配合润肤剂剂使用频率是什么样的？
顾恒：首先，皮肤干燥是特应性皮炎的诊断标准之一，因此每天使用润肤剂是必不可少的。不同的季节可以选择不同类型的润肤剂，在冬季可以使用油脂性强一点的润肤剂，到了夏季可以使用稍微稀润一点或者油脂性弱一点的润肤剂。如果一些患者病情反复发作，发病比较频繁，可以使用钙调磷酸酶抑制剂这些能够安全有效，且可以长期使用的外用药物治疗。并且在控制住病情后，改用一周2次的长期维持治疗来减少复发频率和严重程度。钙调磷酸酶抑制剂不会出现使用激素类药物的皮肤萎缩、毛细血管扩张不良反应。

正确治疗有五部曲，在经过正确的治疗后，特应性皮炎是可以得到控制和缓解，这样花的代价最小，副反应也是最小。
1.首先，皮肤日常基本护理就是要保护皮肤，使受损的皮肤屏障功能慢慢恢复。通过使用保湿霜或者润肤露都可以起到保护皮肤湿润的功能。另外，皮肤清洁也很重要，不要怕洗澡，洗完澡之后马上用一些保湿霜润肤。
2.其次就是基本的药物治疗，基本的药物治疗就是外用药，对于儿童特应性皮炎患者，一般选用温和的中效或者弱效激素，而不要选用强效激素或者含卤素元素的激素。同时还可以用非激素类药膏，代表就是他克莫司软膏。
3.另外，根据症状，如果瘙痒的非常严重，可以吃一些镇静类的药物，镇静药物可以用西利琴或者罗瑞它丁。如果这些治疗不能完全缓解控制疾病，就需要系统治疗，比如内服激素类药物和免疫抑制剂药物。如果合并细菌感染，则同时需要用一些局部的抗生素软膏进行治疗

甜食促使金黄色葡萄球菌等真菌生长繁殖，引发瘙痒、丘疹、水泡等不适。
油炸食品含有较高的油脂和氧化物质，经常进食易导致血热、血燥，诱发皮肤病。
冰淇淋、棒冰、冰冻水果、冰镇饮料等少吃
避免接触化学清洁剂的伤害也是一个很重要的原因，洗衣粉、洗洁精这些化学清洁剂会破坏皮肤的屏障功能，天气和体质的内因，遇上清洁剂的刺激，就容易诱发汗疱疹。
一、多喝几杯水
2、饮用水量：成年人每天推荐1500ml~1700ml水。按照250ml杯子来折算，就是6~6.8杯；按照200ml杯子来折算，就是7.5~8.5杯。
3、金银花有着清热解毒的功效，在炎热的夏季可以经常看见用金银花泡茶喝的人，能够缓解人体内各地方的炎症问题，起到抗菌消炎的作用。

二、适度保湿
1、皮肤是抵御外部真菌的前线战士，洗手时避免用过热的水，使用温和的清洁产品、洗手后将手擦干，但不宜过度清洁。
2、可使用温和保湿成分护手霜，在洗手后使用。
3、另一个重点是不可以抓破水泡，水泡一旦破了可能增加感染风险，想快去去除的方法就是涂抹眉寿堂修复霜，能有效渗透肌肤还原皮肤，天然无刺激，配合送的止痒喷雾，坚持使用两个星期左右即可恢复，网上很容易找到。

三、勤动动
先以每分钟100步的速度行走，再根据自身的体能，逐渐加快，最快可达到每分钟140步，同时尽可能大幅度地摆动和舒展手臂，以刺激淋巴结，有利于皮肤排出毒素。

饮食适宜：1、饮食宜清淡、爽口；2、饮食要节制。
宜吃食物宜吃理由食用建议
　　木耳。含有丰富的吡嗪，可使血小板凝集率下降，同时能降低血粘度、甘油三酯、改善肺循环。可以同苹果做汤食用。
　　西红柿。含有一种番茄因子有溶解血栓的作用。可以煮汤每日食用。
　　甜瓜。防止血小板凝集，抗血栓形成，还有溶解血栓的功效。将蜂蜜与瓜汁调匀，当饮料饮用。
　　饮食禁忌：1、忌油腻食物；2、忌辛辣刺激性食物；

忌吃食物忌吃理由忌吃建议
　　辣椒。易伤肺气，耗心阴，使心肺气阴两亏，从而加重喘咳等症状。辣油、辣味调料、辣酱、京葱、生姜、芥末、蓼蒿等，都少吃为好。
　　猪油。使痰浊内生，内外邪气搏结，胶固粘滞，从而使咯痰不畅，咳嗽难愈；且使水湿运化失司，水饮溢于四肢、胸胁，出现水肿、喘息不得卧等症状。牛油，奶油、油墩子、炸鹌鹑、电烤鸡、鸭等，尽量不要吃的。
　　冷饮。可阻遏胸阳，生痰滋湿，从而使肺病患者咳喘、咯痰、心悸等症状加重。冰淇淋、棒冰、冰冻水果、冰镇饮料等少吃为好。
    炒菜尽量用植物油, 少用动物油.

山茶油,又称茶油、油茶籽油、茶籽油、野山茶油等,是山茶树果实压榨的木本植物油。 茶油性味甘,凉,功效润胃通肠,退湿热,养颜生发,促进伤口愈合。

上海中医院  脾胃病科


## 徐汇公办
  招生人数：　https://www.sohu.com/a/131113948_239541

  办公电话：64872222   招生咨询：64418113
  虹桥路小学属于电脑排位区，对口徐汇中学和南模初

2020高考人数,5w, 985招生6%约3000人, 211招生12-15%约6000人, 总20%, 8000~10000,其中3/4是本地学校

如果上华育,需要经过多个竞争阶段: 1.14%左右区属市重点配额竞争,高概率失败进入后续的裸考 2.竞争4校到区名额(50,按区中考人数分配),浦东有人口优势,徐汇严重不利 3.竞争区属市重点到区名额 4.竞争区属市重点在本区的统招(35%)

2020四八校总招生计划5319,总考生8w,6%左右的人可以上.
2020年徐汇中考报名人数: 5600, 徐汇市重点高中总招生计划1749人,约30%(全市约26%): 上海中学 385  南洋模范 397 位育中学 405 市二    265 南洋中学 317

如果拿出44.5%作为学校配额的话, 那么每个学校的入重点几率: 44.5%**1749-385)/5600 = 11%, 浦东这个比例是5%.
剩余的名额,如果大部分裸考的话,

浦东: 370 480*3 640 400 280 100(上实不算吧)     1690 + 1440 = 3130 , 徐汇的两倍, 考生四倍.

这样, 头部民办有可能会抢占大量裸考的名额. 而几个公办靠配额吃饭.

徐汇区天平街道四所名校：向阳小学、建襄小学、高安路一小与徐汇第一中心小学，
高安路一小、向阳小学、汇师小学、建襄小学

先说结论：既然我们必然先摇号民办，我研究下来，还是买龙华吧

上午花了几个小时看网页，好像最近几年的数据教育局不允许放出来了。下面列表中小括号内容：(2017招生班级个数, 2016年实际预录取人数)。预录取的目标学校当然会有些质量的差异。

徐汇公办，徐汇公办共有公办27所☞含2所一贯制学校+1所特教学校; 徐汇公办民间排名如下：
第一梯队：徐汇中学(10, 14)、位育初(8, ?)、徐教院(6, 10)、师三(4, 4)；
第二梯队：中国中学(7, 10)、南模初(6, 8)、园南(6, 6)、田三(6, 9)、市四(10)、市二初(5, 4)
第三梯队：南洋初(6, 6)、五十四中(4, 5)、华理(6, 7)、龙华(4, 6)；
  其他学校：在本区实力相对比较弱的初中。龙华中游了，按班级比例看，好像不算很差。

四大公办和四大民办进入华育和世外的人都不少。比如华育，按照往年的数据，逸夫小学、盛大花园小学最好保持在年级前15%，世外年级前7%，爱菊小学年级前5%，当然，也不是那么绝对，不一定学校前列的孩子都想进华育嘛。比如盛大花园其实每年有接近一半的孩子进了西南模范。

满分630

世外均分590.5，600以上71人；
华育均分597+，600分以上110+；
上宝均分595.5；
张江均分594.5；
上外双语均分591.05，600以上53人；

西南位育均分600以上20+；
文琦中学均分600以上17个，585以上132个；
徐教院附中最高610.5，600以上11个，590以上共30+，580以上共70+；
九峰中学某个班600分以上11人，590-599.5分12人，585-589.5分8人；

如果不甘心龙华中学，那么可以看看虹桥路小学对口的，我查地图，最近的直接对口的两所初中是徐汇中学和南模初，其次远一点就是市二初和田林三两所。而且虹桥路小学又是菜小，所以，也许会有机会。
或者徐教院附中对口范围

## 红茶上火
1、红茶、熟普洱这一类高发酵度的茶品，在制作完成后的初期，火气都会相对较重（此处单指由发酵带来的火气），通过一段时间的放置（前提是仓储得宜），可以降低其火气——对于熟普洱茶而言称之为“散堆”，同时有散除熟茶渥堆气味的作用。
2、除了发酵本身，制程中的其它部分同样会带来火气，最明显的就是茶叶的干燥。
3、许多红茶干燥温度参数为毛火120℃，足火100℃（不同茶品有差异），这样的高温无疑会给茶品带来燥火，当下品饮感受可能体现为：上头、太阳穴紧锁、喉咙干、锁喉等等。不同的感受既和茶品的种类、制程差异有关，也和品饮者体质的敏感程度有关。
4、红茶的高温制程除了干燥，还有高温提香，最夸张的有红茶已然出现了巧克力味，猜测是亦有轻微炭化现象，对于感知不敏锐的品饮者而言，这种高温火工香是受欢迎的，但也无疑是会导致上火的。
5.一些相对低温干燥的红茶，其火气会相对低些，比如滇红的烘干温度多为60℃左右，新茶火气较高温干燥红茶为低。不过今年来为了迎合市场，滇红的亦有高温提香的茶品出现——对于品饮者而言，当下感知不到不代表对身体没有损害，这才是尴尬的地方（当然，伤害程度与红茶的摄入量也有关）
6、喝过一种滇红，最后干燥采用阴干，是极少数喝了以后没有明显燥感的红茶。不过产量不高，同时对于敏感度低喜欢高火红茶的茶友而言（当然，他们的选择也需要得到尊重），这种茶品是不受欢迎的。
6、因此，红茶会导致上火，具体结果与其发酵制程、干燥方式与温度、有无高温提香等均有关联，最后品饮者品饮到的茶品导致其上火的“能力”是上述因素综合作用的结果。

## 今年的书单
