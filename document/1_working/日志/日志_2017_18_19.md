# 工作日志

### 修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2017/09/25 | 员清观 | 常用操作索引，尽量简短方便使用 |

## misc
cat /proc/pagetypeinfo cat /proc/vmallocinfo

`nautilus` 可以用来从终端启动文件管理器并切换到当前文件夹

## 当前任务备忘
motor文档(路径：内部资料，经验分享，内核及驱动)
abctrl可以考虑增加接口，直接采集audiobox指定fr的信息，这样更加方便，功能强大。这需要有规律的fr命名方式。最好是函数调用得到这些名称
squashfs缺省设置应该改变，4k block，lzo压缩方式
getchannel的时候申请一个buffer,putchannel的时候释放，这样，可以直接废弃audio_get_frame、audio_read_frame，这套函数有问题，因为中间很可能会夹杂写文件到sd卡或者网络等操作，有可能导致卡顿，导致xrun
如果在内核中缺省加载dsp，应用通过ioctrl加载firmware，可以节省15ms加载模块时间。延伸开来，普通的模块，实际上开销包括两个部分，加载驱动时间，和驱动初始化时间
只有audiobox使用的so，应该静态编译，节省加载时间： libfdk-aac.so libspeexdsp.so libdsp.so libcodecs.so libunitrace.so alsa-lib ，并从rootfs中去掉
audiobox, 去掉speexdsp的可能存在的范例程序；增加一个patch,用来去掉so的编译；后否因为ogg而变得太大呢？
audiobox，能否不加载用得少的codec呢？apu_codec可以考虑在另外的进程中实现，动态加载；speexdsp也可以考虑如此实现；或者，部分必须的功能在内核中实现
BR2_PACKAGE_ALSA_LIB_PCM_PLUGINS="all" BR2_PACKAGE_ALSA_LIB_CTL_PLUGINS="all" 这两个是可以裁剪的功能。可以减小alsalib的大小
修改item处理，增加LLI模式，所有平台。
audiobox创建通道失败之后，终止
## 追加，茶
久别离
	2012贡眉，口感和政芯的2011有点像;公道杯里面是很香的，口味和普通的老寿眉比较一致；没有感觉到浓郁的甜。之后可以考虑尝试一下老牡丹(饼和散茶)
	2014白露, 公道杯很香啊, 汤水味道也不错,颜色很清亮, 看起来不错, 有货的话可以买

陶茶屋:　　2011藏岁贡眉, 梅子味, 清亮, 优惠的时候可以买

1. 音频开发,包括:codec驱动,alsa驱动,audiobox模块 vplayer ffmpeg应用 aec处理和测试效果量化评估
2. 存储系统: 性能和稳定性(各种异常情况的处理) fat32文件系统延迟分配解决fat32文件系统缺点, sd/mmc, spi flash, ftl, 启动出错问题, 50M提速
3. 设计门铃项目的demo: 基于全志xr871和cortex-A5
4. 内核维护: uboot和内核启动速度优化;解决内核bug导致的CMA内存碎片问题; freertos内核移植到公司cortex-A5平台

Kernel压缩算法 Kernel裁剪 将一些驱动模块编译为KO延后动态加载

盈方微:
  产品化工程化方向, 有很长的路
  单元测试, 自动测试, 压力测试
  诊断和客户支持手段
  学徒制度, 深度培养每一个员工,但是不适应文化不成熟的公司, 如德国,基本是终身雇佣制的,员工和企业有比较密切的关联.

按照之前讨论，盈方微新的门铃项目采用C20+wifi MCU的架构，两芯片间通过SPI总线通信，尚云P2P的工作将会拆分开在C20和MCU分别完成，MCU端注册到唤醒服务器并维持心跳和支持设备唤醒和客户端推送；C20只有在有实际视频传输任务的时候才会启动，负责监听和建立视频连接。

设备启动流程：
a．MCU端注册到唤醒服务器
b．MCU进入休眠状态，但会定时醒来发送唤醒服务器keepalive心跳(比如60s一次)

手机客户端发起的呼叫流程：
a．客户端向唤醒服务器查询设备休眠状态信息
b．唤醒服务器向设备发送唤醒封包
c．MCU结束休眠，启动C20
d．C20启动完成后，开始listen()监听客户端连接
e．客户端确认设备唤醒之后，connect()连接到设备
f．开始视频通信

设备端主动触发呼叫流程(按门铃按键等事件)：
a．MCU结束休眠，向推送服务器发送推送请求，同时启动C20
b．推送服务器推送请求到手机客户端
c．C20启动完成后，开始listen()监听客户端连接
d．客户端确认推送请求后，connect()连接到设备
e．开始视频通信

## 2019-12-31结束
**12-29**<br>
devfr的类型应该改变; 播放时devfr的大小应该可配置，audiobox命令行参数；播放时channel的参数可以配置。
下一步，pcm通道的参数，应该可以支持更多的buffer个数，更长的period，以保护音频数据流。
**12-28**<br>
现在有能力调整buffer的打消了，dma最大8个，alsa的不受限制
**12-27**<br>
新的控制信息，全部放在struct imapx_runtime_data中，这样，可以保证每个codec一个；或者，只有使能了aec的通道，才有必要使用新的机制。
暂时，把通道映射写入aecv的控制文件中，以后再确定如何调整audiobox代码。
设备aec功能配置，直接使能dma的处理
**12-26**<br>

**12-25**<br>

**12-24**<br>
i2c_2 i2c_3连接到GPIO排线
i2c_0 U9 AXP202 电源管理芯片 地址 0x34
			U11 RTC模块  地址 0x51
i2c_1 codec
**12-18**<br>
调试es8323，启动过程中需要插入延时；去掉aecv2代码中的spin_lock
**12-17**<br>
整理和上传timestamp版本代码；aecv1代码增加ip620x的判断
**12-13**<br>
下一步优化：
１．使用alsa的时间戳代替原有的内核层时间戳/audiobox层时间戳
	这样做除了逻辑更加合理，一个主要原因是i2s配置为16位宽时，原有的时间戳会破坏音频数据
２．audiobox根据sampling_rate，限制sample_size不得小于40ms帧
	过小的sampel_size导致高帧率，更容易导致上层来不及取数据出现xrun，并且开启aec功能时可能会超出dsp处理能力
```cpp
snd_pcm_sw_params_set_tstamp_mode(dev->handle, softwareParams, 1);

extern struct timespec snd_pcm_hw_fast_tstamp(snd_pcm_t *pcm);
struct timespec cur_timestamp;
cur_timestamp = snd_pcm_hw_fast_tstamp(dev->handle);
int tesmp = cur_timestamp.tv_sec*1000 + (cur_timestamp.tv_nsec/1000000);
if(tesmp != dev_buf.timestamp)
printf("timestamp: %lld  timestamp: %d, %d \n"
	, dev_buf.timestamp
	, (int)cur_timestamp.tv_sec, (int)(cur_timestamp.tv_nsec/1000000));
	,
```
**12-12**<br>
  #define	SNDRV_CTL_ELEM_IFACE_CARD	((__force snd_ctl_elem_iface_t) 0) /* global control */　可能更适合用作aec使能控制，比system命令开销小。

ip6205左右声道交换
启动aec:
[   39.153333] ~~~~~~1 VALUE: reg 0xe2(0xc13f00c3-->0xc13f00c2)
[   39.159999] ~~~~~~1 VALUE: reg 0xe2(0xc13f00c2-->0xc13f00c0)
[   39.169999] ~~~~~~1 VALUE: reg 0xe2(0xc13f00c0-->0xc13f0080)
[   39.176666] ~~~~~~1 VALUE: reg 0xe2(0xc13f0080-->0xc13f0000)
[   39.186666] ~~~~~~1 VALUE: reg 0xe2(0xc13f0000-->0xc13f0010)
[   39.193333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0010-->0xc13f0030)
[   39.203333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0030-->0xc13f0130)
关闭aec:
[   50.073333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0131-->0xc13f0133)
[   50.083333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0133-->0xc13f0173)
[   50.093333] ~~~~~~1 VALUE: reg 0xe2(0xc13f0173-->0xc13f01f3)
[   50.103333] ~~~~~~1 VALUE: reg 0xe2(0xc13f01f3-->0xc13f01e3)
[   50.113333] ~~~~~~1 VALUE: reg 0xe2(0xc13f01e3-->0xc13f01c3)
[   50.123333] ~~~~~~1 VALUE: reg 0xe2(0xc13f01c3-->0xc13f00c3)


**12-11**<br>
调试#7168;
frname 定制，调整audiobox代码，在dma模块限制sample_size为40ms
**12-10**<br>

**12-07**<br>
调试并上传speexdsp，完整测试了各种算法和aecvx组合下回声消除功能

准备编写audiobox文档:
1. 场景: 增加audio_set_format audio_get_format场景/ audio_enhance_mode /
2. audio_get_channel_ex 支持逻辑通道参数和物理通道参数不同。

**12-06**<br>
static int default_aec_version = AEC_DEFAULT_VERSION;
调试speexdsp
**12-05**<br>
hlibvcp7g代码合并到audiobox，vcp7g和speex代码统一定义；整理上传audiobox trace的更正
**12-04**<br>
修正i2s和ip6205中16位宽的bug
**12-03**<br>
fr1023使用的是外部会环，所以aecv1录音dma_size=2不会问题
dma_size=2, 16bits录音慢播放慢，录音的时候感觉像是被扔掉了一半数据一样。
## 12-03->...
**11-30**<br>
speexdsp.c　alangodsp.c保存统一定义的函数接口，通过宏控制是否编译；　apu_aec.c 中增加统一的aec函数接口，通过宏控制speexdsp和alango的选择。
第一步，拆分vcp7g_dsp.c文件，然后再集成speexdsp的接口进来。
**11-29**<br>
请假
**11-28**<br>
mempool的使用
```cpp
 #include <linux/mempool.h>
mempool_t* float_mempool;
static inline mempool_t *mempool_create_kmalloc_pool(int min_nr, size_t size)
bio_split_pool = mempool_create_kmalloc_pool(BIO_SPLIT_ENTRIES, sizeof(struct bio_pair));
struct bio_pair *bp = mempool_alloc(bio_split_pool, GFP_NOIO);
void * mempool_alloc(mempool_t *pool, gfp_t gfp_mask)
void mempool_free(void *element, mempool_t *pool)
```

**11-27**<br>
应该在unitrace的configure.ac文件中，根据`BR2_PACKAGE_HLIBUNITRACE`是否set来增加ENABLE_UNI_TRACE的宏定义。unitrace的模块是一定会被编译的，但是其他模块是否编译进去，应该由config选项`BR2_PACKAGE_HLIBUNITRACE`来确定。HLIBUNITRACE_POST_INSTALL_STAGING_HEADERS宏中增加 `-rm $(AUDIOBOX_BUILDDIR)/.stamp_built` `-rm $(TESTING_BUILDDIR)/.stamp_built`，可以自动触发make时重新编译audiobox和testing模块。

audiobox_trace.h
abctrl.h

**11-26**<br>

dsp加载firmware，从firmware_class.c中无法看出如何确定搜索firmware所在目录，然后更改output/system中目录为dsp2/firmware，仍然出错：modprobe: can't load module ceva-dsp (kernel/drivers/infotm/q3f/char/dsp/ceva-dsp.ko): Operation not permitted；怀疑和模块所在目录有关，于是更改模块代码目录为dsp2，仍然出错：can't load module ceva-dsp (kernel/drivers/infotm/q3f/char/dsp2/ceva-dsp.ko)。跟踪firmware_class，已经知道和CONFIG_FW_LOADER_USER_HELPER有关，而且有uevent产生，所以，查看product目录mdev.conf，发现`cevadsp-tl421	0:0 666 @/etc/mdev/dsp_load_fw`，打开dsp_load_fw文件，修改其中的dsp为dsp2，ok. driver目录回归dsp，仍然ok. 所以，应该是Mdev和system目录需要保持一致。

printk(KERN_EMERG "~~~(%s, %d)~~~\n", __func__, __LINE__);
tl421_fw_cb 函数中，应该可以减少一次拷贝的动作。估计可以减少10ms级别的加载时间。
int kernel_read(struct file *file, loff_t offset,	char *addr, unsigned long count) 函数，关注一下。


**11-23**<br>
q3f开发板上的aecv1和aecv2还需要修改声道填充。

audiobox增加新的函数，扩展dev级别的配置，调试和控制
```cpp
int audio_preprocess_ctl(const char *dev, enum new_audio_command requst, void *para, int len)
{
	int cmd = AB_SET_DEV_VOLUME;
	char rpcname[64];
	char devname[64];
	int result = 0;
	int ret;

	if (!dev) {
		return -1;
	}

	memset(devname, 0, 64);
	sprintf(devname, "%s", dev);
	audio_get_rpcname_by_dev(rpcname, devname);
	AB_EVENT(sc, &cmd, devname, para, &result);
	ret = audiobox_rpc_call_scatter(rpcname, sc,
			AB_EVENT_SIZE(sc));
	if (ret < 0) {
		return -1;
	}

	return *(int *)AB_GET_RESULT(sc);
}
```
**11-22**<br>
集成之前aecv2的代码，尝试ceva-dsp对功能定义宏的依赖。
**11-21**<br>
提交float fr修正：
fix(kernel/fr): fix float fr crash problem when SMP is enabled

when struct fr_buf(storing frame management information) of floating fr reside in CMA, a crash will happen; else if moving it to cacheable memory, it work well. This should be related with cache line coherence of SMP.

change: get struct fr_buf out of CMA memory,  alloc/free it dynamically with kzalloc()/kfree(), and restrict maxinum frame number of floating fr to 160.

Close 6127

**11-20**<br>
float fr, SMP无法正常工作的问题。重现，并且重新设计测试脚本。

RM#6127, setproduct.sh选择Gix15, none, default.

vbctrl stop
mkdir /mnt/sd0
mount -t vfat /dev/mmcblk0p1 /mnt/sd0/
cd /mnt/sd0/
videoboxd /mnt/sd0/player_320_g1.json
./vplayer 320_264_15fps_1track.mkv
new
play 1

json文件需要修改，可以改成：
{
    "dec0":{
        "ipu":"g1264",
        "port":{
            "frame":{
                "w": 320,
                "h": 240
            }
        }
    }
}
或者
{
    "dec0":{
        "ipu":"g1264",
        "port":{
            "frame":{
                "w": 320,
                "h": 240,
                "bind":{"filesink":"in"}
            }
        }
    },

    "filesink": { "ipu": "filesink", "args": { "data_path":"/mnt/sd0/h264Test.h264" }}
}

## 11-05->...
**11-19**<br>
跟踪make的全过程，分析output/root产生规则，邮件回答客户问题：
```cpp
跟踪分析了make的全过程，问题已经确认。

先参考典型的烧录脚本burn.ixl内容，我们将基于此burn.ixl脚本制作烧录卡：
    #images:
    i run 0x08000200 0x08000000 ../../output/images/uboot0.isi
    r flash 0x0  ../../output/images/uboot0.isi
    r flash 0x1  ../../output/images/items.itm
    r flash 0x2  ../../output/images/ramdisk.img
    r flash 0x3  ../../output/images/uImage
    r flash 0x5  ../../output/images/rootfs.squashfs

其中，rootfs.squashfs基于output/system生成，它包含完整的最终商用的rootfs；ramdisk.img基于output/root生成，它只包含烧录相关的内容如busybox、mkfs utilities、upgrade程序以及所有的依赖库。故而，后者大小远小于前者。从烧录卡启动时，内核加载ramdisk.img对应的根文件系统，执行其upgrade程序完成烧录uImage和rootfs.squashfs，然后拔出烧录卡，重启，完成烧录过程。

output/root和output/system生成的根文件系统都是只读的，如果需要产生一个可读写的文件系统，应该通过配置items.itm实现。例如，"part7 config.512.fs.jffs2"将会增加一个新的512k大小的jffs2分区，具体操作请参考items文档。

如果需要配置最终rootfs采用squashfs文件系统，首先通过"make menuconfig"，开启"Filesystem images"-->"squashfs target filesystem"，这样make的时候就会在output/images目录产生rootfs.squashfs；并确认burn.ixl文件中配置了"r flash 0x5  ../../output/images/rootfs.squashfs"，然后制作烧录卡即可。
```

记录一下，金总要的epkg文件生成工具: ~/work/working_folder/gen_epkg.tar
编译:  gcc -o gen_epkg epkg_generator.c;
执行下面命令,产生efuse_cfg_03520110_28e2979a9250_500000.epkg文件 ：./gen_epkg 03520110 28e2979a9250 500000
产生的epkg与之前收到的范例文件内容完全相同

iuw64 的源代码在哪里，毛用

**11-16**<br>
计划开展kernel warning的清理工作，现将目前kernel编译中的warning整理了出来，请见附件表格，其中包含gerrit上编译的4个产品，以及x15和x9的2个产品，共6个产品编译过程中的kernel warning信息。首先从q3fevb_va这个产品开始清理，任务分配如下，后续其他产品的清理工作的分配相同。请根据各自的任务分配情况，将表格中的对应warning处理掉：
- Eric: Kconfig, arch, audio, mmc, DMA, fs
- Can: clock, spi, net, regulator, otg, uvc, env
- Wanhu: display, adc, item, gpio, pwm, rtc, other

**11-15**<br>
lds格式；尝试fft乘法除法优化，但发现是float格式，了解之后发现无法完成; 确认sin/cos的优化已经内置了。
**11-14**<br>
2的幂fft变换速度快点。
**11-13**<br>
fftw3f是由fftw模块生成的，需要在package的fftw.mk文件中添加 `FFTW_CONF_OPT += --enable-float`
两种方法测试故事机aec功能：1. 采集故事机capture和record文件，pc上或者q3f板上解析并对比效果。2. 移植speexdsp到故事机。
**11-12**<br>
160fft效果测试，采样点的分组。
**11-11**<br>
review linux启动流程，文档化
**11-09**<br>
考虑进一步提升性能： 1. 移植到sram 2.DISABLE_FLOAT_API
**11-08**<br>
请假
**11-07**<br>
测试speex各种场景下资源开销，并尝试消噪等参数，无效
**11-06**<br>
集成speex到qsdk，定点的开销只有float的一半，然后尝试确认float相关移植
**11-05**<br>
整理回声消除文档，<br>和-后数字的格式问题，导致平台无法预览文档。

## 10-01->10-30...
**10-30**<br>
能否先用固定的参数消除回声，2s完全收敛之后，再切换到新的匹配参数。这样需要修改算法。或者，打开speex之后再不关闭，这样是否就会总是使用之前已经同步好的参数呢？dsp会否也是如此？dsp会耗电，不知道是否适合。可以尝试使用speex程序一次处理多个文件，第一个文件收敛好之后，会否剩余的文件就不需要再收敛了。
speex算法听起来效果和dsp的差不多。可以使用大的采样帧，虽然收敛时间长了，但一次收敛，永远收益
**10-29**<br>
测试脚本，分别测试单向通话和双向通话的场景。优化了7个音频测试文件，全部16bit, 1声道, 8000采样率，并保持振幅相差不大。
```shell
//#!/bin/sh

recorddir=/mnt/sd0/result/
mkdir $recorddir
counter=0

for musicfile in `ls /mnt/sd0/test?.wav`
do
abctrl play -w 16 -r 8000 -s 8000 -n 1 -d $musicfile -v 100 -y 0 -z 8 &
sleep 1
abctrl record --enable-aec -w 16 -s 8000 -n 1 -t 5 -o ${recorddir}"test"${counter}"_dsp".wav
counter=$(($counter+1))
sync
killall abctrl
sleep 1
done
```

**10-27**<br>
audiobox自动测试
为了优化aec测试过程中声音文件的时间同步问题处理，尽量减少测试中大量的手工操作和主观评估，尝试引入自动测试过程：
１．sudo minicom，启动EVB板，确认进入命令行
２．断开minicom链接(ctrl+a, 然后按q键)
３．PC执行脚本开始测试：PC开始播放音源，然后通过执行minicom脚本发送放音和录音命令到EVB板.(测试开始之前应该先启动加载totem进程，以减少PC播放延迟)
totem ./tools/origion.wav &
sudo minicom -S ./aectest.run
附aectest.run脚本内容：
send "mount -t vfat /dev/mmcblk0p1 /mnt"
send "abctrl play -w 32 -s 16000 -n 2 -d /mnt/pcm_16khz_ch2_32b.wav &"
send "abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 20 -o /mnt/record.wav"
exit
４．20秒后录音结束，pesq比较record.wav和origion.wav.

**10-26**<br>
比较的因素：
- 收敛时间
- pesq 或者 RMS振幅
- 调整延时和比较内容部分
- 增加样本个数
- 调整比较时间，15s，60s各自选取几个不同的音源，是否需要
  - 调整音量大小？
  - 频谱？
  - 音乐和语音
  - speex的NN和TAIL应该可以作为参数传递进去看效果

webrtc和speex和dsp，采用相同的处理机制。统一使用采样率8000, 16bit, 单声道。

值得注意的两点：
- 1： 自适应滤波器收敛阶段，期望信号是完全的echo，不能混杂有speech。因为speech和fe是没有关系的，会扰乱W(n)的收敛过程。也就是说要求回声消除算法开始运转后收敛要非常快，最好对方还来不及说话，你一说就收敛好了；收敛好之后，如果对方开始说话，也就是有speech混合过来，这个W(n)系数就不要变化了，需要稳定下来。
- 2：回音路径可能是变化的，一旦出现变化，回声消除算法要能判断出来，因为自适应滤波器学习要重新开始，也就是W(n)需要一个新的收敛过程，以逼近新的回音路径函数F。
基本上来说，上面这两点是两难的，一个需要自适应滤波器收敛后保持系数稳定，以保证不受speech说话干扰，另一个需要自适应滤波器随时保持更新状态，以保证能够追踪变化的回音路径。这样一来，仅从数学算法层面，回声消除已经是难上加难！简单地说，回声消除自适应滤波器的设计具有两个互相矛盾的特性，也就是快速收敛和高度的稳定性，如何同时实现这两项特性，正是设计上的主要挑战。
从应用平台来看，根据笔者多年的经验，可以把回声消除分为两大类：基于DSP等实时平台的回声消除技术和基于Windows等非实时平台的回声消除技术。两者的技术难度和重点是不一样的。有些手机的声学设计是非常不合理的（严重的麦克风扬声器耦合，非线性失真，麦克风底噪等），会使得一些通用的音频算法（回声消除，降噪）无法正常工作
网上搜索回声消除算法对比测试结果时，一般都说speex效果很差。这估计和原始音频文件的质量有关，从Q3F采集到的音频，有下面几个有点：1.回声在1ms左右，延迟非常小；2.录音和放音信号同步极为精确；3.信号失真不大，也没有网络因素影响，尤其是前两者，网上测试一般都是基于网络的语音通讯，都不会满足。

**10-25**<br>
 要注意的是，传给speex回声消除器的两个声音信号，必须同步得非常的好，就是说，在B端，接收到A说的话以后，要把这些话音数据传给回声消除器做参考，然后再传给声卡，声卡再放出来，这有一段延时，这时，B再采集，然后传给回声消除器，与那个参考数据比较，从采集到的数据中把频域和参考数据相同的部分消除掉。如果传给消除器的两个信号同步得不好，即两个信号找不到频域相同的部分，就没有办法进行消除了。
SpeexEchoState *echo_state = speex_echo_state_init(frame_size, filter_length);
  frame_size是每次处理的数据大小。filter_length也称tail_length，自适应滤波器长度。推荐的长度大概的回声时延的3分之一.  遗留问题：filter_length还需要根据场景调整吗？
要求： 1. 收发必须严格同步。2. 收发时延尽量的小。3. filter_length并非越长越好。过长可能导致难以收敛，AEC不起作用。4. speex使用的是线性自适应滤波器，对于非线性失真引入的信号畸变抵抗力差，因此应该尽量避免saturation/clipping

当前简单测试，是否frame_size大些，filter_length小点比较好？这样的前提是，延时很小。后者，可以根据延时得出filter_length

**10-24**<br>
wav文件头部格式解析代码：
```cpp
 private byte[] getWaveFileHeader(int sampleRate, int channels, int bitsPerSample, int bytePerSecond, long fileLenIncludeHeader)
 {
    byte[] wavHeader = new byte[44];
    long totalDataLen = fileLenIncludeHeader - 8;
    long audioDataLen = totalDataLen - 36;

    //ckid：4字节 RIFF 标志，大写
    wavHeader[0] = 'R'; wavHeader[1] = 'I'; wavHeader[2] = 'F'; wavHeader[3] = 'F';

    //cksize：4字节文件长度，这个长度不包括"RIFF"标志(4字节)和文件长度本身所占字节(4字节),即该长度等于整个文件长度 - 8
    wavHeader[4] = (byte)(totalDataLen & 0xff); wavHeader[5] = (byte)((totalDataLen >> 8) & 0xff); wavHeader[6] = (byte)((totalDataLen >> 16) & 0xff); wavHeader[7] = (byte)((totalDataLen >> 24) & 0xff);

    //fcc type：4字节 "WAVE" 类型块标识, 大写
    wavHeader[8] = 'W'; wavHeader[9] = 'A'; wavHeader[10] = 'V'; wavHeader[11] = 'E';

    //ckid：4字节 表示"fmt" chunk的开始,此块中包括文件内部格式信息，小写, 最后一个字符是空格
    wavHeader[12] = 'f'; wavHeader[13] = 'm'; wavHeader[14] = 't'; wavHeader[15] = ' ';

    //cksize：4字节，文件内部格式信息数据的大小，过滤字节（一般为00000010H）
    wavHeader[16] = 0x10; wavHeader[17] = 0; wavHeader[18] = 0; wavHeader[19] = 0;

    //FormatTag：2字节，音频数据的编码方式，1：表示是PCM 编码
    wavHeader[20] = 1; wavHeader[21] = 0;

    //Channels：2字节，声道数，单声道为1，双声道为2
    wavHeader[22] = (byte) channels; wavHeader[23] = 0;

    //SamplesPerSec：4字节，采样率，如44100
    wavHeader[24] = (byte)(sampleRate & 0xff); wavHeader[25] = (byte)((sampleRate >> 8) & 0xff); wavHeader[26] = (byte)((sampleRate >> 16) & 0xff); wavHeader[27] = (byte)((sampleRate >> 24) & 0xff);

    //BytesPerSec：4字节，音频数据传送速率, 单位是字节。其值为采样率×每次采样大小。播放软件利用此值可以估计缓冲区的大小；
    wavHeader[28] = (byte)(bytePerSecond & 0xff); wavHeader[29] = (byte)((bytePerSecond >> 8) & 0xff); wavHeader[30] = (byte)((bytePerSecond >> 16) & 0xff); wavHeader[31] = (byte)((bytePerSecond >> 24) & 0xff);

    //BlockAlign：2字节，每次采样的大小 = 采样精度*声道数/8(单位是字节); 这也是字节对齐的最小单位, 譬如 16bit 立体声在这里的值是 4 字节
    wavHeader[32] = (byte)(bitsPerSample * channels / 8); wavHeader[33] = 0;

    //BitsPerSample：2字节，每个声道的采样精度; 譬如 16bit 在这里的值就是16。如果有多个声道，则每个声道的采样精度大小都一样的；
    wavHeader[34] = (byte) bitsPerSample; wavHeader[35] = 0;

    //ckid：4字节，数据标志符（data），表示 "data" chunk的开始。此块中包含音频数据，小写；
    wavHeader[36] = 'd'; wavHeader[37] = 'a'; wavHeader[38] = 't'; wavHeader[39] = 'a';

    //cksize：音频数据的长度，4字节，audioDataLen = totalDataLen - 36 = fileLenIncludeHeader - 44
    wavHeader[40] = (byte)(audioDataLen & 0xff); wavHeader[41] = (byte)((audioDataLen >> 8) & 0xff); wavHeader[42] = (byte)((audioDataLen >> 16) & 0xff); wavHeader[43] = (byte)((audioDataLen >> 24) & 0xff); return wavHeader;
}
```

**10-23**<br>
继续优化下面音源文件，声音品质到3.0以上：
  ./pesq +8000 origion.aiff ./single_transfer/single_gushiji.wav|grep "Prediction : PESQ_MOS"
      Prediction : PESQ_MOS = 2.293
指定文件长度

**10-22**<br>
abctrl播放音乐文件，应该先去掉头部管理信息，虽然影响不明显，但这的确是一个bug。
测试全部使用8000采样率，16bit，单通道的音频文件。录音音量应该控制在-20db左右？

应该改写pesq代码，增加参数，调整输入文件的偏移，增加对audition保存的pcm格式文件的支持。
  void load_src( long * Error_Flag, char ** Error_Type,SIGNAL_INFO * sinfo) 函数中， Nsamples = (file_size / 2) - header_size; 是否说明应该是16bit的数据流?
想要得到高分，需要使用16bit,两个音源文件应该长度相同，并完全同步。输入参数中，可以按照ms指定长度和delta值。并且将实际比较的文件格式化输出到另外两个文件中。

**10-14**<br>
webrtc编译，shell等，smp环境spinlock同步机制
**10-13**<br>
**10-12**<br>
**10-11**<br>
**10-10**<br>
开始webrtc的工作
Speex本身的去噪效果不好，而EVRC的不错，如果把EVRC的去噪模块拿到Speex里面使用。经证明是很不错的。
webrtc的开发环境建立比较麻烦;下载的代码是基于vc的,先在windows环境下尝试吧.
**10-09**<br>
对比测试新旧两个aecv2机制,旧机制表现不稳定,40%出现消除不干净;高压测试的时候,20%出现整段消除不掉;
**10-08**<br>
aec对比测试,应该保证环境相同,比如,声音软音量大小,speaker和mic的距离.
上午,一行aecv2判断错误导致浪费了4个小时调试解决问题; 下午,对比前后语音aec处理效果,新机制应该更加干净; 发现一个问题,好像启动之后第一次比较干净,之后就脏了.

## 09-01->09-30...
**09-30**<br>
**09-29**<br>
abctrl unitest setlog -m audiobox -l ffff
**09-28**<br>
```cpp
for(( num=1; num<7; num++)) # method2
do
  echo "num=$num"
done

echo 10 12 |awk '{printf("%d\n", $1+$2)}'
echo | awk '{printf("%s\n", $HOME)}'

//读取文件行并处理
while read line
do
  echo $line
done < filename

cat filename | while read line
do
  echo $line
done

```
**09-27**<br>
10次计算时间的操作，占用6%资源；这不仅仅是资源占用的问题，还会影响到其他tasklet
dma搬运的数据，应该直接在驱动中拷贝到fr中，而不是经过alsa的周转。增加了延时的不确定性，也增加了audiobox卡顿造成的风险。
kernel中aec功能，应该通过命令和参数来控制，而不是通过宏来定义吧。
使能aec功能时，是否应该在dma阶段就直接拆分成两个独立的声道，方便以后处理
提高aec处理效果：
1. 回声和参考音音量大小应该差不多，是否应该用软音量调节参考音的大小
2. 如果播放数据延迟，是否可以自填充一些；或者增加判断，xrun发生时aec参考声道填充0；连续两个capture中断而没有playback中断时，根据playback的dma位置来判断
**09-26**<br>
软音量的设置应该允许最大值超过100，有些原始很小的声音，应该软件放大。
去掉dsp的tone的方法：
1. 增加下面函数来重置dsp，去除tone，需要大概10ms恢复，注意需要关注是否会影响到50ms超时的判断，可以考虑重启timer；但是重启之后需要1s左右的建模时间，所以，估计需要提前缓冲1s的音频数据
2. tone的数据是否固定的？可能只需要6个点就可以完全确定正弦波，处理结果扔掉重新发送packet给dsp处理；定义一个pattern数组
3. 是否可以总结过滤的规则，每固定3s时间，或者每多少个packet
4. 可以考虑综合上面两个方法，快到3s的时候，开始检测数据

```cpp
static int tl421_aec_reset_dsp(unsigned long arg)
{
	int err = 0, val;
	void __iomem *base = tl421->ipc.base;
	int mode = AEC_LOW_PROFILE_MODE;

	tl421_module_poweroff();
	tl421_module_poweron();

	writel(0, base + IPC_MCU_MASK0);
	val = readl(base + IPC_SEM0S);
	writel((val & ~(AEC_MODE_MASK)) | (mode << AEC_MODE_BIT), base + IPC_SEM0S);
	writel(0, base + IPC_COM0);
	writel(0, base + IPC_REP0);
	writel(0, base + IPC_REP1);
	writel(0, base + IPC_REP2);

	tl421_ext_wait(0);
	err = tl421_aec_wait_initiate_complete();
	if(err < 0) {
		err = -EIO;
		goto init_fail;
	}

	writel((1 << AEC_DONE_BIT), base + IPC_MCU_MASK0);
	return 0;

init_fail:
	tl421_module_poweroff();

	return err;
}
static long ceva_dsp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
      if (aec_counter > 0x7ff) {
				aec_counter = 0;
				printk(KERN_EMERG "~~~~~~~reset tl421_module_poweron() \n");
				tl421_aec_reset_dsp(arg);
			}
```
**09-25**<br>
小马的几个建议：
应该去掉所有的 AUD_DBG 信息
void *thread_audio_playback_server(void *arg)
  if (fd < 0) {
		return NULL; //最好不要直接返回
	}
int vcp7g_dsp_capture_process(struct vcp_object *vcp_obj, char * in, char * out, int len) {
  //需要区分aecv1和v2
  //#if 1
			*(spk+i) = *(in_resample_buf+(i*4)) | *(in_resample_buf+(i*4)+1)<<8;
			*(mic+i) = *(in_resample_buf+(i*4)+2) | *(in_resample_buf+(i*4)+3)<<8;
  //#else
  			*(mic+i) = *(in_resample_buf+(i*4)) | *(in_resample_buf+(i*4)+1)<<8;
  			*(spk+i) = *(in_resample_buf+(i*4)+2) | *(in_resample_buf+(i*4)+3)<<8;
  //#endif
void aecv2_fill_left_chan(struct snd_pcm_substream *capture)
  最好和aecv1统一填充右声道

**09-23**<br>
```cpp
//Examples
/* step 1: open moto device */
int moto_fd = open("/dev/moto_dev", O_RDWR);

/* step 2: optional, set moto speed at percent ratio, (10 ~ 100)*/
int freq = 100;
ioctl(moto_fd, MOTO_SET_FREQ, &freq);

t_moto_command command;
/* step 3: whirl up 180° then stop*/
command.action = MOTO_CMD_UP;
command.steps = 256;
ioctl(moto_fd, MOTO_ACTION, &command);

/* step 4: whirl up, but we could stop it manually 1s later*/
command.action = MOTO_CMD_UP;
command.steps = 5120;
ioctl(moto_fd, MOTO_ACTION, &command);
sleep(1);
command.action = MOTO_CMD_STOP;
ioctl(moto_fd, MOTO_ACTION, &command);

```

enum MOTO_CMD_ID {
	MOTO_CMD_NOP = 0,
	MOTO_CMD_STOP,
	MOTO_CMD_UP,
	MOTO_CMD_DOWN,
	MOTO_CMD_LEFT,
	MOTO_CMD_RIGHT,
	MOTO_CMD_LEFTUP,
	MOTO_CMD_LEFTDOWN,
	MOTO_CMD_RIGHTUP,
	MOTO_CMD_RIGHTDOWN,
};

int ioctl(int handle, int cmd, int *argdx);
- handle : moto device handler
- cmd :
  - MOTO_SET_FREQ : moto speed
  - MOTO_ACTION : moto commmand, listed in enum MOTO_CMD_ID.
- argdx : command parameter


**09-22**<br>
**09-21**<br>
inline int motor_checkend(int index)
  //always return 0;
**09-20**<br>
待修改驱动：
  void motor_set(unsigned char value) GPIO控制线变更
  int motor_checkend(int index) //读取gpio1_virtul_addr gpio0_virtul_addr，通过gpio电平判断是否已经转动到了极限

static tMotorActDecom motorActionDecomTable[] =
{
	{PTZ_OPT_NULL, 		STOP,		STOP},
	{PTZ_OPT_UP,		KEEP,		BACKWARD},
	{PTZ_OPT_DOWN,		KEEP,		FORWARD},
	{PTZ_OPT_LEFT,		BACKWARD,	KEEP},
	{PTZ_OPT_RIGHT,		FORWARD,	KEEP},
	{PTZ_OPT_LEFTUP, 	BACKWARD, 	BACKWARD},
	{PTZ_OPT_LEFTDOWN, 	BACKWARD, 	FORWARD},
	{PTZ_OPT_RIGHTUP,	FORWARD, 	BACKWARD},
	{PTZ_OPT_RIGHTDOWN, FORWARD, 	FORWARD},
	{PTZ_OPT_AUTO,		STOP, 		STOP},
	{PTZ_OPT_FOCUSFAR,  STOP, 		STOP},
	{PTZ_OPT_FOCUSNEAR, STOP, 		STOP},
	{PTZ_OPT_IRISOPEN, 	STOP, 		STOP},
	{PTZ_OPT_IRISCLOSE, STOP, 		STOP},
	{PTZ_OPT_ZOOMIN, 	STOP, 		STOP},
	{PTZ_OPT_ZOOMOUT,	STOP, 		STOP},
	{PTZ_OPT_POINTPRESET, STOP, 	STOP},
	{PTZ_OPT_POINTRECALL, STOP, 	STOP},
	{PTZ_OPT_POINTCLEAR,  STOP, 	STOP},
	{PTZ_OPT_MENUSHOW, 	  STOP, 	STOP},
	{PTZ_OPT_HNAVIGATE,   RUNNING, 	KEEP},
	{PTZ_OPT_VNAVIGATE,   KEEP, 	RUNNING},
	{PTZ_OPT_STOP, 		  STOP, 	STOP}
};

```cpp
void  bcm6212_gpio_init()
    error = gpio_request(bt_reset, "bcm6212");
    gpio_direction_output(bt_reset, 0);
    msleep(100);
    gpio_set_value(bt_reset, 1);
    msleep(200);
```

QEN_MotorP 使能电压  GPIO52


调试马达的环境：  分支qipc_qiwo_x30_dev setproduct 0   d318 0   960P.json 2   gc2385mipi
  repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b qipc_qiwo_x30_dev

1.下载好最新分支后进入buildroot，执行
git reset --hard 542d9a7a429b2da9ecc2c58b5c9647708a914e9a
因为这分代码的环境是ubuntu18.04，要在较早的ubuntu版本上编译需要回退部分代码。

2.仍然在buildroot目录下修改Config.in
git diff package/Config.in
diff --git a/package/Config.in b/package/Config.in
index 4e216e04..3b575dca 100644
--- a/package/Config.in
+++ b/package/Config.in
@@ -748,7 +748,6 @@ source "buildroot/package/enchant/Config.in"
 source "buildroot/package/icu/Config.in"
 source "buildroot/package/libedit/Config.in"
 source "buildroot/package/libfribidi/Config.in"
-source "buildroot/package/libiconv/Config.in"
 source "buildroot/package/linenoise/Config.in"
 source "buildroot/package/ncurses/Config.in"
 source "buildroot/package/newt/Config.in"
并删除 package/libiconv/Config.in和package/libiconv/libiconv.mk
以上部分是因为在回退代码前做裁剪时裁掉了，我怕影响到分区，所以也去掉了。
3.如果编译完做启动卡，还要修改下gendisk.sh权限，服务器上的这个脚本没有执行权限

ps：我用启动卡启动或者烧录时都遇到有时不识别内核的情况，重新上电试试，或者在不识别内核时敲biu，然后执行res重启


int imapx_asoc_platform_probe(struct device *dev) 函数应该增加一个参数， int aecv2_enable，表示这个设备aec功能被使能
//设置某个参数
static int aecv2_delay_open(struct inode *inode, struct file *file)
{
	return 0;
}
static ssize_t aecv2_delay_read(struct file *file, const char __user *buffer, size_t count, loff_t *data)
{
	printk(KERN_EMERG "preset_offset: 0x%x\n", preset_offset);
	return 0;
}

static ssize_t aecv2_delay_write(struct file *file, const char __user *buffer, size_t count, loff_t *data)
{
	char delay[8];
	if (copy_from_user(&delay, buffer, 4)) {
		return -1;
	}
	delay[5] = 0;
	preset_offset = simple_strtol(delay, NULL, 10);
	printk(KERN_EMERG "preset_offset: %d\n", preset_offset);
	return 4;
}

static struct file_operations aecv2_delay_fops = {
  .open = aecv2_delay_open,
  .read = aecv2_delay_read,
  .write  = aecv2_delay_write,
};

static int __init aec_delay_init(void)
{
	proc_create("aec_delay", 0, NULL, &aecv2_delay_fops);
  	return 0;
}
__initcall(aec_delay_init);

**09-19**<br>

**09-18**<br>
调整代码实现，发现还是有playback数据被破坏的情况，导致回声消除效果不佳。
配合当前的Playbuffer使用； playback的pos正常处理，capture延迟填充，可以增加一个判断，如果当前capture_pos加上offset,调整值到正常范围后，小于playback的pos,就代表需要继续等待

或者，capture和playback都延迟一个period上报。
**09-17**<br>
调试aec2.0代码
**09-16**<br>
makefile.am configure.in automake机制的复习
**09-15**<br>
思考aec功能的基本机制，确定两个buffer的偏移计算方式
**09-14**<br>
aec实现改进的考虑，应该可以把dma操作分成两步骤，第二步要达到录音比放音中断晚固定的采样点个数，可以定制插入一个slave_dma的请求；这个请求可以在某个录音或者放音的中断中提出；同时，还需要考虑到，当前tasklet可能带来ms级别的误差

调用 int pl330_dma_getposition(struct dma_chan *chan, dma_addr_t *src, dma_addr_t *dst) 函数，读取capture和playback两个通道的当前指针和当前dma_pos，从而准确确定两者的相对偏移时间。

在 capture的 imapx_audio_buffdone() 函数中，判断，如果状态从单通变为双通，那么判断偏移时间；之后每个capture中断中，根据偏移填充capture数据；务必保证两者的buffer足够大，不要被overrun.

需要知道通道是否启动了aec,所以，需要增加额外的函数来配置参数。现在只是一个aec2.0的宏，绝对不够；如果aec2.0工作正常，应该取消v1.0；需要对端substream的指针。提供填充左声道的函数，基于对端playback substream填充数据；不需要额外的buffer,只需要增加几个索引就好。

**09-13**<br>
abctrl unitest setlog -m audiobox -l 1ffff
abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 77 -z 85 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 5 -o /mnt/sd0/record_1.wav
abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/record_1.wav -v 100
rm /mnt/sd0/record_1.wav
sleep 1

abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 77 -z 85 &
abctrl record -w 32 -s 16000 -n 2 -t 5 -o /mnt/sd0/record_1.wav

modprobe ceva-dsp
audiobox > /dev/null &
abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 77 -z 85 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 5 -o /mnt/sd0/record_1.wav

abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 21 -z 34 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 10 -o /mnt/sd0/record_1.wav


abctrl play -w 32 -f 256 -s 16000 -n 2 -d /mnt/sd0/music.wav  -v 100 -y 21 -z 48 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 20 -o /mnt/sd0/record_1.wav


**09-12**<br>
调试codec,需要频繁改变其内部寄存器实现测试，找到或者实现工具

**09-11**<br>
几个可能需要调整的地方：
1. dma中断模式
2. 是否应该增加delay参数，模拟本地回声延时，不同的产品，回声路径导致的延时不同
3. 验证一下，播放和录音的中断是否时间基本一致，因为它们对应于同一次i2s传输；i2s的传输，是否应该是基本实时的过程，不可能一次传送很多数据，codec慢慢播放
4. 回声处理，如果要求实时，是否应该改为在驱动中完成，而不是经过audiobox转折

dma_size缺省为2，`imapx_i2s_set_sysclk()`函数中另行设定，一般应该是4；burst_len在`imapx_dmadev_request()`函数中固定设置为8；所以dma一次搬移32byte数据；基本可以认为，音频的播放和录音是实时的。一个period,

**09-10**<br>
```cpp
void capture_fill_right_chan(uint8_t *pos, uint32_t len)
  p_cap_rd += step; /* just consume it */ //代码是否错误
void dump_playback_data(uint8_t *pos, uint32_t len)
  if (play_sync > SAVED_PERIOD)  //奇怪的逻辑,不是应该直接覆盖,并且保持play_sync不变的么?
void imapx_audio_buffdone(void *data) //中断callback函数中,应该尽量简单,会否导致xrun,或者
  //一次总共传输多少数据,应该不重要;重要的是每个period对应一个中断回调就好
  imapx_pcm_update(substream);//调用层次中,好像包含有usleep()函数,待验证
```

**09-09**<br>
```cpp
解析下面的命令
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-addr2line
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-gprof
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-ranlib
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-readelf
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-size
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-strings
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-ldd
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-strip
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-nm
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-gcov
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-objcopy
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-elfedit
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-objdump
~/work/bak_0_repo/buildroot/prebuilts/uclibc-4.7.3/bin/arm-buildroot-linux-uclibcgnueabihf-gdb
```
**09-04**<br>
```cpp
//内核中操作文件的方法
static int tl421_printf_dump(char * file_path, unsigned int offset, unsigned int len)
  fp = filp_open(file_path, O_RDONLY, 0644);
  fs = get_fs();	set_fs(KERNEL_DS);
  vfs_read(fp, (char *)&buf, sizeof(uint16_t), &pos);
  filp_close(fp, NULL);
	set_fs(fs);
  //这个函数中包含文件系统在内核内使用的流程，
```

```cpp
int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
  int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
    ret = adap->algo->master_xfer(adap, msgs, num);

  static int imapx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num);
  static uint32_t imapx_i2c_func(struct i2c_adapter *adap);
  static struct i2c_algorithm imapx_i2c_algo = {
  	.master_xfer = imapx_i2c_xfer,
  	.functionality = imapx_i2c_func,
  };
```

**09-03**<br>
## 08-01->08-27...
**08-31**<br>
精简 module_power_on power clock等
增加preuboot0模块，加快uboot0加载过程

新增模块加载uboot0的话，定义好32k,dma只需要一次传输就好，处理可以简化。可以考虑，直接手工定制dma的微指令；dma去掉发送方向代码;dry_run全是0；clear_desc_buf函数改写

```cpp
static int __ref kernel_init(void *unused)
	kernel_init_freeable();
	async_synchronize_full();
	free_initmem();
	mark_rodata_ro();
	system_state = SYSTEM_RUNNING; //会否影响到多线程调度或者中断处理呢？
```

**08-30**<br>

`find . -iname built-in.o -exec ls {} -l \;`

ld各模块大小：
-rw-rw-r-- 1 yuan yuan 258194 8月  30 15:56 ./sound/built-in.o
-rw-rw-r-- 1 yuan yuan 759445 8月  30 15:56 ./fs/built-in.o
-rw-rw-r-- 1 yuan yuan 315940 8月  30 15:55 ./mm/built-in.o
-rw-rw-r-- 1 yuan yuan 45018 8月  30 15:56 ./init/built-in.o
-rw-rw-r-- 1 yuan yuan 115149 8月  30 15:56 ./lib/built-in.o
-rw-rw-r-- 1 yuan yuan 100444 8月  30 15:55 ./arch/arm/mach-q3f/built-in.o
-rw-rw-r-- 1 yuan yuan 25276 8月  30 15:55 ./arch/arm/vfp/built-in.o
-rw-rw-r-- 1 yuan yuan 57474 8月  30 15:55 ./arch/arm/mm/built-in.o
-rw-rw-r-- 1 yuan yuan 93731 8月  30 15:55 ./arch/arm/kernel/built-in.o
-rw-rw-r-- 1 yuan yuan 151809 8月  30 15:55 ./block/built-in.o
-rw-rw-r-- 1 yuan yuan 1367805 8月  30 15:56 ./drivers/built-in.o
-rw-rw-r-- 1 yuan yuan 586877 8月  30 15:56 ./kernel/built-in.o
最后image大小：
-rw-rw-r-- 1 yuan yuan  1088472 8月  30 15:56 uImage
-rwxrwxr-x  1 yuan yuan 2912847 8月  30 15:56 vmlinux*
-rw-rw-r--  1 yuan yuan 3888614 8月  30 15:56 vmlinux.o

**08-29**<br>
有几个问题，不解：
1. system很大，如果必须压缩，freertos怎么办，支持squashfs会否还是很慢
2. 某些驱动本身会化时间
3. 工具链是否需要变化，还是继续使用Linux的，有何区别？
4. 是否可以借用原有的buildroot架构，是否可以为应用程序的重构减少一些负担？由于kernel是基于Kconfig搭建，删除原有的目录就可以自动完成清理工作
5.
**08-28**<br>
初步解析bsp开发流程：
- 确定编译开发环境，定义新的repository作为开发基础
- 实现基本的clock, timer, dma驱动模块，完善中断机制
- 提供OS中间件接口给BSP调用(可选)
- 实现uart和控制台功能，以支持命令行开发调试，后续过程即可并行开发；uart之前采用低效的Polling模式工作
- 逐个实现基本接口： iic, iis, pcm, pwm, gpio, global timer, cmn timer, watchdog, adc, spimul, ssp, rtc, codec, IR ,bt ,usb ,fr ,ftl, ethernet, SD/SDIO/eMMC控制器
- 集成lwip
- 实现ceva-dsp
- 实现音频系统重构
- 实现第三方wifi驱动
- 实现安全子系统
- 实现显示子系统
- 实现视频相关: isp, VENC, FODET, ISPOST, MIPI，不考虑

寻找freertos posix wrapper，否则需要自己编写
全新的开源音频框架 (Audio Development Framework, ADF)，它是基于 FreeRTOS 操作系统，轻量化、可裁剪、高度灵活，支持多种 Codec IC、编解码格式、音乐格式和语音识别服务。

开发时间以单人工作量计, 按照以下几个基本模块来预估:
1. 基础部分: (10 weeks)
    - 编译开发环境
    - clock pmu cmn_timer global_timer 中断
    - uart驱动控制台诊断机制
    - dma
    - fr和cma
2. 存储子系统：(6 weeks)
    - spimul, ssp, flash
    - SD/SDIO/eMMC控制器
    - ftl
3. 音频子系统，作为一个整体来实现, (14 weeks)
    - iic, iis, pcm, audio_codec
    - aec/aac等
    - 替代ALSA的音频框架
    - audiobox cep eventhub 调整
4. misc io: (10 weeks)
    - pwm gpio adc IR bt watchdog usb
5. network: (8 weeks)
    - wifi/ethernet/lwip
OS中间件: (未评估)
显示子系统: (未评估)
安全子系统: (未评估)
视频系统: (未评估)
系统集成: (未评估)

**08-27**<br>
freertos kernel移植基本完成，内核加载、内核启动、中断、tick、任务切换、消息队列等基本机制调试完成, 创建两个互相定时乒乓发送消息的的task, 运行4天没有出现错误

freertos基本移植过程：
1. 下载最新v10.1.0版本
    下载地址： https://sourceforge.net/projects/freertos/
2. 解压之后从中截取如下内容生成新的freertos模块，保存到freertos目录：
  ./FreeRTOS/Source/portable/GCC/ARM_CA9文件夹下，cpu相关部分： portASM.S port.c portmacro.h
  ./FreeRTOS/Source/portable/MemMang文件夹下，动态内存管理：heap_4.c
  ./FreeRTOS/Source/文件夹下c文件，内核核心代码: event_groups.c list.c queue.c stream_buffer.c tasks.c timers.c
  ./FreeRTOS/Source/include文件夹下所有头文件；
  ./FreeRTOS/Demo/CORTEX_A9_Zynq_ZC702文件夹下文件，需要移植中断、timer、tick相关bsp和测试范例，其他内容需要裁剪
3. 使用arm-buildroot-linux-uclibcgnueabihf工具链编译freertos工程，过程中裁剪不必要的demo文件, 编译完成之后进入下一步
4. 添加freertos模块到qsdk工程中，之后调试可以直接执行`make freertos-rebuild`编译
   - 在bootloader/下，添加上述freertos目录
   - 在buildroot/boot/下，添加freertos的config目录，里面包含Config.in和freertos.mk两个文件
5. 调试freertos模块(后面详细描述)
   - 调整makefile
   - 加载中断向量表，设定ARM各工作模式下stack
   - 移植GIC、TIMER模块
   - 增加printf支持
   - 深度裁剪冗余代码
6. 制作启动卡并用来启动freertos demo
  - 在tools/下，添加新的genfreertos.sh脚本，用来构建包含uboot0.isi、items.itm和freertos.isi的启动卡
  - 启动过程: irom -> uboot0 -> freertos

**08-26**<br>
**08-25**<br>
**08-24**<br>

**08-23**<br>
GIC相关代码和linux内核部分了解。https://blog.csdn.net/xiafeng1113/article/details/44998179
确定调整timer的clk配置， #define XSCUTIMER_CLOCK_HZ (1536*1000*1000/18UL)，tick基本准确
**08-22**<br>
调整freertos代码，整理代码，包括裁剪掉60多个头文件； 增加vsprintf.c等文件,uclibc库不支持完整的库，或者是我编译选项定义的有问题。
**08-21**<br>
北京，颐和园
**08-20**<br>
北京，长城
**08-10**<br>
freertos, 放在iram中,包括中断向量表,这样需要relocate; 估计应该在lds中增加 MEMORY字段,模仿Irom的配置. 只从dram中分配动态的内存. 暂时这样,以后不可以,因为data大小需要扩展的.

**bak_0_repo使用uboot0环境编译出uboot0.isi,拷贝到bak_1_repo作为uboot1.isi使用.**<br>
  make uboot-dirclean;
  make uboot-rebuild; cp -f /home/yuan/work/bak_0_repo/output/images/uboot0.isi /home/yuan/work/bak_1_repo/output/images/uboot1.isi
  ./tools/gendisk.sh /dev/sdb


定义`CONFIG_USE_IRQ`来开启uboot1的中断和堆栈设置

**08-09**<br>
确定工商银行下一个项目.
裁剪uboot到5k和12k两个版本,然后开始移植freertos了.
**08-08**<br>
今天阅读freertos部分代码.
下一步计划:
  1. 在uboot代码中,加载中断向量表,增加中断处理
  2. 增加timer启动停止和中断配置,确认tick功能正常,代码参考irom部分 init_timer()
  3. 集成freertos代码到uboot中

~/work/0sproject/kernel/arch/arm/mach-q3f/include/mach/irqs.h
  //#define IMAP_GIC_CPU_BASE	(IMAP_SCU_BASE + 0x100)

```cpp
static void __init q3f_init_irq(void)
{
	/* start from 29 to enable local timer */
	gic_init(0, 29, IO_ADDRESS(IMAP_GIC_DIST_BASE),
			IO_ADDRESS(IMAP_GIC_CPU_BASE));
	return;
}
```

**08-07**<br>
freertos移植:
  1. 编译;2. 下一步,修改lds;3. 使用uboot0加载
**08-06**<br>
freertos移植:
  编译成功,基于cortex a9和CORTEX_A9_Zynq_ZC702 demo, 中间.s文件编译出错不识别某些指令,增加-mfpu=NEON之后问题解决.
  基于altera的FPGA版本,是一个失误;切换到CORTEX_A9_Zynq_ZC702工程,浪费了一些时间

```cpp
//测试脚本
    while true; do
			videoboxd > /dev/null
			frinfo_ok=`cat /proc/fr_info | grep -c '32.38M'`;echo $frinfo_ok
			echo "step 1"
			echo "Show frinfo_ok : [ $frinfo_ok ]";
			echo "step 2"
			if [ "$frinfo_ok" == "0" ]; then
				echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~initiate videobox failed~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
				break;
			fi
			echo "step 3"
			sleep 1;
			killall videoboxd
			sleep 1;
			echo "step 4"
			cat /proc/meminfo > /dev/null;echo 3 > /proc/sys/vm/drop_caches;cat /proc/meminfo | grep "MemFree"
			echo "step 5"
		done
```
## 07-01 -- 07-30->...
**07-27**<br>
本周主要工作内容：
1. 在qiwo门铃上重现videobox申请fr内存失败的问题，并压缩测试条件，基本能保证5分钟之内重现；
2. 在qiwo门铃上移植预留fr内存的新功能，压力测试20小时，申请fr内存失败的问题不再重现
3. 在qiwo门铃上改变CMA迁移算法，原机制先分配最大块的CMA内存，改为先分配满足条件的最小CMA内存块，压力测试1小时，申请fr内存失败的问题不再重现
4. 在qiwo门铃上跟踪问题，发现CMA中内存碎片是由squashfs中管理inode产生的，它从CMA申请的内存无法归还，而同时启动的应用越多，这个inode占用的内存越多，就越容易出现CMA内存不够的问题

下周重现大分辨率拍照测试时申请fr内存失败的问题; jim说最新版本可能改动了一些相关的内容，会导致问题难以重现，所以，可以不测试。

**07-26**<br>
测试，videobox增加参数，控制其执行还是halt,多个halt的程序，应该会占用大量内存，尝试重现场景。

**07-25**<br>
尝试重现qiwo门铃内存分配fr失败问题。
**07-24**<br>

除了足够的fr内存之外，videobox启动还需额外的内存用于程序加载和堆栈等，这个大小缺省是8M，通过ulimit -s 1024可以调整缺省堆栈为1M，那么至少仍然需要3.5M。所以如果应用在videobox之前启动并占用大量内存的情况下，videobox可能因为普通内存不足而启动失败。
//预留34M
cma -f 0 -s 4 -m 3500 -l 1 -t 1 &
//预留35M
cma -f 0 -s 4 -m 3300 -l 1 -t 1 &
sleep 1
cat /proc/meminfo > /dev/null;echo 3 > /proc/sys/vm/drop_caches;cat /proc/meminfo | grep "MemFree"
ulimit -s 1024
videoboxd &

//对比测试1： 允许迁移
//老版本允许迁移videobox终止；新版本cma测试程序终止
cma -f 0 -s 4 -m 5000 -l 1 -t 1 & 直接
sleep 1
videoboxd &

当应用程序申请过多内存时，保护videobox启动，预留足够的fr, 但是mmap内存怎么办？
保护videobox启动，

cma迁移的配置以及预留fr内存的机制，会影响到应用可用内存，测试如下：
//应用程序可用内存测试,保障videobox在3s内完成启动
  //禁止迁移，测试程序可申请4k内存3100次
  cma -f 0 -s 4 -m 3100 -l 1 -t 1 &
  //允许迁移，预留35m，测试程序可申请4k内存3300次
  cma -f 0 -s 4 -m 3300 -l 1 -t 1 &
  //允许迁移，预留34m，测试程序可申请4k内存3500次
  cma -f 0 -s 4 -m 3500 -l 1 -t 1 &
  //允许迁移，无预留fr，测试程序可申请4k内存3700次
  cma -f 0 -s 4 -m 3700 -l 1 -t 1 &
  ulimit -s 1024
  sleep 1
  videoboxd


**07-23**<br>
```cpp
//cma测试程序
//#include <stdio.h>
//#include <stdlib.h>
//#include <unistd.h>
//#include <fcntl.h>
//#include <fr/libfr.h>

int main(int argc, char *argv[])
{
	int opt;
	int blksize = -1;
	int mblknum = -1;
	int cmaflag = 0;
	int fstep = -1;
	char echar;
	int loopcnt = -1;
	int curnum = 0;
	char str[20];
	void * (ptr[1024*32]);
	int total_malloc = 0;
	int total_free = 0;
	int total_fail = 0;
	int mblknum_loc;
	int wait_time = 2000;//seconds
	struct fr_info fr;
	char fr_name[128];

	memset(ptr, 0, sizeof(void*)*4096);

	while((opt = getopt(argc, argv, "s:m:f:l:w:t:"))!=-1) {
		switch (opt) {
		case 's':
			blksize = 1024*atoi(optarg);
			break;
		case 'm':
			mblknum = atoi(optarg);
			break;
		case 'f':
			fstep = atoi(optarg);
			break;
		case 'l':
			loopcnt = atoi(optarg);
			break;
		case 'w':
			wait_time = atoi(optarg);
			break;
		case 't':
			cmaflag = atoi(optarg);
			break;
		case '?':
			echar = (char)optopt;
			printf("argument error, opt char is \' %c \'!\n", echar);
			break;
		}
	}

	if (blksize <= 0 || mblknum <=0 || fstep <0 || loopcnt<=0 || mblknum >= 1024*32) {
		printf("error para value. %d, %d, %d, %d\n", blksize, mblknum, fstep, loopcnt);
		return -1;
	}
	printf("size=%08x, mblknum=%08x, fstep=%08x, loopcnt=%d, waittime=%d cmaflag=%d\n"
		, blksize, mblknum, fstep, loopcnt, wait_time, cmaflag);

		printf("start test loop %d\n", loopcnt);
		while(loopcnt-- > 0) {
			if (cmaflag & 0x1) {
				curnum = 0;
				mblknum_loc = mblknum;
				while (mblknum_loc-- > 0) {
					ptr[curnum] = malloc(blksize);
					if(ptr[curnum])
						memset(ptr[curnum], 1, blksize);
					else {
						total_fail++;
						printf("malloc(%d) failed %d, total: malloc=%d free=%d, fail=%d\n", blksize, ptr, total_malloc, total_free, total_fail);
					}
					if (fstep!=0 && curnum%fstep==0 && ptr[curnum]>0) {
						free(ptr[curnum]);
						ptr[curnum] = 0;
					}

					total_malloc++;
					curnum++;
				}
			}

			if (cmaflag & 0x2) {
				mblknum_loc = mblknum;
				while (mblknum_loc-- > 0) {
					snprintf(fr_name, sizeof(fr_name), "pid%d_%d", getpid(), mblknum_loc);
					if (fr_alloc(&fr, fr_name, blksize, 1) != 0) {
						total_fail++;
					}else
						;//printf("fr_name: %s\n", fr_name);
					total_malloc++;
				}
			}
		}

		if (cmaflag&0x4) {
			curnum -= 1;
			while (curnum > 0) {
				if(ptr[curnum]) {
					free(ptr[curnum]);
					total_free++;
				} else
					break;
				curnum -= 1;
				printf("cmaflag: %d curnum: %d\n", cmaflag, curnum);
			}
		}

		printf("\n~~~~~~~~~~~~~~~~~~~~~~~~End test: cmaflag=%d~~~~~~~~~~~~~~~~~~~~~~~~\n", cmaflag);
		sleep(500);

	return 0;
}

```
**07-20**<br>
**07-19**<br>
**07-18**<br>

**07-17**<br>
几种修改方式:
1. 所有的驱动中,dma_alloc_coherent()和dma_free_coherent()调用替换为新的函数接口,只需要在get_dma_ops()中添加一行
2. 所有的驱动中,dma_alloc_coherent()和dma_free_coherent()中dev参数变更为新的api接口对应的dev,set_dma_ops()函数关联两者
3. 驱动和fr分开申请内存
**07-16**<br>
```cpp
mmc_test 6 &测试:
terminate called after throwing an instance of 'std::system_error'
  what():  Resource temporarily unavailable

```
**07-13**<br>
确定预留内存方法,测试也发现,上层应用需要借用不到1M的CMA,否则运行错误.所以,节省内存是必须的.
修改kconfig文件的过程中,编译出错,然后就再也恢复不了;两种办法解决问题:1. 代码移植到另外一个目录 2. 比较发现了主要差异, git checkout /kernel/scripts尝试

trace控制
```cpp
extern int 	dmaconti_debug;
extern int 	dmabmp_debug;

//#define dmacontigdebug(fmt, args...) ({				\
	if (unlikely(dmaconti_debug))			\
		printk(KERN_DEBUG	"dma_contig::%s " fmt, __func__, ## args);		\
})

early_param("cma", early_cma);

```
**07-12**<br>
调整分配算法的实现,发现纠结点:预留的fr大小应该设定为多少.
**07-11**<br>
整理和移植bitmap算法的打印信息
**07-10**<br>
videobox启动关闭循环失败,跟踪之后发现是上层的问题;改变测试方法
**07-09**<br>
整理完成内存管理文档,最后使用html格式分享,和md转换最不会丢失信息.讨论完成之后,开始实现.
**07-06**<br>
**07-05**<br>
fr分配内存时, flag为 : GFP_KERNEL|__GFP_NOWARN 或者 GFP_KERNEL

**07-04**<br>
为bitmap增加诊断机制,文档化
**07-03**<br>
为bitmap增加诊断机制
**07-02**<br>
整理CMA实现算法
```cpp
//解析代码,一定要确保下面判断是无效的
if (PageHighMem(page))
//解析下面函数,详细
bitmap_find_next_zero_area()

addr = __alloc_from_contiguous(dev, size, prot, &page, caller);
int dma_alloc_from_coherent(struct device *dev, ssize_t size,dma_addr_t *dma_handle, void **ret)
pageno = bitmap_find_next_zero_area(cma->bitmap, cma->count, start, count, mask);
pageno = bitmap_find_free_region(mem->bitmap, mem->size, order);
  //没有对齐的操作,所以,应该使用bitmap_find_next_zero_area的一套接口来实现.

bitmap_find_next_zero_area()

//参考下面的函数来实现,或者,感觉可以直接使用
static void *__alloc_from_pool(size_t size, struct page **ret_page)
	struct dma_pool *pool = &atomic_pool;
	unsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;
	align_mask = (1 << get_order(size)) - 1;
	spin_lock_irqsave(&pool->lock, flags);
	pageno = bitmap_find_next_zero_area(pool->bitmap, pool->nr_pages, 0, count, align_mask);
	bitmap_set(pool->bitmap, pageno, count);
	ptr = pool->vaddr + PAGE_SIZE * pageno; 	*ret_page = pool->pages[pageno];
	spin_unlock_irqrestore(&pool->lock, flags); 	return ptr;
static int __init atomic_pool_init(void)
	int bitmap_size = BITS_TO_LONGS(nr_pages) * sizeof(long);
	bitmap = kzalloc(bitmap_size, GFP_KERNEL);
	pages = kzalloc(nr_pages * sizeof(struct page *), GFP_KERNEL);
	ptr = __alloc_from_contiguous(NULL, pool->size, prot, &page, atomic_pool_init);
	for (i = 0; i < nr_pages; i++)			pages[i] = page + i;
	spin_lock_init(&pool->lock);
  pool->vaddr = ptr;		pool->pages = pages;		pool->bitmap = bitmap;		pool->nr_pages = nr_pages;
}
//下面函数改写,增加对应的init函数,控制好所有对应的bitmap.
void *__alloc_from_contiguous(struct device *dev, size_t size, pgprot_t prot, struct page **ret_page, const void *caller)

模仿atomic_pool_init()函数,分配内存部分,好像bitmap已经初始化过
cma_create_area()函数中初始化,和atomic_pool_init()地位相同
cma初始化的时候,每个page增加下面处理:
  __dma_clear_buffer(page, size);
    void *ptr = page_address(page);
  	memset(ptr, 0, size);
  	dmac_flush_range(ptr, ptr + size);
  	outer_flush_range(__pa(ptr), __pa(ptr) + size);//eric : empty function
  __dma_remap(page, size, prot);
    apply_to_page_range(&init_mm, start, size, __dma_update_pte, &prot);
  	dsb();
  	flush_tlb_kernel_range(start, end);
  ptr = page_address(page);
```

----
## 06-04->06-29
**06-28**<br>
请假,带父亲到医院检查心功能.
**06-28**<br>
感觉,可以直接移植最新版本的coherent.c函数中内容,初始化的时候直接增加core_init,保证在普通驱动之前初始化就好.
CONFIG_CMA 估计不能禁止
不是必须用fr的struct device指针作为申请内存时的dev参数,直接使用全局的就好. 在新的驱动文件中定义,core_init函数中申请并且使用系统全局的CMA初始化.

```cpp
struct cma *dma_contiguous_default_area; //包含了

void __init arm_memblock_init(struct meminfo *mi, struct machine_desc *mdesc)
  dma_contiguous_reserve(min(arm_dma_limit, arm_lowmem_limit));

```
void dma_contiguous_early_fixup(phys_addr_t base, unsigned long size);

struct dma_coherent_mem {
	void		*virt_base;
	dma_addr_t	device_base;
	unsigned long	pfn_base;
	int		size;
	int		flags;
	unsigned long	*bitmap;
	spinlock_t	spinlock;
	bool		use_dev_dma_pfn_offset;
};

dma_declare_coherent_memory
dma_init_coherent_memory

__dma_clear_buffer(page, size);
__dma_remap(page, size, prot);
ptr = page_address(page);

如果进入buddy,那么就会有clear和remap的要求,但如果不进入,那么直接计算就可以得到相关的地址信息.

可以直接给common CMA赋予一个

struct device *GLOBAL_CMA;

//#define dma_alloc_coherent(d, s, h, f) dma_alloc_attrs(d?d:GLOBAL_CMA, s, h, f, NULL)

或者修改下面函数就好, dev为NULL的时候,不调用arm_dma_ops,直接

static inline struct dma_map_ops *get_dma_ops(struct device *dev)
{
	if (dev && dev->archdata.dma_ops)
		return dev->archdata.dma_ops;
	return &arm_dma_ops;
}

之后需要对比最新版本的情况.

用到的数据结构:
    struct dma_coherent_mem {
	    void		*virt_base;
	    dma_addr_t	device_base;
	    phys_addr_t	pfn_base;
	    int		size;
	    int		flags;
	    unsigned long	*bitmap;
    };
    struct dma_coherent_mem	*dma_mem; /* internal for coherent mem
        mem->size
        mem->bitmap
        mem->device_base
        mem->virt_base
        mem->flags
        dev的用处应该只是获取到这个指针.
    //struct cma *cma_area;		/* contiguous memory area for dma


dma_declare_coherent_memory()函数申请这个指针和对应内存,并且初始化之

**06-27**<br>
**需求**
videobox和客户应用共享使用CMA内存,内存总容量够用的前提下,videobox可能会在某些场景下分配大块连续内存失败.已知场景至少包括:
- 客户高优先级程序和videobox进程同时后台启动,竞争CMA内存,可以参考`RM#6667 videobox 启动出现几率性失败`
- videobox改变分辨率

`RM#6667`问题中david已经确认在内核配置中打开CONFIG_CMA_MIGRATE_OFF的宏,禁止用户程序对CMA内存的抢占,可以避免上述情况的出现. 本文的目标是尝试改善内存管理的方式,允许用户程序占用CMA内存的情况下,避免videobox在剩余内存足够的情况下分配连续内存失败. 客户程序恶意占用过量内存的情况不在本文考虑范围内.

**分析1 内存资源两种统计管理方式**<br>
- bitmap算法,CMA中每一个page都对应bitmap中一个bit,此bit为1代表page已经被分配,为0代表空闲.分配连续内存的时候,在bitmap中寻找第一个连续为0的bit区域,并设置为1;释放内存的时候将此bit区域清0
- 伙伴系统,这是linux内存管理基本算法,不在此介绍;videobox和客户应用共享使用CMA内存的时候,CMA内存初始化时会被释放到伙伴系统中.

**分析2 cma内存申请和释放流程**<br>
下面大概列出申请和释放cma内存的基本调用流程:
```cpp
dma_alloc_coherent(dev, ...)
  |--> dma_alloc_attrs(dev, ...)
    |--> arm_dma_alloc(dev, ...)
      //if (dma_alloc_from_coherent(dev, size, handle, &memory))  return memory;
      |--> return __dma_alloc(dev, size, handle, gfp, prot, false,__builtin_return_address(0)); //dev非空的情况
        |--> return __alloc_from_contiguous(dev, size, prot, &page, caller);
          |--> page = dma_alloc_from_contiguous(dev, count, order);
            pageno = bitmap_find_next_zero_area(cma->bitmap, cma->count,start, count, mask);//从bitmap中找到符合条件的连续内存
            pfn = cma->base_pfn + pageno;
            ret = alloc_contig_range(pfn, pfn + count, MIGRATE_CMA);//从伙伴系统中申请内存
            bitmap_set(cma->bitmap, pageno, count);//在bitmap中标注内存已被占用
            return pfn_to_page(pfn);

dma_free_coherent(dev, ...)
  |--> dma_free_attrs(dev, ...)
    |--> __arm_dma_free(dev, ...)
      if (dma_release_from_coherent(dev, get_order(size), cpu_addr))  return;//dev非空的情况
      |--> __free_from_contiguous(dev, page, cpu_addr, size);
        |--> dma_release_from_contiguous(dev, page, size >> PAGE_SHIFT);
          bitmap_clear(cma->bitmap, pfn - cma->base_pfn, count); //清除bitmap中对应位域
          free_contig_range(pfn, count);//释放内存到伙伴系统
```

`dma_alloc_coherent()`函数第一个参数`dev`确定了它的两种主要使用场景:<br>
- `dev`为`NULL`
  同时使用了bitmap和伙伴系统两种算法管理内存<br>
  申请系统公有的CMA,当前fr和驱动模块都是此种方式<br>
- `dev`为具体设备指针
  仅使用bitmap算法管理内存<br>
  设备独享自定义的私有CMA,当前系统中未使用此种方式<br>

**分析3 改进方向**<br>

videobox分配内存失败后`cat /proc/pagetypeinfo`的显示结果如下:
```
  Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, zone   Normal, type    Unmovable      0      1      2      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type  Reclaimable     70     92     52      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Movable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Reserve      0      0      0      1      0      0      1      1      1      1      0
Node    0, zone   Normal, type          CMA   2161   2160    356      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0

Number of blocks type     Unmovable  Reclaimable      Movable      Reserve          CMA      Isolate
Node 0, zone   Normal            1            1            3            1           10            0
```

用户的应用程序大量抢占CMA的内存后产生过多CMA内存碎片,导致videobox无法申请到足够长的连续内存. 基于此,有两个疑点:
- 碎片过于琐碎,完全没有8或更多page的碎片,怀疑分配算法是否合理
- 伙伴系统有碎片整理的能力,但没有生效,怀疑碎片回收的算法有缺陷

比较系统的跟踪内核相关内存管理部分逻辑之后,我认为现有的cma机制本身如果能够解决上面两个问题,可以满足我们内存使用的需求

**CMA迁移算法bug**<br>
跟踪应用层`malloc()`函数调用流程到`__alloc_pages_nodemask()`

```cpp
__alloc_pages_nodemask()
  |--> get_page_from_freelist()
    |--> buffered_rmqueue()
      |--> __rmqueue()
        page = __rmqueue_smallest(zone, order, migratetype);
        if (unlikely(!page) && migratetype != MIGRATE_RESERVE)
          |--> page = __rmqueue_fallback(zone, order, migratetype);
            for (current_order = MAX_ORDER-1; current_order >= order; --current_order) {
  		        for (i = 0;; i++) {
                migratetype = fallbacks[start_migratetype][i];
                ...
              }
            }
```

应用层调用`__rmqueue_smallest()`申请不到通用内存时,就会调用`__rmqueue_fallback()`从CMA申请内存. 阅读代码时发现逻辑上存在严重问题,检查分配的循环每次从`current_order = MAX_ORDER-1`开始,也就是说每次优先分配最大的内存块,这种逻辑就是个内存粉碎器. 比如我们有10个4M大小的CMA块,10次调用分配之后,哪怕只是分配4k小内存,我们就只剩下10个2M大小的块和大量小碎片;反复大量调用后,最后就只会剩下4k和8k碎片.

简单尝试修改逻辑如下进行测试,不会再出现碎片:
```cpp
  ...
    for (current_order = order; current_order <= MAX_ORDER-1; current_order++) {
    		for (i = 0;; i++) {
        }
    }
```

查看最新linux4.18 kernel,这部分代码也已经被修正,系统优先分配小的CMA块

**碎片整理问题**<br>
这涉及到更复杂的流程,尚未发现问题根源,需要更多时间跟踪. 这应该是超量碎片场景下会出现的问题,修正内存分配算法中逻辑错误之后,没有再次发现

**06-26**<br>

void show_free_areas(unsigned int filter)

void refresh_cpu_vm_stats(int cpu)  计算cpu内存

void drain_zonestat(struct zone *zone, struct per_cpu_pageset *pset)

void zone_page_state_add(long x, struct zone *zone,enum zone_stat_item item)
unsigned long zone_page_state(struct zone *zone,	enum zone_stat_item item)

unsigned long global_page_state(enum zone_stat_item item)
unsigned long zone_page_state(struct zone *zone,enum zone_stat_item item)
void __inc_zone_state(struct zone *zone, enum zone_stat_item item)
__inc_zone_page_state(struct page *page,enum zone_stat_item item)
void __dec_zone_state(struct zone *zone, enum zone_stat_item item)

**06-25**<br>
----
**06-22**<br>
本周进展:
1.跟踪CMA机制内存alloc过程,发现可移动页不足导致从CMA迁移的时候分配算法不合理,会导致CMA内存出现大量碎片;简单尝试修改算法之后,不再出现碎片,在系统绝大部分内存都被分配出去的场景下,前者为videobox分配内存失败而后者成功;
2.跟踪CMA机制内存free过程,确认了CMA机制中包含对可移动页的碎片整理功能,只是客户的场景中碎片整理失败;暂时停止此方向的跟踪,等确定最终实现方案之后再决定是否继续分析解决;
3.经过简单尝试确定,现有机制的基础上使用`dma_declare_coherent_memory()和dma_contiguous_reserve()`就可以比较方便的实现fr设备独享CMA

```cpp
[2018-06-25 11:15:55.966] Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10     11
[2018-06-25 11:15:55.978] Node    0, zone   Normal, type    Unmovable      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:15:55.989] Node    0, zone   Normal, type  Reclaimable      0     10     13      6      0      1      1      0      1      0      1      0
[2018-06-25 11:15:56.000] Node    0, zone   Normal, type      Movable      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:15:56.011] Node    0, zone   Normal, type      Reserve      0      0      0      0      0      0      0      0      0      0      0      1
[2018-06-25 11:15:56.023] Node    0, zone   Normal, type          CMA      0      0      0      0      1      0      3      0      1      0      1      3
[2018-06-25 11:15:56.034] Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:15:56.045]
[2018-06-25 11:15:56.046] Number of blocks type     Unmovable  Reclaimable      Movable      Reserve          CMA      Isolate
[2018-06-25 11:15:56.054] Node 0, zone   Normal            0            1            2            1            4            0
[2018-06-25 11:15:56.063] ~~~~~~~~~~~~~~mes_len: 52~~~~~~~~~~~~~~~
[2018-06-25 11:15:56.080] @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@malloc failed: 3584
[2018-06-25 11:15:56.259] ~~~~~~~~~~~~~~mes_len: 52~~~~~~~~~~~~~~~
[2018-06-25 11:15:59.985] Page block order: 11
[2018-06-25 11:15:59.987] Pages per block:  2048
[2018-06-25 11:15:59.989]
[2018-06-25 11:15:59.989] Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10     11
[2018-06-25 11:16:00.000] Node    0, zone   Normal, type    Unmovable      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:16:00.012] Node    0, zone   Normal, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:16:00.023] Node    0, zone   Normal, type      Movable      0      1      0      0      0      0      0      0      0      0      0      0
[2018-06-25 11:16:00.034] Node    0, zone   Normal, type      Reserve      0      0      2      0      1      1      1      1      1      1      1      0
[2018-06-25 11:16:00.045] Node    0, zone   Normal, type          CMA      0      1      0      0      0      0      0      1      1      0      1      2
[2018-06-25 11:16:00.057] Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0      0
```

**06-21**<br>
设计mmc_test程序,大量分配内存,然后加载videobox的时候,可能因为没有足够的页缓存,有时候20+s才会加载成功程序,然后杀掉mmc_test程序释放内存.

__rmqueue_fallback 的借用顺序也应该调整: 应该在cma已经没有可以借用的时候,再去借用MIGRATE_RECLAIMABLE,现在的代码,是优先借用高order的,同order有限cma的,这样是有问题的.MIGRATE_RECLAIMABLE缺少会导致程序加载速度很慢.

moveable好像从开始就没分配,但显示2个,不知道怎么回事.

我们可以软件配置定义一个上限, 超过这个上限, 不能

记得,海思当时的方案,支持的通道配置变化的时候,需要先释放所有的通道,然后重新分配.
几个方案:
- 兼容之前的CMA方式,解决bug,这是尽量给客户提供更多可用内存的方式,可以考虑让可回收页面占用部分cma内存
- 使用一个cma,禁止客户fallback,使用coherent的bitmap机制管理cma;当前实际上使用的伙伴系统
- 两个cma,一个
实际执行:
- 增加接口,可以让设备申请自己的cma接口
-
**06-20**<br>
migratetype:2 4 current_order:0 a page: c033a000
migratetype:2 4 current_order:0 a page: c0332000
migratetype:2 4 current_order:0 a page: c032a000
migratetype:2 4 current_order:0 a page: c0322000
migratetype:2 4 current_order:0 a page: c031a000
migratetype:2 4 current_order:0 a page: c0312000
migratetype:2 4 current_order:0 a page: c030a000
migratetype:2 4 current_order:0 a page: c0302000
migratetype:2 4 current_order:0 a page: c02fa000
migratetype:2 4 current_order:0 9 page: c02fe000
migratetype:2 4 current_order:0 9 page: c0306000
migratetype:2 4 current_order:0 9 page: c030e000
migratetype:2 4 current_order:0 9 page: c0316000
migratetype:2 4 current_order:0 9 page: c031e000
migratetype:2 4 current_order:0 9 page: c0326000
migratetype:2 4 current_order:0 9 page: c032e000
migratetype:2 4 current_order:0 9 page: c032e000
migratetype:2 4 current_order:0 9 page: c0336000
migratetype:2 4 current_order:0 9 page: c033e000
migratetype:2 4 current_order:0 9 page: c02f6000
migratetype:2 4 current_order:0 8 page: c02f8000
migratetype:2 4 current_order:0 8 page: c0340000
migratetype:2 4 current_order:0 8 page: c0338000
migratetype:2 4 current_order:0 8 page: c0330000
migratetype:2 4 current_order:0 8 page: c0328000
migratetype:2 4 current_order:0 8 page: c0320000
migratetype:2 4 current_order:0 8 page: c0318000
migratetype:2 4 current_order:0 8 page: c0310000
migratetype:2 4 current_order:0 8 page: c0308000
migratetype:2 4 current_order:0 8 page: c0300000
migratetype:2 4 current_order:0 8 page: c02fc000
migratetype:2 4 current_order:0 8 page: c0304000
migratetype:2 4 current_order:0 8 page: c030c000
migratetype:2 4 current_order:0 8 page: c0314000
migratetype:2 4 current_order:0 8 page: c031c000
migratetype:2 4 current_order:0 8 page: c0324000
migratetype:2 4 current_order:0 8 page: c032c000
migratetype:2 4 current_order:0 8 page: c0334000
migratetype:2 4 current_order:0 8 page: c033c000
migratetype:2 4 current_order:0 8 page: c02f4000
migratetype:2 4 current_order:0 8 page: c0326000
migratetype:2 4 current_order:0 8 page: c031e000
migratetype:2 4 current_order:0 8 page: c0316000
migratetype:2 4 current_order:0 8 page: c030e000
migratetype:2 4 current_order:0 8 page: c0306000
migratetype:2 4 current_order:0 8 page: c02fe000
migratetype:2 4 current_order:0 8 page: c02fa000
migratetype:2 4 current_order:0 8 page: c0302000
migratetype:2 4 current_order:0 8 page: c030a000
migratetype:2 4 current_order:0 8 page: c0312000
migratetype:2 4 current_order:0 8 page: c031a000
migratetype:2 4 current_order:0 8 page: c0322000
migratetype:2 4 current_order:0 8 page: c032a000
migratetype:2 4 current_order:0 8 page: c0332000
migratetype:2 4 current_order:0 8 page: c033a000
migratetype:2 4 current_order:0 7 page: c033b000
migratetype:2 4 current_order:0 7 page: c0333000
migratetype:2 4 current_order:0 7 page: c032b000
migratetype:2 4 current_order:0 7 page: c0323000
migratetype:2 4 current_order:0 7 page: c031b000
migratetype:2 4 current_order:0 7 page: c0313000
migratetype:2 4 current_order:0 7 page: c030b000
migratetype:2 4 current_order:0 7 page: c0303000
migratetype:2 4 current_order:0 7 page: c02fb000
migratetype:2 4 current_order:0 7 page: c02ff000
migratetype:2 4 current_order:0 7 page: c0307000
migratetype:2 4 current_order:0 7 page: c030f000
migratetype:2 4 current_order:0 7 page: c0317000
migratetype:2 4 current_order:0 7 page: c031f000
migratetype:2 4 current_order:0 7 page: c0327000
migratetype:2 4 current_order:0 7 page: c02f5000
migratetype:2 4 current_order:0 7 page: c033d000
migratetype:2 4 current_order:0 7 page: c0335000
migratetype:2 4 current_order:0 7 page: c032d000
migratetype:2 4 current_order:0 7 page: c0325000
migratetype:2 4 current_order:0 7 page: c031d000
migratetype:2 4 current_order:0 7 page: c0315000
migratetype:2 4 current_order:0 7 page: c030d000
migratetype:2 4 current_order:0 7 page: c0305000
migratetype:2 4 current_order:0 7 page: c02fd000
migratetype:2 4 current_order:0 7 page: c0301000
migratetype:2 4 current_order:0 7 page: c0309000
migratetype:2 4 current_order:0 7 page: c0311000
migratetype:2 4 current_order:0 7 page: c0319000
migratetype:2 4 current_order:0 7 page: c0321000
migratetype:2 4 current_order:0 7 page: c0329000
migratetype:2 4 current_order:0 7 page: c0331000
migratetype:2 4 current_order:0 7 page: c0339000
migratetype:2 4 current_order:0 7 page: c0341000
migratetype:2 4 current_order:0 7 page: c02f9000
migratetype:2 4 current_order:0 7 page: c02f7000
migratetype:2 4 current_order:0 7 page: c033f000
migratetype:2 4 current_order:0 7 page: c0337000
migratetype:2 4 current_order:0 7 page: c032f000

Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, zone   Normal, type    Unmovable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Movable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Reserve      0      0      2      0      0      1      1      1      0      1      0
Node    0, zone   Normal, type          CMA   1783      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0

Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, zone   Normal, type    Unmovable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type  Reclaimable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Movable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Reserve      2      1      1      0      1      1      0      1      0      1      0
Node    0, zone   Normal, type          CMA      1      1      0      0      0      0      0      1      1      1      1
Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0

cat /proc/pagetypeinfo

**06-19**<br>
**06-18**<br>
**06-15**<br>
内存管理学习

qiwo_lanch_dropcaches()
{
	while [ -f "/tmp/drop" ]; do
		echo 3 > /proc/sys/vm/drop_caches
		usleep 1000
	done
	echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~dropceches stopped!"
}
qiwo_lanch_ceva_dsp()
{
	modprobe ceva-dsp
	touch /tmp/ceva
}
qiwo_lanch_videobox_cur()
{
	videoboxd > /dev/null 2>&1
	touch /tmp/video
}
qiwo_lanch_wifi_cur()
{
	qiwo_load_wifi_driver
	touch /tmp/wifi
}
case "$1" in
  start)
	echo "[ $VERSION ] start qiwo custum script.";

	mount -t vfat /dev/spiblock2 /config
	modprobe Felix clkRate=80000000

	eventhub &

	touch /tmp/keep_power

	echo "start eventhub ."
	#qiwo_lanch_once_wifi
	touch /tmp/drop
	touch /tmp/wifi
	qiwo_lanch_dropcaches &
	while true; do
		#echo "start ceva_dsp ."
		qiwo_lanch_ceva_dsp &
		qiwo_lanch_videobox_cur &

		while [ ! -f "/tmp/ceva" ]; do
			usleep 1000
		done
		while [ ! -f "/tmp/video" ]; do
			usleep 1000
		done

		while [ ! -f "/tmp/wifi" ]; do
			usleep 1000
		done
		modprobe -r ceva-dsp
		#modprobe -r bcmdhd
		kill -9 $(pidof videoboxd)
		rm /tmp/ceva
		rm /tmp/video
		#rm /tmp/wifi

		#dmesg > /tmp/dmesg_info
		usleep 100000
	done

**06-14**<br>
extern int 	dmaconti_debug;
//#define dmacontigdebug(fmt, args...) ({				\
	if (unlikely(dmaconti_debug))			\
		printk(KERN_DEBUG	"dma_contig::%s " fmt, __func__, ## args);		\
})

dmacontigdebug("real alloc switch : %d", real_switch, (int)test1, (int)test2);

dmamapdebug("real alloc switch : %d", real_switch, (int)test1, (int)test2);


内存管理学习
**06-13**<br>
MIGRATE_UNMOVABLE,	MIGRATE_RECLAIMABLE,	MIGRATE_MOVABLE, MIGRATE_CMA,
从只读文件系统加载的程序,申请的内存应该是MIGRATE_MOVABLE,这样应该更好.
内存管理,需要考虑MIGRATE_RECLAIMABLE到MIGRATE_CMA的迁移可能.
**06-12**<br>
内存管理学习
**06-11**<br>
内存管理学习
**06-10加班**<br>
内存管理学习
**06-08**<br>
cma内存的申请和释放，以方便的方式dump出来，包含开始地址，大小等信息，按照顺序打印，列出hole等．

**06-07**<br>
阅读内存管理代码和资料
printk(KERN_EMERG "func:%s, %d~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n", __func__, __LINE__);

printk(KERN_EMERG "func:%s, %d~~~~~~~~~~~~~~~~~\n", __func__, __LINE__);
printk(KERN_EMERG "~~~~~~~~~func:%s, %d, (%x %x)\n", __func__, __LINE__
          , (int)test1, (int)test2);
printk(KERN_EMERG "~~~~~~~~~func:%s, %d, (phys:%x addr:%x pgd:%x)\n", __func__, __LINE__
					, (int)phys, (int)addr, (int)pgd);
memblock_dbg("memblock_reserve: [%#016llx-%#016llx] %pF\n",
		     (unsigned long long)base,
		     (unsigned long long)base + size,
		     (void *)_RET_IP_);

**06-06**<br>
阅读内存管理代码和资料

CMA问题，建立测试脚本，mmc_test程序，以多种不同的大小和方式申请内存，测试多种场景下CMA以及整个内存系统的状态变化，分析解决问题．
之后门铃项目中反映50Mhz工作不稳定，uboot容易出现启动失败，这应该是spimul两个时钟非同源导致．
增加记录，每个进程占用的内存．

整体修正：
http://gerrit.in.infotm.com/#/c/15770/

**06-05**<br>
RM #6625 -- BU2: 读写jffs2分区导致下次启动无法挂载文件系统
RM #6272 -- QSDK: [Allchip][BSP] 内核环境中SPI总线时钟无法工作在50MHz
问题分析解决：
之前完全无法工作在50MH，是因为clk.c中配置ssp-clk时，ENABLE 了 NCO　模式，时钟波形质量差．

代码上传：comment #4中已经包含

make app-d318-upgrade-rebuild;make

fix(spimul,spiblock): resolve a squashfs access error problem
this problem get caused by two issues: 1. ssp_clk and spibus_clk of spimul is generated from different PLL, this may cause bus error at high speed transmission; 2.spi_block read cache buffer have a bug which casue memory access out of bound
Close 6722

尝试16kblock size，和下层保持一致； 更新squashfs版本到4.2
印象中，mmc驱动每次数据最大128k；spi接口现在定义16k --> mmc->max_blk_size = 65536;mmc->max_seg_size = 0x1000;之类的设定

**06-04**<br>
[2018-06-05 13:33:05.460] blk:dc8 cnt:24 (105053, 125148) // 8成的数据读取是32个block．
      blk_cnt = ((offset_addr[segments+1] - offset_addr[0]) >> tr->blkshift);
			blk_addr = (block + (offset_addr[0] >> tr->blkshift));
			//ktime_get_ts(&ts_write_start);
			if (tr->read_multisect(dev, blk_addr, blk_cnt, spi_blk->cache_read_buf)) {
				ret = -EIO;
				break;
			}
			//ktime_get_ts(&ts_write_end);
			//printk("infotm %x spi %d %d read %d %d \n", buf, blk_addr, blk_cnt, (ts_write_end.tv_sec - ts_write_start.tv_sec), (ts_write_end.tv_nsec - ts_write_start.tv_nsec));
			for(i=0; i<(segments+1); i++) {
				buf = (char *)buf_addr[i];
				blk_cnt = ((offset_addr[i+1] - offset_addr[i]) >> tr->blkshift);
				memcpy(buf, spi_blk->cache_read_buf+offset_addr[i], blk_cnt<<tr->blkshift);
			}
spiblock_fs_read_multisect() 函数修改，直接读取到本地的buffer中就好，或者，spi部分实现sg dma机制．

可以考虑，跟踪一个完整的squshfs文件加载过程．

需要确定，调整时钟同源之后，boot和kernel阶段192m应该分频到32M？然后就是对pll022的影响？
cd config;touch test;touch drop;sync

uboot中spi读取数据块64k切换到4k，影响8%的效率(115ms--123ms).
int32_t ssp_manager_set_flash_type(uint32_t flash_type)
  spi_manager_g.flash_sector_size = 64*1024;

pl022最大一次读取4k，这才是最大的区别．
是否应该打印所有的flash访问请求呢？或者，最近的若干个．

----
## 05-02->06-01
**06-03加班**<br>
每次dma传输前后，都增加一定的延时，看是否能够解决问题!!!!!
降低分频之前的输入时钟，也许会有影响，之前出现300M输入需要改成150才能使用的情况．而且之前都是使用60M的时钟．
不知道太低会否不好，那么就再试试看4倍频吧．
之前的测试，重新使用低频率试试看．
测试发现，使用单个总线时钟就可以驱动spi接口了．

**06-02加班**<br>

脚本中增加限制，保证videobox在ceva_dsp加载成功之后启动，不清楚两者之间是否存在有某种互斥关系．

禁止mmc0

qiwo_lanch_dropcaches()
{
	while [ -f "/config/test" ]; do
		echo 3 > /proc/sys/vm/drop_caches
		usleep 10000
	done
	echo "dropceches stopped!"
}

请不要忽略：　Bus error

**06-01**<br>
请假，上午去中山医院，下午国际象棋
**05-31**<br>

根据这几天的测试，如下操作可以保证不会出现当前问题：
1. Felix，videoboxd，qiwo_load_wifi_driver保持前台运行
2. 取消drop_caches操作
估计这个问题和内存占用有关，进一步分析需要更多时间．
感觉drop_caches操作应该是清理了cache，导致立刻需要读取填充大量数据，导致问题；总线频率太高，是否同样的情况？不断在各个进程之间颠簸．
单线spi没有这个问题，

下一步：　禁止drop_caches再次尝试
echo 4 > /proc/sys/vm/dirty_background_ratio
echo 8 > /proc/sys/vm/dirty_ratio
printk(KERN_EMERG "fragment_cache: (%d, %d)\n", SQUASHFS_CACHED_FRAGMENTS, msblk->block_size);
禁止squashfs的cache如何？
```cpp
//基本的清理过程，但实际上没有任何意义
free -m
sync
cat /proc/sys/vm/drop_caches
echo 3 > /proc/sys/vm/drop_caches
cat /proc/sys/vm/drop_caches
```
整理清楚：uboot0启动时part和其他传入kernel的参数的管理

感觉有可能是squashfs中存在的一个bug,cache相关的，cache已经被回收，但内核继续索引使用．
最新修改的脚本去掉sleep;
恢复其他所有的脚本，只去掉echo 3 > /proc/sys/vm/drop_caches看看结果如何．

**05-30**<br>
下一步，d318等程序，移动到videobox之后启动，而且应该保证videobox启动完毕．

内核加载程序时增加打印信息，记录时间:
static int do_execve_common(const char *filename,
  if((strcmp(filename, "/usr/bin/audiobox") == 0) || (strcmp(filename, "/usr/bin/videoboxd") == 0)
		|| (strcmp(filename, "/usr/bin/d318") == 0)
		|| (strcmp(filename, "/usr/bin/systemmsg") == 0)
		|| (strcmp(filename, "/usr/bin/d318") == 0))
		printk(KERN_EMERG "~~~~~start exec: %s at [%d]\n", filename, jiffies);

可以考虑同时启动包括videobox在内的多个程序，也许出现几率更高．
  就算是不重现，比较并行启动和串行启动的时间长度．

videoboxd延时
[2018-05-30 09:59:01.204] Ispostv2: ispost_open
[2018-05-30 09:59:01.207] SQUASHFS error: lzo decompression failed, data probably corrupt
时间非常接近，所以，有可能会造成影响．

ispost_open 开始和结束的时候，增加打印
调整代码，改变时钟的时候刚好在读取文件．或者，测试程序后台运行，读取几个典型的大文件．
videoboxd加载之前的900ms延时，真是有毛病．

弄清楚，
1. item文件的part部分是如何解析的
2. ftl的模块化机制
3. mtd功能

几种烧录方式流程：
1. upgrade流程
2. d318-upgrade，客户自定义流程
3. uboot1烧录

**05-29**<br>
make app-d318-upgrade-rebuild;make
mkdir /mnt/sd4
mount -t squashfs /dev/spiblock1 /mnt/sd4
mkdir /mnt/sd3
mount -t vfat /dev/mmcblk0p1 /mnt/sd3
cp -fr / /mnt/sd3
cp -fr -L /usr /mnt/sd3

**05-28**<br>
Unable to read page, block 4f5556, size 1515a
SQUASHFS error: ~~~2 lzo decompression failed: -5, out_len:0x15eb7

读取：
//１．位宽改为每次读取16bits
２．6 dummy cycles 需要确认一下，什么意思
３．试试看降低时钟，看起来好像很难出现，很奇怪，好像复现过，但现在无法重现．
４．尝试去掉 SPI_NOR_QUAD_WRITE SPI_TX_QUAD 这两项
５．sd卡启动，反复读取flash，确认每次读取内容相同．
６．尝试，单线，35Mhz，是否会出现错误．
７．后台运行的程序，尝试全部提到前台来．
８．禁止mmc0初始化，根本没用到，看是否有影响．
９．内存不够，有可能吧，alloc_contig_range test_pages_isolated(41500, 417f8) failed
１０．squashfs上层再次读取并解压
１１．spi驱动层确定读取错误原因
１２．使用高倍率分频(8)，并尝试 imapx_spi_probe()函数中禁止：
    `clk_set_rate(host->extclk, host->master_info->extclk_rate);`
１３．应该考虑调整busclk
１４．尝试polling方式4线测试
１５．尝试kernel中启动wifi和ddk驱动等，或者，kernel启动时初始化相关时钟．
１６．尝试，降低cpu整体时钟．

repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b dev_qsdk
repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b qipc_qiwo_doorbell_dev
repo sync -c
repo start develop --all


**也许倍频因子也有影响，至少应该是４，２会出问题？**
如果是这样，提高原始clk，设置：
  `DEV_CLK_INFO(SSP_CLK_SRC, 0, EPLL, 0, 4, DISABLE),`
  `.extclk_rate = 120000000 /*50MHZ*/`

或者，在底层增加判断，每批数据读取两次，然后进行比较，不同的话，打印错误，以确认问题．　
Dear david,
分支：   qipc_qiwo_doorbell_dev
下载完后做修改两处代码
1.按照如下diff，后修改一个文件
mqd@mqd-OptiPlex-3020:~/2018/qiwo/qipc_qiwo_doorbell_dev_squashfserror/system$ git diff
diff --git a/d318/S22qiwo_ff b/d318/S22qiwo_ff
index 862cf68a..a0c0e2aa 100755
--- a/d318/S22qiwo_ff
+++ b/d318/S22qiwo_ff
@@ -787,8 +787,8 @@ case "$1" in

        echo "[ $VERSION ] qiwo custum script end..."
        sleep 15;
-       cd /ff && ./autotest &;
-    ./autotest_videobox &
    cd /ff && ./autotest &

2.将system/d318/ff/下的autotest用该目录下的autotest-squashfserror替换
编译：　./tools/setproduct.sh   1   doorbell  0   PS5230DVP_NEW.json  0   ps5230dvp
    使能4k block
    make app-d318-upgrade-rebuild;make
    make d318-rebuild;make;./tools/mkburn.sh /dev/sdb
    cat /proc/pagetypeinfo

  	eventhub &
	modprobe ceva-dsp &
	modprobe Felix clkRate=80000000 &

	echo "start eventhub ."

	qiwo_load_wifi_driver  > /dev/null ;
	qiwo_initdir  > /dev/null ;
	qiwo_check_if_to_set_network1  > /dev/null ;
	qiwo_lanch_videobox &
	echo "[ $VERSION ] lanch doorbell ";
	d318 &
	nice -n -20 systemmsg  > /dev/null &
	echo "[ $VERSION ] let doorbell start in backgroud. ";
	qiwo_lanch_audiobox > /dev/null  &
	qiwo_initial_wifi_info > /dev/null  &
	qiwo_nptd_initial > /dev/null &
	echo "[ $VERSION ] qiwo custum script end..."
	touch /tmp/keep_power
	echo "reboot 15s later..."
	sleep 15;
	cat /proc/fr_info
	frinfo_ok=`cat /proc/fr_info | grep -c 'Total: 23.65M'`;echo $frinfo_ok
	process_ok=`ps | grep -c -e 'videoboxd$' -e 'audiobox$' -e 'd318$'`;echo $process_ok
	echo ""
	echo "Show frinfo_ok : [ $frinfo_ok ] ... process_ok : [ $process_ok ]";
	echo ""
	if [ "$frinfo_ok" == "1" ]; then
		if [ "$process_ok" == "3" ]; then
			echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~initiate videobox ok~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
			reboot
		fi
	fi

**05-27**<br>
测试：　
1. 8字节对齐，原代码，问题重现
2. 64字节对齐，问题仍然重现
3. 恢复单线spi接口－－周一检查,没有重现，所以这是4ｌｉｎｅ相关的问题．
4. 尝试polling方式4线测试

**05-25**<br>
17:04开始测试
手机上resetting wifi重新绑定，按门铃按键启动程序，绑定的时候需要保证删除/confit/test文件．绑定完毕，重启，touch /config/test触发测试流程  d318.c qiwo_write_uart 2741  send usart data: aa 15 2 b5 b9 55　//2表示开启测试过程

spi驱动，如果使用全双工协议，那么最好在pl022中完成；怀疑spi-core的机制是否还合适，因为需要经常填充和发送空的消息，这个消息不应该来自于上层，而且为了保证效率，最好避开core的thread上下文，直接在pl022中维持发送和接收链表；
pump_transfers()函数中，调用 spi_get_next_queued_message()函数判断master队列为空，就直接封装简单消息接口；这需要增加 set_up_next_null_transfer()函数；

全双工方式下，发送空消息，或者上层tx_buf中信息；接收到的数据需要判断是否有效，无效就直接丢弃，有效，放到队列中．

上层接口：模仿net,发送和接收定义buffer. 阻塞读取，阻塞发送，

spi驱动层，只需要增加标志位，表明是否填充即可，最多加上有效长度．

spi_get_next_queued_message()函数可以直接取下一消息．

评价包含：
1. 整体评价，如能力，特点，长处等等
2. 突出业绩（如印象最深的，最有价值的等等，不要超过3个）


**05-24**<br>
内存管理基本机制学习;下午4:30－6:00 spi驱动会议；
**05-23**<br>
内存管理基本机制学习
**05-22**<br>
no_scatterlist_test 分支，调试并解决pl330 scatterlist 传输问题
另外一个不对头的地方，tasklet中调用callback,callback中包含有delay,这是不大合适的，考虑工作队列替代．
struct pl330_info *pi = &pch->dmac->pif;
dev_err(pi->dev, "~~~~~~~~ %s:%d!\n", __func__, __LINE__);

**05-21**<br>

fix(spimul): resolve a jffs2 mounting problem from anni project
this was caused by 4-line spi bus working with too small rx burst length, so adjust minimum dma rx burst length to 16 bytes for 4-line spi bus, to speed up dma transfer
Close 6625

mkfs.vfat /dev/spiblock2
umount /dev/spiblock2
mkdir /mnt/sd3
mount -t vfat /dev/spiblock2 /mnt/sd3

cp /bin/busybox /mnt/sd3
cp /mnt/sd3/busybox /mnt/sd0/b2

int len = 0;
if(len > 4096)
 		 pr_err("[spimul] 1~~~~~~~~~~~~~~~~~~~~~rx err:%d %d\n", __LINE__, len);

----
**05-20加班**<br>
linux驱动，宋宝华版本，前面几章基本过滤
**05-19加班**<br>
pl330文档，spi调整机制的分析．
**05-18**<br>
深入了解pl330机制以及分析测试之后，估计问题可能是因为每次dma搬运的burst数据太少(4bytes)，如果spi接收数据的速率超过dma通道搬运能力，就会出错；尝试降低spi频率到5M，如预期不会出现问题；尝试提升spi频率到60M,同时加大burst长度到64,如预期也不会出现问题．
**05-17**<br>
阅读pl330代码
**05-16**<br>
16字节对齐可以解决问题，继续分析根本原因．开始阅读pl330代码
**05-15**<br>
新硬件上重现问题，尝试比较出错jffs2分区和正常分区在写入相同内容时差别，无法找到分析依据；发现出错时最后数据长度3800，尝试512字节对齐，问题解决
**05-14**<br>
anni分支调试，总是出现jffs2的访问错误，但最后发现是硬件问题，烧录kernel和system失败．kernel启动提示，版本时间是05/11的．

**05-12加班**<br>
p2p基于udp，所以，点到点的数据传输可能会丢失，
    同样，udp包记得是必须按照packet接收，不像tcp收发可以直接放在buffer中，所以，p2p自己额外定义了buffer，必须要尽快接收．
    设备到pc，pc接收非常简单，没有发现丢失数据；pc到设备，数据丢失非常明显，尤其是批量传送的时候
p2p内存耗尽问题：
    １．p2p需要限制接收buffer的大小，否则传输的burst会导致内存耗尽
    ２．及时通知，尽快消耗数据，查询方式可能太慢
创建独立的spi线程，直接从rx缓冲区中获取数据发送．
buffer大小的定义，按照packet的大小比较合适，这样可以增加响应速度．
有一个问题，如果短时间内接收到比较多的packet，xr871来不及通过spi发送到c20，p2p会malloc过多的内存，导致内存耗尽而crash．这个问题我这边无法避免．
|--> 和涂鸦讨论确定，涂鸦将移植MQTT协议相关部分到xr871，音视频封装处理部分到c20，预计5月末完成；配合涂鸦的sdk更改，我们这边需要修改spi和p2p软件，以支持多个session以及每个session支持多个channel的设计．
周五已经实现基本的spi消息机制，在c20和pc之间实现了简单的双向通信demo：c20传递一个文件到pc，同时pc传递一个文件到c20，文件验证没有出现错误．
下一步，等待涂鸦完成sdk移植之后的集成．

**05-11**<br>
anni分支相关登录:
repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b qipc_anni_dev
repo sync -c
git tag //显示所有版本tag
git checkout qsdk_ipc_v3.6.1
repo start develop --all

root anni2013

二. 代码编译:
./tools/setproduct.sh
//# please choose a product from list below:
0   q3520e_nopmu    1   q3520e_nopmu_isp_debug  2   qipc_38f_nopmu
//# your choice: 0
//# configuration written to /home/soyo/soyo_work/ipc/qipc_anni_dev/.config
//# product successfully set to q3520e_nopmu
//# please choose sensor0 configuration:
0   sc2235dvp     x   none
//# your choice: 0
//# please choose product json configration:
0   1080P.json  1   1080P_IQ.json 2   rc.json 3   720P.json 4   960P.json x   default
//# your choice: 0
//# choose configuration successfully to q3520e_nopmu
三. 代码烧录:
1. 编译完将output/images下所有文件拷贝到tf卡
   //cp -rf output/images /media/yuan/Ubuntu\ 16.04\ LTS\ amd64/
   cp output/images/* /media/yuan/Ubuntu\ 16.04\ LTS\ amd64/
   cp output/images/uImage /media/yuan/Ubuntu\ 16.04\ LTS\ amd64/
   sync
   sudo eject /dev/sdb
   cd /media/yuan/Ubuntu\e520_1line 16.04\ LTS\ amd64/
2. 烧录在uboot1阶段敲空格停在命令交互界面，插入TF卡，使用以下命令更新需要更新的镜像文件
vs assign mmc1;vs assign flash;vs erase 10000 10000
//uboot0.isi+items.itm
vs assign mmc1;fatload mmc 1:1 80008000 uboot0.isi;fatload mmc 1:1 80014000 items.itm;vs assign flash;vs erase 0 10000;vs write 80008000 0 10000
//uboot1.isi
fatload mmc 1:1 80008000 uboot1.isi;vs erase 20000 40000;vs write 80008000 20000 40000
//kernel
fatload mmc 1:1 80008000 uImage;vs erase 60000 200000;vs write 80008000 60000 200000
//system
fatload mmc 1:1 80008000 rootfs.squashfs;vs erase 260000 D20000;vs write 80008000 260000 D20000
//app data
vs assign flash;vs erase F80000 80000

vs assign mmc1;vs assign flash;fatload mmc 1:1 80008000 uImage;vs erase 60000 200000;vs write 80008000 60000 200000


26+d2 = F80000

ifconfig eth0 down
ifconfig eth0 192.168.21.108 netmask 255.255.255.0 broadcast 192.168.21.255
ifconfig eth0 up

inet addr:128.168.91.233  Bcast:128.168.91.255  Mask:255.255.255.0

ifconfig eno1 128.168.91.235 netmask 128.168.91.255 broadcast 255.255.255.0


ping 128.168.91.233

**05-10**<br>
下一步调整：　p2p client，发送命令配置xr871的测试参数；c20测试参数从命令行输入
数据传输方式：
１．c20轮询，查询有没有接收到数据，或者能否发送新的数据，有的话就启动过程．暂时按照单向传输实现．
２．xr871检查p2p buffer,和c20交互状态信息，执行c20数据请求

基于spi增加测试命令：数据开始，结束，下一个文件，等等．

测试项目，需要统计传输速率等信息(还需要测试，dma最小块对齐是否256.)：
1. 单元测试：相同大小数据块传输，传送/接收/全双工，参数：数据块大小，数据块个数
2. 单元测试：cmd+data数据块传输，传送/接收/全双工，参数：数据块大小，数据块个数，命令长度
3. 真实数据传输，文件或者指定数据块．

应用场景：
1. c20发送结束，发送命令到xr871，xr871xr871发送cmd到client
2. client发送结束，发送命令到xr871，xr871xr871发送cmd到c20
3. client启动，发送命令启动xr871和c20
4. client同时发送和接收数据，启动发送完毕命令，接收接收完成命令．

c20实现：
1. 读取：循环check然后读取
2.

**05-09**<br>
c20到client传输没哟发现文件，反方向总是出错．跟踪，最后发现消息头部定义不能小于128bytes，可能和xr871的dma配置有关．如果项目立项，那么后续继续跟踪．当前，先使用128的消息头长度．
**05-08**<br>
发送和接收在涂鸦应用中分开实现：
　　如果上层使用轮询方式接收，那么发送和接收，可以分开实现
　　如果采用线程+消息队列的方式，那么最好发送和接收一起，可以提高效率。
　　针对当前的应用，分开实现可行而且比较简单。
完全采用c20主控，这样无论发送还是接收，都需要xr871满足了指定的长度要求，才能传输，这样暂时可以简化代码的设计

printf("reach: <%s,%d>\n", __func__,__LINE__);

c20处理流程：
　　０．启动一个线程
　　１．查询对方收发状态
　　２．如果可以发送就从本地文件中读取内容发送
　　３．有数据就绪就读取并写入目标测试文件
xr871处理流程：
　　０．启动一个线程
　　１．接收一条命令，查询，接收，发送的操作．
　　２．如果可以发送就从本地文件中读取内容发送
　　３．有数据就绪就读取并写入目标测试文件
然后，尝试双工读写数据，明显简化
　　０．启动一个线程
　　１．全双工访问．

**05-07**<br>
上午移植涂鸦sdk，和涂鸦　力波讨论确定api接口含义
初始化：
    tuya_ipc_tranfser_init(&p2p_var);
    start_live();
启动session:
    tuya_ipc_session_start(23, TRANS_MODE_P2P);
发送视频：
    １．初始化视频通道：　ret = tuya_ipc_ring_init(VIDEO_MAIN_CHN, 512*1024);
    ２．循环发送视频帧：tuya_ipc_ring_append_data(VIDEO_MAIN_CHN, videoBuf, len, media_type, pts);
发送音频：
    １．初始化音频通道：　ret = tuya_ipc_ring_init(VIDEO_MAIN_CHN, 512*1024);
    ２．循环发送音频帧：tuya_ipc_ring_append_data(AUDIO_CHN, audioBuf, len, AUDIO_FRAME, pts);
下午和晚上基本都在会议

**05-06加班**<br>
amba bus相关代码解析； 远程桌面剪贴板功能，处理失败，所以转向确认验证了几个通用共享方式：samba/cifs/nfs/ftp

**05-05加班**<br>
今天考虑增加spi全双工传输的支持.
1. 测试，每次大的数据传输之前先额外增加４个字节的收发，看会否影响到正常的处理．
spi传输函数全双工时候，使用动态内存来分配发送buffer，出现错误，spi卡死在dma，可能是需要一定程度的对齐．
如果全部的数据都进行校验，开销太大；如果不校验，那么不安全．所以推荐采用部分校验的方式．命令需要校验，数据帧中的命令ack部分，也应该校验．
每个传输过程可以通过两种方式触发：１．两个方向的申请中断；２．轮询方式，中间可以增加msleep.　后面这种方式虽然效率稍低，但本身视频传送是非对称的，c20发送的数据不会引入延时，而且手机端过来的数据应该对延时有一定的容忍度．

应该在驱动层完成传输过程的操作．
除了数据，前面过程就算是有错，也要执行完毕几个步骤
cmd加上两次ack的方式：
１．cmd，交互信息
２．可控制数据传输 : 中断方式或者延时方式处理错误
  如果任何一方对协商结果有异议，那么就否决数据传输．这一步不方便通过传输的内容来判断，因为内容可能出错．尤其是长度信息出错将会导致失控
    c20不启动传输，或者xr871不触发ready中断．通过超时来实现．也就是说，每次出错付出的代价是一定延时．
    传送请求，启动一次全新的传输；重传请求，不发送data，直接再次重新传输cmd.
  xr871检查到错误:
    c20增加一个请求资源的接口，阻塞等待dma ready中断，重传请求中断也可以终止它，哪个中断先到就处理哪一个．xr871检查到错误就发送重传请求，否则就发送dma ready中断．
  c20检查到错误
    不启动数据传输，产生重传请求中断，xr871接收到中断之后，终止数据dma的配置．

如果协商没有数据需要发送，那么数据部分就作为ack用．增加seqnum的控制，出错重传．xr871在一次传输中，没有数据要发，那么下次轮询的时间间隔可以定义的稍长．

xr871一次基本读写流程：
１．读取当前tcp的读写buffer大小
２．如果有读的，设置好当前send_len
３．读取recv_buffer，如果网络缓冲就绪就发送；如果当前recv_buffer中空，设置recv_enable=1
４．spi读写8同步字节
５．填充send_buffer内容，协调两端数据长度，开始spi传输过程

如果同步字节完毕之后，刚好有新的frame过来，那么延后处理这个frame.

**05-04**<br>
又要开始涂鸦sdk移植，有点头疼．

全志xr871，app软件是基于freertos和lwip的，完整资料可在https://github.com/XradioTech/XR871下载
chip vendor: 全志
chip type: ARM Cortex-M4F
chip Model: xr871
Endian: Little
ToolChain Version:4_9-2015q2
ToolChain Info:　gcc-arm-none-eabi-4_9-2015q2
编译开发环境搭建参照　XR871/03_SDK/XR871_Quick_Start_Guide-CN.pdf 文档

开发可以使用project/wlan_demo工程作为基础。

接入无线路由器，比如接入"TP-LINK_5E87E6"，可以在命令行输入：
net mode sta
net sta config TP-LINK_5E87E6 12345678
net sta enable



范例command TP-LINK_5E87E6　为路由器ssid，密码12345678



chip vendor: Infotm
chip type: ARM Cortex-A5
chip Model: C20
Endian: Little
ToolChain Version:4.7.3
ToolChain Info:　arm-buildroot-linux-uclibcgnueabihf

工具链下载：
Windows:https://launchpad.net/gcc-arm-embedded/4.9/4.9-2015-q2-update/+download/gcc-arm-none-eabi-4_9-2015q2-20150609-win32.exe
Linux:https://launchpad.net/gcc-arm-embedded/4.9/4.9-2015-q2-update/+download/gcc-arm-none-eabi-4_9-2015q2-20150609-linux.tar.bz2

开发过程中，修改default config，可以提高distclean之后的工程配置工作效率
meld products/q3fevb_va_ipc/configs/qsdk_defconfig .config
meld products/q3fevb_va_ipc/configs/linux_defconfig output/build/linux-local/.config

**05-03**<br>
重新整理spi和p2p的测试代码，调试中出现一些弱智问题，浪费了３个小时时间．
可以从c20发送文件到pc，或者c20无限发送数据，这两种模式方便之后的调试．
xr871启动支持下面几种模式：
１．进入命令行之后不执行任何测试
２．链接自己缺省路由测试
３．链接pc server，通过网络获取指定测试路由，然后开始测试
４．rw程序最好可以完成更加复杂一点的测试内容，可以rw程序指定传输的数据长度或者时间

设定两种发送模式：<br>
- 指定文件发送，发送完毕为止，可以设置文件参数, 不指定文件的话就是无限发送
　mmc_test send -f /mnt/sd0/pcm_16khz_ch2_32b.wav -b 16
- 无限发送
　mmc_test send -b 16



## 2019 04-14->...
**04-25**<br>
增加如下的诊断内容:
  dev->dev_fr_counter++;
  prtd->xrun_step

**04-24**<br>
static unsigned long long get_timestamp(void) {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
    return  ts.tv_sec * 1000ull + ts.tv_nsec / 1000000;
}

APP_LOG_CRIT("get 2: %d\n", (int)get_timestamp());

**04-23**<br>

abctrl play -w 32 -s 16000 -n 2 -d /mnt/sd0/pcm_16khz_ch2_32b.wav -y 22 -z 34 &
abctrl record -w 16 -s 16000 -n 2 -t 8 -o /mnt/sd0/record_1.wav &
abctrl record --enable-aec -w 16 -s 16000 -n 2 -t 8 -o /mnt/sd0/record_2.wav &

**04-22**<br>
如果在设备将要结束的时候, audio_set_format,会否出现异常呢? 应该增加保护.
codec_open 增加pid打印

**04-17**<br>
audiobox crash 的问题， 如何跟踪:
  1. 如果出现， 可以在相关的函数中增加延时和打印，以帮助定位。发送参考代码给客户。
  2. gdb, 具体到process_end的bug，应用进程sleep启动， audiobox中杀死应用进程。
  3. 把trace通过管道或者消息队列,重定向到另外一个进程,这样可以保证trace的完整性.
应用程序打印中增加内核时间，可以和内核代码同步
```cpp
int devctrl_check_release_dev(audio_dev_t dev)
{
	int next_check = 5000;//check 5ms later

	pthread_mutex_lock(&dev->dev_mutex);
	if (dev->trying_hal_release != 1) {
		pthread_mutex_unlock(&dev->dev_mutex);
		return next_check;
	}
	if (list_empty(&dev->head)) {
		int result = 0, cmd = AB_RELEASE_DEVICE;
		snd_pcm_sframes_t delay;
		char rpcname[64];
		snd_pcm_delay(dev->handle, &delay);
		result = delay*1000/dev->attr.samplingrate;
		APP_LOG_INFO("Frame left:%d, %dms\n", delay, result);
		if (delay > (dev->attr.samplingrate>>9)) {
			if (result > 40) {
				next_check = 40000;
			} else if (result > 20) {
				next_check = 20000;
			} else if (result > 10) {
				next_check = 10000;
			}
			pthread_mutex_unlock(&dev->dev_mutex);
			return next_check;
		}
		sprintf(rpcname, "%s-%s", AUDIOBOX_RPC_BASE, dev->devname);
		AB_EVENT(sc, &cmd, dev->devname, NULL, &result);
		audiobox_event_scatter(rpcname, sc, AB_EVENT_SIZE(sc));
	}
	pthread_mutex_unlock(&dev->dev_mutex);

	return next_check;
}
```

客户说,aecv2没有ctrl+c时候的crash问题：
**04-16**<br>
```cpp
//音频放大
		short *ptr = dev_buf.virt_addr;
		int i, multi = 5;
		for (i=0;i<(dev_buf.size/2);) {
			ptr[i+2] = multi*ptr[i+2];
			ptr[i+3] = multi*ptr[i+3];
			i += 4;
		}
```
**04-15**<br>
获取完整的内部数据结构信息，然后打印出来:   audio_dev_t     audio_chn_t     apu_codec_t
是否可以查询fr的情况呢？
还有一些全局变量的打印
  static uint8_t audiobox_id[AB_ID] = {0, 0, 0, 0};
  static int enhance_mode = 0;
  static int default_aec_algorithm = -1;
  static int capture_devfr_duration = 300;//in ms

**04-14**<br>
是否应该增加api接口，可以临时的提升或者降低audio播放时钟呢？
## 03-04->...
**03-23**<br>
增加通道和api的单独控制功能, abctrl直接命令行指定通道和命令以及参数, 或者, abctrl提供控制台解析测试. 主要目标是对运行中的通道和设备进行解析, 打印配置和统计信息, 控制测试等.

增加一条消息, 开启dma的trace信息。应该可以实现比较复杂和全面的dma trace。

**03-22**<br>
记录一下spinlock锁死问题相关信息,重现等:
```cpp
echo 6 > /proc/sys/vm/dirty_ratio
echo 3 > /proc/sys/vm/dirty_background_ratio

mount -t vfat /dev/mmcblk0p1 /mnt
videoboxd   /mnt/player_320_g1.json
cd /mnt
./vplayer /mnt/320_264_15fps_1track.mkv

new
play 1

mount -t vfat /dev/mmcblk0p1 /mnt
abctrl unitest setlog -m audiobox -l 0
abctrl play -w 32 -s 16000 -n 2 -d /mnt/pcm_16khz_ch2_32b.wav -y 22 -z 28 &
abctrl record --enable-aec -w 32 -s 16000 -n 2 -t 5 -o /mnt/voice_0.wav &
```

**03-21**<br>
调试底层音频, 可使用校验和或者非0字符个数来判断播放的音频是什么玩意.
```cpp
	int i;
	long long zero_flag = 0;
	char* myptr = (char*)p_dbginfo->audio_devinfo;
	for (i=0;i<sizeof(p_dbginfo->audio_devinfo);i++) {
		zero_flag += myptr[+i];
	}
	APP_LOG_CRIT("audiobox zero_flag : %d\n", zero_flag);

int i;
long long zero_flag = 0;
for (i=0;i<prtd->dma_period;i++) {
	zero_flag += prtd->hw_dma_area[prtd->dma_pos+i];
}
printk(KERN_EMERG "zero_flag: %lld 0x%x\n", zero_flag, counter_1*prtd->dma_period/8);
```
**03-20**<br>
增加一个
void audiobox_set_event(audio_dev_t dev, int* variable, int event)
dev->hal_state 的改变,一定要在临界区中进行, 只能在主线程和service线程中进行.
dev清空了当前的所有数据之后,恢复正常工作.所以,flush应该是一次性的操作. 增加一个flush的函数,
audiobox应该设定40ms的缺省帧长
应该可以直接使用下面接口,快进所有的frame,一直到无数据为止
```cpp
snd_pcm_forward(dev->handle, size);
printk(KERN_DEBUG "~~~(%s, %d) %x %x %x -- %x == %x --  %x %x -- %x ~~~\n", __func__, __LINE__
, runtime->status->hw_ptr
, runtime->control->appl_ptr
, prtd->app_copy_ptr
, prtd->dma_pos/8
, prtd->last_valid_pos/8
, prtd->app_pos/8
, prtd->dma_copy_pos/8
, prtd->fill_silence
);

```

**03-19**<br>

snd_pcm_close()之前应该增加snd_pcm_drain(),保证播放完毕.
audiobox应该返回在某个系统时间点上,延时等等的参数,这样,即使上层被阻塞一段时间,仍然可以得到准确的音视频同步播放时间. 这个同步时间,应该是write一个Frame之后锁定alsa接口,然后调用,获取到pcm delay和当前时间,通知上层

**03-18**<br>
imapx_dma.c中增加一个sound链表，可以根据device找到对应的管理信息；这是因为，aecv2_controler并不能简单归纳入imapx_runtime_data，因为它包含了较多的录音和播放两个方向的关联信息。

先确定上次什么位置开始填充静音的，然后，等hw_ptr大于它，代表已播放完毕；
runtime->control->appl_ptr 应该是下一个写入的帧的开始位置

如果需要进一步的读取更加精确的剩余时间，那么需要读取dam位置信息。

**03-16**<br>
启动过程
```cpp
printf("~~~(%s, %d)~~~%p %p %s\n", __func__, __LINE__, pcmp, *pcmp, name);

int snd_pcm_open(snd_pcm_t **pcmp, const char *name, snd_pcm_stream_t stream, int mode)
  int err = snd_config_update();
  return snd_pcm_open_noupdate(pcmp, snd_config, name, stream, mode, 0);
    err = snd_config_search_definition(root, "pcm", name, &pcm_conf);
    snd_config_set_hop(pcm_conf, hop);
    err = snd_pcm_open_conf(pcmp, name, root, pcm_conf, stream, mode);
      _snd_pcm_empty_open
        _snd_pcm_plug_open
          err = snd_pcm_open_slave(&spcm, root, sconf, stream, mode, conf);
          err = snd_pcm_plug_open(pcmp, name, sformat, schannels, srate, rate_converter, route_policy, ttable, ssize, cused, sused, spcm, 1);
            _snd_pcm_hw_open
              snd_pcm_hw_open

int snd_pcm_hw_params(snd_pcm_t *pcm, snd_pcm_hw_params_t *params)
  int err = _snd_pcm_hw_params(pcm, params);
    int err = pcm->ops->hw_params(pcm->op_arg, params); //int snd_pcm_plug_change_format(snd_pcm_t *pcm, snd_pcm_t **new, snd_pcm_plug_params_t *clt, snd_pcm_plug_params_t *slv)
      err = snd_pcm_plug_insert_plugins(pcm, &clt_params, &slv_params);
        int snd_pcm_plug_change_format(snd_pcm_t *pcm, snd_pcm_t **new, snd_pcm_plug_params_t *clt, snd_pcm_plug_params_t *slv)
          snd_pcm_linear_open(new, NULL, slv->format, plug->gen.slave, plug->gen.slave != plug->req_slave);
            err = snd_pcm_new(&pcm, SND_PCM_TYPE_LINEAR, name, slave->stream, slave->mode);
            pcm->fast_ops = &snd_pcm_plugin_fast_ops;
            snd_pcm_set_hw_ptr(pcm, &linear->plug.hw_ptr, -1, 0);
            snd_pcm_set_appl_ptr(pcm, &linear->plug.appl_ptr, -1, 0);

~~~(snd_pcm_hw_open, 1310)~~~0xb6b0b9e8 0x2ca18 (null)
~~~(snd_pcm_plug_open, 1148)~~~0x22278 0x2cd30 default
~~~(_snd_pcm_empty_open, 106)~~~0x22278 0x2cd30 default
```
**03-15**<br>
开始填0的时候设置flag并递增，收到数据的时候清除flag.上层可以通过读取这个flag得知已经填多少个0，下层是否已经播放完毕。或者，put_channel的时候通过这个机制来判断，比延时关闭放音设备更好。如果有更高精度要求
put_channel 时候，增加参数
put_channel函数阻塞，返回的时候表示播放完毕，如何？

读取数据，如果当前hw_ptr位置是上次最后一次数据的app_ptr位置，那么，播放完成了

**03-14**<br>
es8323增加如下： SOC_SINGLE_XR_SX("Infotm Spk Playback Volume", 0x2e, 4, 5, 0, 0x2e, 0), auidobox应该读取参数个数然后配置相应个数的音量

**03-13**<br>
x15的i2s的mclk必须手动初始化

**03-12**<br>
早上08:07到公司

如果支持audio_route_cset，那么不改写下面两个：
  chndata_set_mvol_setting(dev_name, volume);
  dev->m_volume
这样，相当于音量100

继续跟踪函数 int snd_ctl_elem_info(struct snd_ctl_file *ctl, struct snd_ctl_elem_info *info)如何获取step参数
先尝试硬件处理，失败，转软件方式以保持向前兼容。

**03-11**<br>
早上08:06到公司

audiobox增加新的函数，读取下层kcontrol的min和max和db范围，一般是0dB到-90dB，即使有误差也不大；然后直接计算得到音量，而不需要在驱动层次调试。另外提供另外一个kcontrol，供查询db范围如何？

如下面数据结构定义：
```cpp
struct sndrv_ctl_elem_info {
	struct sndrv_ctl_elem_id id;	/* W: element ID */
	int type;			/* R: value type - SNDRV_CTL_ELEM_TYPE_* */
	unsigned int access;		/* R: value access (bitmask) - SNDRV_CTL_ELEM_ACCESS_* */
	unsigned int count;		/* count of values */
	pid_t owner;			/* owner's PID of this control */
	union {
		struct {
			long min;		/* R: minimum value */
			long max;		/* R: maximum value */
			long step;		/* R: step (0 variable) */
		} integer;
		struct {
			long long min;		/* R: minimum value */
			long long max;		/* R: maximum value */
			long long step;		/* R: step (0 variable) */
		} integer64;
```
两个问题：
1. 部分手头没有的平台，如何处置
2. 给上层提供的音量接口，根据一般客户感受，还是现有的db量化
3. 之后可以增加： softvol放大功能，比如2550就是放大10倍


统一使用`Speaker Playback Volume`作放音音量控制；至于录音音量控制，可以在x15开发板上，控制reg11看是否；

为了兼容不同的codec，audiobox调用应该采用统一的volume定义(对应了实际的db)，这样，到reg值的转换，应该在下层完成。应该考虑使用tlv的方式来设置音量。不同的codec，根据最大最小取值以及对应的db变换范围，确定最小db和step这两个参数即可。应该以最大音量为0db，如果取值范围大，那么变化1对应的db就小。比如100->50，应该对应降低多少db呢？

增加音量控制功能的基本范例：
```cpp
static const struct snd_kcontrol_new fr1023_snd_controls[] = {
    SOC_SINGLE_EXT("Speaker Enable Switch", 0, 0, 1, 0, fr1023_spk_get, fr1023_spk_put),
  	SOC_DOUBLE_R("Speaker Playback Volume", FR1023_CONTROL18, FR1023_CONTROL19, 0, 63, 1),
};
int fr1023_probe(struct snd_soc_codec *codec)
  snd_soc_add_codec_controls(codec, fr1023_snd_controls, ARRAY_SIZE(fr1023_snd_controls));
```

应该把libdsp的驱动注册进入ffmpeg中，然后增加额外的注册?好像不是标准的。

重采样和编码应该分开

跟踪 swr_convert 函数的处理，找到bug所在。
～～～～～ aec前面应该增加一个recombine，每次获取固定的采样点，这样，可以方便的支持512的整数倍的帧
～～～～～ 重采样，先看看现有机制，是否内置有
～～～～～ 编码前，增加recombine函数接口

## 02-01->02-28...
**02-29**<br>
**02-28**<br>
audiobox -l 1ffff &
abctrl record -W 16 -w 32 --enable-aec -s 16000 -n 2 -t 1 -f 576 -o /mnt/sd0/record_1.mp3
**02-27**<br>
make libffmpeg-rebuild;make libcodecs-dirclean;make libcodecs-rebuild;make audiobox-dirclean;make audiobox-rebuild;make;./tools/gendisk.sh /dev/sdb

abctrl record -W 16 -w 32 -s 8000 -n 2 -t 2 -o /mnt/sd0/record_3.mp3
gdb audiobox -l 1ffff

mp3录音，是否可以如下测试：
abctrl record -w 32 -s 16000 -n 2 -t 1 -f 576 -o /mnt/sd0/record_1.mp3
abctrl record -w 32 -s 16000 -n 2 -t 1 -F 1024 -f 576 -o /mnt/sd0/record_2.mp3
abctrl record -W 32 -w 16 -s 16000 -n 2 -t 1 -f 576 -o /mnt/sd0/record_3.mp3

**02-25**<br>
libffmpeg.mk文件中：
LIBFFMPEG_DEPENDENCIES += lame
LIBFFMPEG_CONFIG_ENCODER += --enable-libmp3lame
LIBFFMPEG_CONFIG_ENCODER += --enable-encoder=mp3lame
LIBFFMPEG_CONFIG_MUXER += --enable-muxer=mp3
**02-26**<br>
cd ~/work/mp3_encoder/deprecated-lame-mirror
./configure
make
./frontend/lame testcase.wav test.mp3
```cpp

需要 CONFIG_MP3_MUXER
//这个好像是填写mp3头部信息的模块
ff_libmp3lame_encoder
AVOutputFormat ff_mp3_muxer = {
    .name              = "mp3",
    .long_name         = NULL_IF_CONFIG_SMALL("MP3 (MPEG audio layer 3)"),
    .mime_type         = "audio/mpeg",
    .extensions        = "mp3",
    .priv_data_size    = sizeof(MP3Context),
    .audio_codec       = AV_CODEC_ID_MP3,
    .video_codec       = AV_CODEC_ID_PNG,
    .write_header      = mp3_write_header,
    .write_packet      = mp3_write_packet,
    .write_trailer     = mp3_write_trailer,
    .query_codec       = query_codec,
    .flags             = AVFMT_NOTIMESTAMPS,
    .priv_class        = &mp3_muxer_class,
};

//注册所有的codec到ffmpeg
void avcodec_register_all(void)
//注册所有的codec到ffmpeg
void avdevice_register_all(void)
//注册所有的codec到ffmpeg
void av_register_all(void)
  REGISTER_MUXDEMUX(MP3,              mp3);
```
**02-18**<br>
安装画图工具：  `sudo apt-get install graphviz`

1. 需要补充三张图片：1. audiobox框图 2. dev/channel/apu链表 3. 录音和放音线程泳道图
2. 增加Audiobox的启动过程，图看情况
3. 增加api接口调用流程，图看情况，多个线程多个消息队列间

可以考虑，逐步完善文档

**02-19**<br>
**02-20**<br>

## 01-21->...
**01-28**<br>

**申请第一个录音通道**

只分析下面场景： 设备aec2.0使能，通道aec使能，codec为g711a，两个通道参数相同的场景

```cpp
int audiobox_get_channel(struct event_scatter *event)
	... //调整校验音频通道和设备参数
	devctrl_create_dev()
		devctrl_alloc_dev()//申请并初始化dev管理信息
		devctrl_activate_server()
			audio_hal_open()//为设备启动录音PCM设备
			devctrl_alloc_devfr()//为设备申请`dev_fr`和`dev_fr_mapped`
			audio_create_devserv()//启动capture server线程
		list_add_tail(&dev->node, &audiobox_devlist);//dev添加到`audiobox_devlist`链表
	... //申请并初始化channel管理信息
	apu_preproc_create()
		apu_preproc_prepare()//为设备申请`aec_fr`并初始化aec lib和管理信息
		pthread_create(&dev->preproc_pid, NULL, thread_apu_preproc, p_preproc);//启动aec处理线程
	apu_codec_create()
		apu_fr_alloc(dev, &chn->channel_fr, FR_NAME_CHAN_PREFIX); //为通道申请`chan_fr`
		__apu_codec_create(chn);
			... //申请并初始化codec管理信息
			apu_codec_prepare()
				apu_fr_alloc(dev, &p_codec->codec_fr_para, FR_NAME_CODEC_PREFIX);//为codec子模块申请`codec_fr`
				softvol_apu_open(apu_handle); //申请softvol子模块
				recombiner_apu_open(apu_handle); //申请recombine子模块
				codec_apu_open(apu_handle); //申请codec子模块
			list_add_tail(&chn->chn_node, &p_codec->vchanlist);//通道添加到codec的通道链表
			list_add_tail(&p_codec->node, &dev->apulist); //codec添加到设备的codec链表
		apu_codec_start(chn); //启动通道编码处理线程
	list_add_tail(&chn->node, &dev->head); //channel添加到dev的通道链表
```

```cpp
int audiobox_get_channel(struct event_scatter *event)
	... //调整校验音频通道和设备参数
	... //申请并初始化channel管理信息
	apu_codec_create()
		apu_fr_alloc(dev, &chn->channel_fr, FR_NAME_CHAN_PREFIX); //为通道申请`chan_fr`
		__apu_codec_create(chn);
			//第二通道和第一通道参数相同，可共享第一个通道的codec
			list_add_tail(&chn->chn_node, &p_codec->vchanlist);//通道添加到codec的通道链表
	list_add_tail(&chn->node, &dev->head); //channel添加到dev的通道链表
```

```cpp
int __audiobox_put_channel(int id)
	remove_chan_node(dev, chn);
		list_del(&chn->node); //从dev通道链表中移除通道
		list_del(&chn->chn_node); //从codec通道链表中移除通道
	apu_codec_destroy(chn);
		p_codec->ref_counter--; //codec的引用索引递减
		apu_fr_free(dev, &chn->channel_fr); //释放`chan_fr`
	free(chn);
```

```cpp
int __audiobox_put_channel(int id)
	remove_chan_node(dev, chn);
		list_del(&chn->node); //从dev通道链表中移除通道
		list_del(&chn->chn_node); //从codec通道链表中移除通道
	apu_codec_destroy(chn);
		pthread_join(p_codec->apu_pid, NULL); //通道处理线程退出
		apu_fr_free(dev, &chn->channel_fr); //释放`chan_fr`
		apu_fr_free(dev, &p_codec->codec_fr_para); //释放`codec_fr`
		list_del(&p_codec->node); //从dev的codec链表中移除codec
		apu_codec_unprepare(p_codec, 1);
			softvol_apu_close(p_codec); //关闭softvol子模块
			codec_apu_close(p_codec); //关闭codec子模块
			recombiner_apu_close(p_codec); //关闭recombiner子模块
		free(p_codec);
	free(chn);
	apu_preproc_destroy(dev);
		apu_preproc_unprepare(dev);
			pthread_join(dev->preproc_pid, NULL); //停止aec处理线程
			aec_lib_deactivate_preproc(p_preproc); //释放`aec_fr`并 deinit aec_lib
	devctrl_try_destroy_dev(dev);
		list_del(&dev->node);	//从`audiobox_devlist`链表中移除dev
		devctrl_deactivate_server()
			audio_release_devserv(dev); //退出capture server线程
			apu_fr_free(dev, &dev->dev_fr_para); //释放`dev_fr`
			apu_fr_free(dev, &dev->dev_fr_para_mapped); //释放`dev_fr_mapped`
			audio_hal_close(dev); //关闭PCM设备
```


```cpp
int audiobox_get_channel(struct event_scatter *event)
	... //调整校验音频通道和设备参数
	devctrl_create_dev()
		devctrl_alloc_dev()//申请并初始化dev管理信息
		devctrl_activate_server()
			audio_hal_open()//为设备启动放音PCM设备
			devctrl_alloc_devfr()//为设备申请`dev_fr`
			audio_create_devserv()//启动playback server线程
		list_add_tail(&dev->node, &audiobox_devlist);//dev添加到`audiobox_devlist`链表
	... //申请并初始化channel管理信息
	apu_codec_create()
		apu_fr_alloc(dev, &chn->channel_fr, FR_NAME_CHAN_PREFIX); //为通道申请`chan_fr`
		__apu_codec_create(chn);
			... //申请并初始化codec管理信息
			apu_codec_prepare()
				apu_fr_alloc(dev, &p_codec->codec_fr_para, FR_NAME_CODEC_PREFIX);//为codec子模块申请`codec_fr`
				softvol_apu_open(apu_handle); //申请softvol子模块
				recombiner_apu_open(apu_handle); //申请recombine子模块
				codec_apu_open(apu_handle); //申请codec子模块
			list_add_tail(&chn->chn_node, &p_codec->vchanlist);//通道添加到codec的通道链表
			list_add_tail(&p_codec->node, &dev->apulist); //codec添加到设备的codec链表
		apu_codec_start(chn); //启动设备统一的解码处理线程
	list_add_tail(&chn->node, &dev->head); //channel添加到dev的通道链表
```

```cpp
int audiobox_get_channel(struct event_scatter *event)
	... //调整校验音频通道和设备参数
	... //申请并初始化channel管理信息
	apu_codec_create()
		apu_fr_alloc(dev, &chn->channel_fr, FR_NAME_CHAN_PREFIX); //为通道申请`chan_fr`
		__apu_codec_create(chn);
			... //申请并初始化codec管理信息
			apu_codec_prepare()
				apu_fr_alloc(dev, &p_codec->codec_fr_para, FR_NAME_CODEC_PREFIX);//为codec子模块申请`codec_fr`
				softvol_apu_open(apu_handle); //申请softvol子模块
				recombiner_apu_open(apu_handle); //申请recombine子模块
				codec_apu_open(apu_handle); //申请codec子模块
			list_add_tail(&chn->chn_node, &p_codec->vchanlist);//通道添加到codec的通道链表
			list_add_tail(&p_codec->node, &dev->apulist); //codec添加到设备的codec链表
		apu_codec_start(chn); //无实际操作，因为解码线程之前已启动
	list_add_tail(&chn->node, &dev->head); //channel添加到dev的通道链表
```

```cpp
int __audiobox_put_channel(int id)
	remove_chan_node(dev, chn);
		list_del(&chn->node); //从dev通道链表中移除通道
	apu_codec_destroy(chn);
		apu_fr_free(dev, &chn->channel_fr); //释放`chan_fr`
		list_del(&p_codec->node); //从dev的codec链表中移除codec
		apu_codec_unprepare(p_codec, 1);
			softvol_apu_close(p_codec); //关闭softvol子模块
			codec_apu_close(p_codec); //关闭codec子模块
			recombiner_apu_close(p_codec); //关闭recombiner子模块
      apu_fr_free(dev, &p_codec->codec_fr_para); //释放`codec_fr`
		free(p_codec);
	free(chn);
```

```cpp
int __audiobox_put_channel(int id)
	remove_chan_node(dev, chn);
		list_del(&chn->node); //从dev通道链表中移除通道
	apu_codec_destroy(chn);
		apu_fr_free(dev, &chn->channel_fr); //释放`chan_fr`
		list_del(&p_codec->node); //从dev的codec链表中移除codec
		apu_codec_unprepare(p_codec, 1);
			softvol_apu_close(p_codec); //关闭softvol子模块
			codec_apu_close(p_codec); //关闭codec子模块
			recombiner_apu_close(p_codec); //关闭recombiner子模块
      apu_fr_free(dev, &p_codec->codec_fr_para); //释放`codec_fr`
		free(p_codec);
    pthread_join(dev->decoder_pid, NULL);
	free(chn);
	devctrl_try_destroy_dev(dev);
		list_del(&dev->node);	//从`audiobox_devlist`链表中移除dev
		devctrl_deactivate_server()
			audio_release_devserv(dev); //退出playback server线程
			apu_fr_free(dev, &dev->dev_fr_para); //释放`dev_fr`
			audio_hal_close(dev); //关闭PCM设备
```

**01-27**<br>
背景音的播放，应该永不停息，前景音播放多少，背景音就跳过多少，这样，方便音视频同步的处理，也更加自然符合逻辑。这样，只需要计算播放了多少帧，中间填充了多少静音，就可以计算得到准确的播放延时。

**01-25**<br>
音视频同步播放的问题，在audiobox中增加一个新的api，获取当前fr和alsa中总计累积的音频帧对应`时间`，注意是`时间`，输入参数为通道handle
精度需要保证，因而，需要直接读取dma当前位置信息。放音时因为采用了静音填充，故而可以考虑设置创建通道时候播放第一帧时候时间为0，时间轴单调递增。获取到的时间戳应该是dma播放的时间时间，直接在`imapx_audio_buffdone()`函数中，累加放音时间；
int imapx_pcm_new(struct snd_soc_pcm_runtime *rtd)函数中，为`pcm->card->dev` SNDRV_PCM_STREAM_PLAYBACK 设备增加一个device_file提供当前真实高精度时间戳
audiobox提供函数接口，参数为通道，从通道得到设备名称，然后得到设备id，然后直接读取device_file,可以避免eventhub机制的低效干扰。
另外，这样获取到的时间，是绝对播放时间，而不是通道自己的相对播放时间。比如，如果通道数据underrun，下层自动填充静音，那么，上下理解时间上可能不同。
音视频同步，应该发生在播放文件的场景。

增加fill silence计数，这样就知道播放的实际音频帧的个数了；这可以通过提供一个相对时间戳来实现，上面的是绝对时间戳。一般来说，应该通过相对时间戳来实现音视频同步控制。

视频播放线程应该只需要关心当前已经播放了多少个音频帧。
在下层统计的话，需要考虑到可能存在插入的前景播放的影响。
当前通道已经播放的，可以通过audiobox中fr的残留总大小，加上当前alsa buffer总的残留大小，参考当前通道历史总大小，估算得到当前正在播放的音频的时间戳。

放音时，多个同类通道，应该是禁止的，或者，不需要考虑这种场景了；也就是说，如果当前已经有了一个背景音通道，创建新的背景音通道会失败。否则，处理上会有非常烦人的事情。
前景音通道，应该无所谓音视频同步问题；对于背景音通道，所有的插入的前景音通道时间和帧率，都应该计算入。

根据当前设备当前背景音通道和所有当前前景音通道fr剩余数据，和alsa buffer剩余数据，和dma中Position，模拟计算，当前正在播放的音频帧的时间戳。如果大量插入前景音，可能导致得到荒谬的负值。

音视频同步烦人的因素：
1. 填充静音
2. 其他通道
3. xrun

**01-24**<br>
填充静音影响因素：
1. aecv2时，reserve number
2. snd_pcm_update_hw_ptr0()函数中，runtime->status->hw_ptr = new_hw_ptr;位置影响
3. dma的buffer的period总个数

## 01-14->...
数据结构章节中包含基本数据结构和fr两个部分

数据结构章节中，画图，描述下面链表结构：
struct audio_dev {
  struct list_head node;//dev的节点
	struct list_head head; //channel链表头部
	struct list_head apulist; //apu链表头

  int fr_total_size; //dev已经占用的fr大小
  int foreground_chan_counter;//没有存在的必要，如果有前景音播放，申请通道应该直接失败的。

struct audio_chn {
  struct list_head node;
  struct list_head chn_node;//node for vchanlist in apu.

typedef	struct	_apu_codec_{
  struct list_head node;    //节点 --> apulist
	struct list_head vchanlist; //list of capture channels referring to this codec //只有录音

4个dev
图中，4个channel应该有两个通道参数完全一致的，另外两个参数不一致；对应3个 codec 节点

放音图，录音图分开

然后，结构体中定义的主要单元，大概描述一下。


## 2019 01-07->...
  cd ~/work/qsdkdoc/psdocs/qsdk/books/pg-audiobox

改变master_volume，可以在devfr之前或者之后，但额外进行了一次运算。

**01-11**<br>
struct audio_dev {
**01-10**<br>
设计文档：
- audiobox启动过程，eventhub
- 录音过程： devfr aec softvol recombine encoder
- 放音过程： decoder recombine softvol devfr
- fr定义
- apu概念： softvol recombine codec，录音时关联到codecfr，放音时关联到devfr
- 创建通道流程： 通道参数校验，申请fr，初始化alsa，启动线程
- 录音capture线程，mapped处理线程，aec线程，apucodec对应的编码线程，而非每个channel对应一个thread.
- 放音线程

需要解析流程的几个主要函数：
- audiobox_get_channel
- audiobox_activate_channel
- audiobox_set_format
- audiobox_enable_aec
-

```cpp
//--- 启动设备：
audio_dev_t devctrl_create_dev(char *dev_name, audio_dev_attr_t *attr)
  dev = devctrl_alloc_dev(dev_name, attr);//申请并初始化设备管理数据结构
  devctrl_activate_server(dev);//int devctrl_activate_server(audio_dev_t dev)
    audio_hal_open(dev);
    devctrl_alloc_devfr(dev);//申请dev_fr_para，AEC2.0会额外申请dev_fr_para_mapped
    audio_create_devserv(dev);//启动设备层录音或放音线程
//--- 启动设备：
```
画图呢，还是用代码流程来表示。

基本数据结构，好像无必要再详细描述

```cpp
//2.1 立体数据结构
//下面关系，是否应该给出示意图
LIST_HEAD(audiobox_devlist); //设备链表
  struct audio_dev
    struct list_head node; //添加到audiobox_devlist的本身node
    struct list_head head; //有效channel链表
    struct list_head apulist; //apu codec链表

    apu_codec_t
      list_add_tail(&chn->chn_node, &p_codec->vchanlist);

内部实现：
```

```cpp
//2.2 fr定义和图
先描述基本的fr定义介绍
fr访问的基本模式： get - proc - put 不需要体现在文档中
某些函数，如果需要详细解析，可以在泳道下面增加新的图
```
```cpp
//2.3 基本的处理模块介绍

```
融合了线程和处理流程和fr数据结构，使用fr名称来代表fr
能否使用纵坐标作为fr来区分呢？

怎么插入线程呢？
alsa --(thread::audio_hal_read())> devfr --()> aecfr --> codecfr --> chanfr

横坐标为线程或者模块：
  alsa lib ++ thread_audio_capture_server线程 ++ thread_audio_capture_server_mapped线程 ++

  线程之间为

函数处理流程和fr数据流程结合为一：
- 通道创建过程
- 通道销毁过程
- set_format过程
- 各种通道类型对应流程

--- 启动录音设备：

录音和放音全路径介绍，带图

// 章节：audiobox中管理数据结构和管理方式
// 章节：audiobox中的fr

描述fr在audiobox设计中的作用，然后绘制一个最长路径录音和放音。

然后，列出所有的fr，描述作用，还有命名规则

fr定义：
//struct audio_dev
- struct	_apu_frnode_ dev_fr_para; //vacant fr for playback dev, real fr for capture.dev
- struct	_apu_frnode_ dev_fr_para_mapped; //
- struct	_apu_frnode_ dev_preprocfr_para;//for capture dev, aec proc output fr; no use for playback.dev
//struct audio_chn
- struct	_apu_frnode_ channel_fr;
//struct	_apu_codec_
- struct	_apu_frnode_ codec_fr_para; //encoder and decoder out fr

设计文档：
- 1.优化效率，录音放音通道和设备参数相同时，hal到channel之间只需要一次数据拷贝
- 2.设备帧和通道帧非一一对应时，增加recombine模块重新组帧处理，之前处理避开这个问题，无视应用层采样点大小设定。
- 3.放音过程调用audio_put_chanel销毁最后一个通道时，播放完所有帧再退出playback server，以保证体验
- fr命名规则

放音：
- chanfr -> codecfr (by chan_codec) -> devfr(softvol recombine)
- chanfr -> devfr

录音，使能aec:
- devfr -> aecfr -> codecfr -> chanfr
- devfr -> aecfr -> chanfr

录音2.0：
- devfr -> mappedfr -> codecfr -> chanfr
- devfr -> mappedfr -> chanfr

录音1.0：
- devfr -> codecfr -> chanfr
- devfr -> chanfr

**01-09**<br>
整理audiobox_v2文档；设备参数限制：
- if(dev->attr.samplingrate > (MAX_FRAME_RATE*dev->attr.sample_size))
- 采样率当前只支持8k的整数倍
- channel：必须为 2
- bitwidth : 16或32
- sample_size : 最大为samplingrate/40
**01-08**<br>
audio相关的bug列表:
- [APOLLO3] audio codec驱动开发验证 功能 #2392
- QSDK:[Allchip][BSP]对audiobox的需求进行分析 功能 #4782
- QSDK:[Allchip][MID]添加ISP实时信息查询 功能 #4425
- QSDK:[Allchip][BSP]Audiobox 优化 功能 #4719
- BU1: auido frame timestamp error 错误 #4737

设备参数确定方式支持不关闭通道调用 audio_set_format() 改变设备参数

**01-07**<br>
增加的函数接口只有两个：
  int audio_get_channel_ex(const char *dev, audio_chn_fmt_t *chn_fmt, int flag)
  int audio_enhance_mode(void)
  增强模式和兼容模式

## 公司信息
公司腾讯企业邮箱。微信客户端绑定密码 : ooErfMAnogvZeWtL

密码管理：
需要修改密码的项目：　qq 微信　支付宝　工商银行　招商银行　印象笔记　网易邮箱和云　百度云百度账号　
需要管理的支付密码：　工商银行　招商银行　微信红包　
所有的技术和论坛，都是用　ericyun110322    ，密码　为　中学　１　３　３　应该不会需要用大写的情况，而且也够长。１１个字符刚好。
无所谓的普通的信息和公司密码，爱家，快捷方便为主啊
印象笔记非常重要的个人笔记， 活期通, 微信，支付宝，银行等相关的

dd if=/dev/zero of=/dev/spiblock0 bs=1M count=1
dd if=/dev/zero of=/dev/mmcblk0 skip=16M bs=1M count=1

ipcs -q　获取消息队列表，然后根据key，进入队列，从队列中查询，从队列中删除。

audio驱动当前缺少32khz的支持； audiobox_set_chn_mute 函数现在实际上是无效的

printk(KERN_EMERG "~~~(%s, %d)~~~\n", __func__, __LINE__);

.mk .pc文件
depends on BR2_PRIMARY_SITE != ""
depends on BR2_EXTERNAL != "buildroot/support/dummy-external"
select BR2_PACKAGE_SSTRIP_HOST
depends on !BR2_PACKAGE_HOST_ELF2FLT
default "$(TOPDIR)/buildroot/local.mk"

显示下次make将会编译的所有目标，这样方便调试。
    make show-targets;make help;make pkg-source;//pkg只下载; make pkg-extract;//pkg只下载和解压但不编译，可以在output/build/目录中修改后编译

## 2017-09月-结束了
trace中，应该定义一个宏，可以直接显示函数行号时间信息，可以定义前缀后缀字符如＠＃￥以及个数，
关键字：　公司产品相关 BU1相关
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
09.04~09.06 audio部分驱动
--------------------------------------------------------------------------------
08.29~09.01 周2~5
08.29：上午1/4_bit_line kernel和uboot修正，下午看audiobox需求文档，同时做auto delayline测试；由于tf卡延长线太粗，撑坏了Q3f板子的卡槽，导致识别失败浪费时间
08.30：上午修改和验证和提交rm#4901的apollo版本；然后整理之前mmc_test的程序，验证和测试rm#5367的问题
08.31：进程退出时audiobox释放它可能释放的channel,解决rm#5460
09.01：上午提交rm#5460修正，下午阅读hisi音频文档，开始看sound部分的驱动。
--------------------------------------------------------------------------------
使用MDwiki预览编写的文档：
cd ~/work/qsdkdoc/psdocs
python -m SimpleHTTPServer 8080
http://127.0.0.1:8080/#!qsdk/books/pg-videobox/main_audiobox.md
--------------------------------------------------------------------------------
员清观
年龄：　　　　40
职位：　　　　资深软件开发工程师
政治面貌：　无
工作单位：　上海盈方微电子股份有限公司
工作地址：　上海市浦东新区张江高科技园区祖冲之路2290弄展想广场1号16层
电话：　　　　18616715815
--------------------------------------------------------------------------------
08.14~08.18 周1
周1 牙种植手术，之后３天特别经常头晕，估计和消炎药以及甲硝唑有关；
周二上午，调试sd卡4-1线切换的问题，有初步的进展，下午开始详细了解和验证audiobox部分的功能
周三周会上催促audiobox的文档进度，看来无法细致学习了，开始写audiobox文档；周４全天文档
周五
--------------------------------------------------------------------------------
08.11 周5
本周主要调试uboot相关的部分的内容。遇到了不少问题。详细见RM#4826
最好和work目录平级建立一个新的orig目录，运行不同EVB只要烧录就好了，最多更新一下程序，更加方便一些。这个目录的内容不应该做任何修改，或者修改之后立刻恢复。
--------------------------------------------------------------------------------
08.03 周4
handler_init  中创建handler_ID对应的mq
     handler_msg_queue_create
          handler_key = getpid();
          handler_ID = msgget(handler_key, IPC_EXCL | IPC_CREAT | 0777);
int provider_init(void)
     provider_msg_queue_create(eventd_pid);

int eventd_serv_init()  中创建(关联)３个mq
     eventd_handler_key = eventd_provider_key = getpid();
     eventd_handler_ID = eventd_handler_msg_queue_create(getpid());
     eventd_provider_ID = eventd_provider_msg_queue_create(getpid());
     provider_ID = provider_msg_queue_create(getpid());

1.eventd_handler_ID
     eventd_handler_msg_queue_create   ／／创建
     Send_Handler_Register_Event
          event_register_handler &&&  event_unregister_handler //应用
     Read_Handler_Register_Event
          register_thread_fun　          //eventd
2.eventd_provider_ID
     eventd_provider_msg_queue_create   ／／创建
     Read_Provider_Register_Event       ／／没用到
     Send_Provider_Register_Event       ／／没用到
3.provider_ID
     provider_msg_queue_create          ／／创建
     Read_Data_Event_From_Provider
          rec_data_thread_fun
               register_thread_fun　//eventhub进程中创建的线程。
     Send_Data_Event_To_Eventd     ／／发送event请求到eventd
          event_send　　&&&  event_rpc_call
4. handler_ID
     handler_msg_queue_create          ／／创建
          handler_init
               event_register_handler，　进程注册event的时候调用和创建。
     Read_Handler_Register_Return  //专门读取　Send_Handler_Register_Event　注册注销返回信息
          event_register_handler
          event_unregister_handler
               ／／应用进程调用

Read_Return_From_Handler

--------------------------------------------------------------------------------
08.02 周3
dd if=/dev/zero of=/dev/spiblock0 bs=1M count=1
--------------------------------------------------------------------------------
07.21 周5 jack.ye
git rebase -i dev_qsdk
git commit --amend -m "RM#NONE: add SD/MMC card speed test program"
git branch new-feature dev_qsdk 基于dev_qsdk建立新的branch开发新功能
新的branch上,可以自由的commit,不需要特别注意注释
git branch merge-feature new-feature   开发完成后,基于建立新的merge用的branch
git checkout merge-feature
git rebase -i dev_qsdk        fixup保留commit而丢弃不需要的comment
repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b dev_qsdk_dv
repo sync -c
repo start --all dev_qsdk_dv
repo forall -c "git checkout tag_before_merge_2.2.0"

make linux-menuconfig
     device drvier
           Infotm special files and drivers
InfoTM power detect driver support
if (!strncmp(provider_data.event.name, EVENT_PROCESS_END, strlen(EVENT_PROCESS_END))){
			int	*p_pid = (int*)provider_data.event.buf;
			//printf("~~~~~~~~"~~%s.....%d....name:%s for:%d, %s\n", __FUNCTION__, __LINE__, provider_data.event.name, *p_pid, p_pid+1);
			int msg_id = msgget(*p_pid, 0);
			if(msg_id > 0)
				msgctl(msg_id, IPC_RMID, NULL);

			return;
		}
--------------------------------------------------------------------------------
07.20 周4
修改pr_detect.c之后，videobox初始化出现错误，出现３色图像，clean后重新编译
运行出现frlib ver:10, fr driver ver:11错误,没办法，重新编译tf360.　基本步骤：make clean; make menuconfig 手动使能libswcale，如果make过程中失败后才使能，那么需要重新clean.
编译出错find: ‘output/product/items.itm.tmp’: No such file or directory，直接cp items.itm items.itm.tmp
configure: error: Package requirements (libswresample >= 1.0.0) were not met:     手动使能libswresample
cannot find -lqmediautils　　使能qlibmediautils(和qlibffmpeg同级)，并使能前两个子配置。
--------------------------------------------------------------------------------
07.19 周3
aac adts length
return ((buf[3] & 0x3) << 11) | (buf[4] << 3) | (buf[5] >> 5);
1. make menuconfig-->Qsdk options->Apps->common event provider
2. 初始化脚本中launcher &前添加: cepd &
3. 然后还是没有进程关闭的打印，cep中增加打印，发现socket没有收到信息；pr_detect.c中，init_module增加打印确认已经增加进来。然后，发现pr_detect原有的replace_func功能异常，阅读内核代码之后删除这个函数。替换代码：
4.
void my_profile_task_exit(struct notifier_block *self, unsigned long val, void *data){
	struct process_info info;
	if(strcmp(current->comm, "mdev")) {
		info.pid = current->pid;
		strncpy(info.name, current->comm, strlen(current->comm)+1);
		nl_sendmsg(nl_sk, &info);
	}
}
static struct notifier_block my_task_exit_nb = {
	.notifier_call = my_profile_task_exit,
};
static int _init_module(void ) {
	struct netlink_kernel_cfg cfg = {
		.groups = 1,
		.input = NULL,
	};
	profile_event_register(PROFILE_TASK_EXIT, &my_task_exit_nb);
	nl_sk = netlink_kernel_create(&init_net, NETLINK_USER, &cfg);
	if (!nl_sk) {
		printk(KERN_ALERT "Error creating socket.\n");
		return -1;
	}
	return 0;
}
static void _cleanup_module(void)
{
	netlink_kernel_release(nl_sk);
}
--------------------------------------------------------------------------------
07.18 周2
vb_ctrl测试脚本
#!/bin/sh
mkdir /mnt/sd0/
r=0
i=0
times=100000
while [ $i -le $times ]
do
        videoboxd &
        sleep 2
        vbctrl cam -c isp --snapcapture=one
        sleep 1
        vbctrl stop
        sleep 1
    let "i++"
done
--------------------------------------------------------------------------------
07.17 周1 audiobox优先级相关代码测试验证
--------------------------------------------------------------------------------
07.14 周5/6 音频相关代码学习
--------------------------------------------------------------------------------
07.13 周4 音频编码 音频解码 dsp
make linux-menuconfig :
device drvier
	infotm special files and drivers
		infotm q3f series support
			q3f dsp driver support
				ceva tl421 dsp
					encoder decoder aec
device drvier   //pr_detect
	infotm special files and drivers
--------------------------------------------------------------------------------
07.12 周3 解决#3941，开始跟踪#4496，
初步分析卡顿原因：录像时采样率48000,每个帧1024个采样，所以每秒产生大概47个音频帧．但是播放时，统计发现每秒发送不到３０个音频帧到audiobox，这导致underrun，产生卡顿．所以应该是qplayer帧控制产生的问题．
继续跟踪代码．
定时关机　sudo shutdown -h +30
--------------------------------------------------------------------------------
07.11 周2
修改burn.ixl，调整了几个image的顺序之后，调试uboot1就不需要强制先烧录kernel.
#name q3evb burn.ixl, for make ius
#images:
i run 0x08000200 0x08000000 ../../output/images/uboot0.isi
r flash 0x0	 				../../output/images/uboot0.isi
r flash 0x1	 				../../output/images/items.itm
r flash 0x10	 			../../output/images/uboot1.isi
#r flash 0x2	 			../../output/images/ramdisk.img
#r flash 0x3  	 			../../output/images/uImage
#r flash 0x4  				uImage
#r flash 0x5  				../../output/images/rootfs.squashfs

	int	pcounter = 0;
	static int	print_counter = 6;
	int total_size = fr.size;

	if(print_counter < 6){
		printf("frame(size:%d): \n", fr.size);
		for(pcounter = 0;pcounter<fr.size;pcounter++){
			printf("%x,", ptr[pcounter]);
			if(pcounter && (((pcounter+1)%16)==0)){
				printf("\n");
			}
		}
		printf("\n");
	}
	char*	tmp_fr_ptr = NULL;
	while(total_size > 0){
		tmp_fr_ptr = (char*)fr.virt_addr;
		fr.size = aac_get_frame_len(tmp_fr_ptr);
		if(fr.size < 0){
			printf("frame decapsulate failed!\n");
			break;
		}
		if( this->PFrFifo->PushItem(&fr) < 0 ){
        	LOGGER_ERR("push audio error\n");
    	}

		total_size -= fr.size;
		tmp_fr_ptr += fr.size;
		fr.virt_addr = (void*)tmp_fr_ptr;

		if(print_counter < 6)
			printf("fr.size : %d\n", fr.size);
		if(total_size < 0){
			LOGGER_ERR("frame length error!\n");
		}
	}
    print_counter++;

------------------------------------------------------------------------------
07.10 周1 最新v1.9的dv代码，重现aac解码4002错误．
dｍｅｓｇ显示ｋｅｒｎｅｌ打印(简化掉了正常的sdio命令)：
mmc_host mmc0: Bus speed (slot 0) = 39600000Hz (slot req 39600000Hz, actual 39600000HZ div = 0)
mmc0: new high speed SDHC card at address 1234
mmcblk0: mmc0:1234 SA32G 29.3 GiB
[sdio]-send cmd -18,arg-0x00000000,cmdr-0x20002352
data error 2000
imap-mmc1 imap-mmc1.1: data FIFO error (status=00002000)
mmcblk0: error -5 transferring data, sector 0, nr 8, cmd response 0x900, card status 0xb00
mmcblk0: retrying using single block read
[sdio]-send cmd -17,arg-0x00000000,cmdr-0x20002351
data error 2000
sd卡初始化流程正常，cmd　18读取MBR失败，然后cmd 17读取MBR同样失败，都是data error 2000，这对应　Masked Start-bit error interrupt，表示接收start bit失败，看起来好像时序问题．
附完整初始化命令序列打印, 不支持cmd52/8/5，但sandisk class 10同样不支持，应该不影响正常初始化：
[sdio]-send cmd -52,arg-0x00000c00,cmdr-0x2000a174
cmd error 100
[sdio]-send cmd -52,arg-0x80000c08,cmdr-0x20002174
cmd error 100
[sdio]-send cmd -0,arg-0x00000000,cmdr-0x20002000
[sdio]-send cmd -8,arg-0x000001aa,cmdr-0x20002148
[sdio]-send cmd -5,arg-0x00000000,cmdr-0x20002045
cmd error 100
[sdio]-send cmd -5,arg-0x00000000,cmdr-0x20002045
cmd error 100
[sdio]-send cmd -5,arg-0x00000000,cmdr-0x20002045
cmd error 100
[sdio]-send cmd -5,arg-0x00000000,cmdr-0x20002045
cmd error 100
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x00000000,cmdr-0x20002069
--------------------------------[sdio]-send cmd -0,arg-0x00000000,cmdr-0x20002000		MMC_CMD_GO_IDLE_STATE
--------------------------------[sdio]-send cmd -8,arg-0x000001aa,cmdr-0x20002148		MMC_CMD_SEND_EXT_CSD
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069		ACMD41 电压检测和判断
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069		sd卡返回busy
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069
[sdio]-send cmd -55,arg-0x00000000,cmdr-0x20002177
[sdio]-send cmd -41,arg-0x40300000,cmdr-0x20002069		sd卡返回ready
--------------------------------[sdio]-send cmd -2,arg-0x00000000,cmdr-0x200021c2
--------------------------------[sdio]-send cmd -3,arg-0x00000000,cmdr-0x20002143
[sdio]-send cmd -9,arg-0x12340000,cmdr-0x200021c9			MMC_CMD_SEND_CSD
[sdio]-send cmd -7,arg-0x12340000,cmdr-0x20002147			MMC_CMD_SELECT_CARD
[sdio]-send cmd -55,arg-0x12340000,cmdr-0x20002177		MMC_CMD_APP_CMD
[sdio]-send cmd -51,arg-0x00000000,cmdr-0x20002373
[sdio]-send cmd -55,arg-0x12340000,cmdr-0x20002177
[sdio]-send cmd -13,arg-0x00000000,cmdr-0x2000234d		MMC_CMD_SEND_STATUS,　capability信息。
--------------------------------[sdio]-send cmd -6,arg-0x00fffff0,cmdr-0x20002346		MMC_CMD_SWITCH
--------------------------------[sdio]-send cmd -6,arg-0x80fffff1,cmdr-0x20002346		MMC_CMD_SWITCH
[sdio]-send cmd -55,arg-0x12340000,cmdr-0x20002177
--------------------------------[sdio]-send cmd -6,arg-0x00000002,cmdr-0x20002146		MMC_CMD_SWITCH
[sdio]-send cmd -18,arg-0x00000000,cmdr-0x20002352
data error 2000
[sdio]-send cmd -12,arg-0x00000000,cmdr-0x2000414c
[sdio]-send cmd -13,arg-0x12340000,cmdr-0x2000214d
[sdio]-send cmd -17,arg-0x00000000,cmdr-0x20002351
data error 2000
--------------------------------------------------------------------------------
07.07 周5 aac编解码基础知识的学习
--------------------------------------------------------------------------------
07.06 周4 audiobox完毕，开始aac编解码基础知识的学习．
--------------------------------------------------------------------------------
07.05 周3 开始阅读audiobox代码，预估明天能够整理完毕．
--------------------------------------------------------------------------------
07.04 周2昨晚失眠，早上7:40到公司．阅读audiobox文档，阅读eventhub部分代码，基本理清其机制．
--------------------------------------------------------------------------------
07.03 周1 调整fat32实现，增加struct address_space_operations fat_aops_da，代码逻辑更加清晰．开始阅读audiobox文档
--------------------------------------------------------------------------------
07.02 周7 加班，继续调整和测试fat32算法，主要分析mmu_private数据的逆向调用逻辑问题．
--------------------------------------------------------------------------------
07.01 周6 上午国际象棋考试，铩羽而归；下午休息，玩
--------------------------------------------------------------------------------
06.30 周5 测试mmap,跟中fat_bmap调用，发现没有关系．
linux kernel中，和tasklet相关的softirq有两项，HI_SOFTIRQ用于高优先级的tasklet，TASKLET_SOFTIRQ用于普通的tasklet
公司产品相关：
使用定码率而非变码率，是因为据说重力感应，有速度变化的时候才会录像，但这真的符合应用场景么？
为何测试和平台之间无法直接通过ｂｕｇ沟通呢？
报告bug，信息好简单．
make mrproper　命令会删除所有的编译生成文件、内核配置文件(.config文件)和各种备份文件，所以几乎只在第一次执行内核编译前才用这条命令。
make clean　命令则是用于删除大多数的编译生成文件，但是会保留内核的配置文件.config，还有足够的编译支持来建立扩展模块。所以你若只想删除前一次编译过程的残留数据，只需执行make clean命令。
总而言之，make mrproper删除的范围比make clean大，实际上，make mrproper在具体执行时第一步就是调用make clean

BU1相关：
GUI : MainWindowProc　是消息主要处理接口．
IPU.cpp             int IPU::Start()
ThreadCore.cpp      void ThreadCore::EnhancePriority(bool enhance){
--------------------------------------------------------------------------------
06.29 周4 测试o_direct，调整fat延迟分配策略机制．
--------------------------------------------------------------------------------
06.28 周3 调整fat延迟分配策略机制．
--------------------------------------------------------------------------------
06.27 周2 调整fat延迟分配策略机制．
--------------------------------------------------------------------------------
06.26 周1 测试计划和测试代码．
--------------------------------------------------------------------------------
06.25 周7 加班，优化inode.c中代码，测试
--------------------------------------------------------------------------------
06.24 周6 加班，优化inode.c中代码，测试
--------------------------------------------------------------------------------
06.23 周5 调整inode.c中代码，增加临界区保护多个page的写入和回写操作．
lock_page()和unlock_page()，小心两次lock导致死锁
--------------------------------------------------------------------------------
06.22 周4 跟踪抓图失败问题, arm_dma_alloc()函数强制在回写线程外回写page,而且顺序是乱序的
--------------------------------------------------------------------------------
06.21 周3 跟踪抓图失败问题
sysserver/spv_utils.c#play_audio()函数，sleep(2)并且禁止audio_put_channel(handle);后抓图正常，
--------------------------------------------------------------------------------
06.20 周2 请假，上午新华医院开药，下午家长会．
--------------------------------------------------------------------------------
06.19 周1
--------------------------------------------------------------------------------
06.16 周5
write_cache_pages 函数中增加确认page块分配的动作．
--------------------------------------------------------------------------------
06.15 周4 昨天下午5:25到今天8:30，１５个小时正常运行．
今天下班时，记得测试录像卡死问题．
先给tf360增加串口线，后盖很难开启，小刘给我一个带串口的tf360.
昨天测试居然使用的不是延迟分配的程序，晕．
--------------------------------------------------------------------------------
06.14 周3 trace机制就绪之后，迅速解决page和block不对齐导致的问题．tf360还，新的终端没有串口．
--------------------------------------------------------------------------------
06.13 周2 kernel 调试trace打印方式，已经搞定，以后可以用这种方式来搞．
发现调试内核问题时，打印信息会影响到正常执行，导致逻辑变化．控制测试条件减少打印信息，不方便还仍然偶尔有不一致的行为，导致逻辑分析混乱．所以只好先搞定trace显示方式的问题．
之前追踪mmc部分流程打印trace的时候，把关键的信息先集中保存在全局变量中，满足条件的时候一次性打印出来．这种延时打印的方式有效但使用不方便．现在想试试通用的方法．
尝试了几种方式：
１．延后定时调用dmesg显示内核trace
　　出错信息过多，printk的ring buffer很容易被overrun而导致关键信息丢失．
　　增加kernel　trace环形buffer大小，没有看到明显效果，估计错误信息太多，虽然可以手动注释掉部分错误，但不方便而且仍然无法保证信息不丢失，所以放弃；
２．在mmc_test进程中循环读取/proc/kmsg，过滤掉不关心的trace信息，然后显示的方式．
　　读取之后立刻显示，结果发现trace丢失；
　　然后，尝试先写入临时文件缓冲，延后一段时间集中显示临时文件信息，仍然出现trace丢失；　　　
　　最后，将mmc_test进程设定为实时，并取消isp线程的实时设定，trace信息正常显示．之前问题应该是因为mmc_test进程总是被抢占，无法及时读取kernel trace而导致.
当前使用第二个方式进行调试，没有发现有什么异常.
至于videobox audiobox app-launcher 这三个进程的打印，重定向到/dev/null，避免混杂显示的干扰．
--------------------------------------------------------------------------------
06.12 周1 重定向问题.
__mpage_writepage 函数中，对于一个page,之前处理只判断第一个bufhead的blocknr是否-1，如果一个Ｐａｇｅ只有第一个block分配了，那么后面的几个block就会出现逻辑不一致．解决这个问题之后，录像能够持续一段时间，３分钟可以录像２００m左右，结尾处理仍然有问题．
--------------------------------------------------------------------------------
06.11 周7  直接回家
--------------------------------------------------------------------------------
06.10 周6  syslog和trace信息重定向相关学习
--------------------------------------------------------------------------------
06.09 周5 fat32 延时分配策略调试
--------------------------------------------------------------------------------
06.08 周4 fat32 延时分配策略调试
--------------------------------------------------------------------------------
06.07 周3 fat32 延时分配策略，每次关机太烦拆掉电池，结果短路，修正后继续调试．
--------------------------------------------------------------------------------
06.06 周2 fat32 延时分配策略添加，录像直接卡死，调试．主要是尝试添加一些trace信息．printk输出级别错误，浪费了不少时间．
cat /proc/sys/kernel/printk 4 4 1 7 其中第一个“4”表示内核打印函数printk的打印级
--------------------------------------------------------------------------------
06.05 周1 今天应该结束fat32部分阅读工作．继续测试录像卡死问题．
--------------------------------------------------------------------------------
06.04 周7
--------------------------------------------------------------------------------
06.03 周6 上午拔牙，下午加班，疼的浑身无力早退．
热插拔sd卡一次，两小时只有没有异常；另外一次录像停止之后，fsck修正之后，正常录像，然后第二天，继续卡死．
--------------------------------------------------------------------------------
06.02 周5 下午会议，开始阅读fat部分代码
--------------------------------------------------------------------------------
06.01 周4
同时开启wifi和录像，测试和整理．
--------------------------------------------------------------------------------
05.31 周3
同时开启wifi和录像，spv_launcher.c文件中，int sysserver_proc()函数中SpvMessageLoop(g_launcher_handler);之前增加：
SendMsgToServer(MSG_CONFIG_CHANGED, (int)GETKEY(ID_SETUP_WIFI_MODE), (long)GETVALUE(STRING_DIRECT), TYPE_FROM_DEVICE);
最后自己从早期代码中，找到05.08/04.19 王辉代码修改掉, For TF360, when start wifi not record, and change the bitrate.
--------------------------------------------------------------------------------
05.27 周6 两天时间栽倒ＴＦ３６０的旧机型上了．
测试发现ｗｉｆｉ性能很差，资源占用50%以上，高鹏说没见过ｗｉｆｉ性能好过．去掉实时调度之后，问题消失，以为ｗｉｆｉ受实时调度影响比较大．

--------------------------------------------------------------------------------
05.26 周5
fat相关的改动, 在g_dev_qsdk目录.
关于系统进程调度的问题分析.
由于中间穿插了一些其他任务, 加上初期自己思路也有些不清晰, 任务延迟.

测试前后版本.
首先需要确定优先级调整前后CPU资源和内存资源的占用情况是否有明显的变化.

实现了一个测试模块, 实现top和htop的部分功能. 这样做的目的主要是:
1. 自定义统计方式, 可以自己选定测试开始结束时间, 宏观分析更方便;
2. 实现33ms(ISP中断)级别的资源统计, 尝试为系统优化和分析提供一些微观的视角.

应该是总结出一种方法或一个工具, 能够对系统CPU资源动态变化情况提供一个量化的衡量标准, 然后我们才可能评估当前系统是否存在明显问题, 是否能对其进行优化.
具体的来讲, 对系统调度分析的问题, 分成几个阶段进行. 第一阶段,
各种可能出现问题的地方, 不同的场景, 强化压力测试.

进程监控部分, 最好内核完成, 应用部分定制好需求, 时间到达之后取结果就好, 避开用户内核态之间频繁切换, 可以提高效率.
--------------------------------------------------------------------------------
05.25 周4 上午正式提交system API 文档,  继续系统资源监控, 否则本月目标管理无法完成了.
使用fseek代替每次open/close Proc文件, 资源占用减小一半.
大概33ms采样一次信息, 测试程序本身占用5%左右系统资源, 存在两个问题:
1. 采样时间点不准确
2. 用户内核态之间切换开销, 间接影响待测试对象的运行.
3. 使用proc文件系统, 效率有待提高.

应该在内核态提供支持, 直接使用原始tick统计数据.
--------------------------------------------------------------------------------
05.24 周3  全天system API 文档, 小郭几个相关api
--------------------------------------------------------------------------------
05.23 周2  上午系统资源监控, 下午system API 文档 , 专利相关问题, 5:30开始座谈会, 两个小时结束.  今天领导开始出差, 周五回来
--------------------------------------------------------------------------------
05.22 周1   系统资源监控, 怎么这么麻烦. 一些细节问题太浪费时间了.
--------------------------------------------------------------------------------
05.21 周7 继续系统资源监控的问题
修改 /kernel/arch/arm/Kconfig 文件, 找到 config HZ, 修改default 3000, 代码中HZ也调整到了3000, 成功.
进程tick个数统计有点问题, 最后发现
修改代码, 去掉写sd卡,看看sd占用了大概10%资源; 同样的方法, 确定一下wifi.
--------------------------------------------------------------------------------
05.20 周6 继续系统资源监控的问题
进程级别的打印, 100HZ没有问题了, 3000HZ修改但失败.
专利问题: jason zhao / 胡斌
--------------------------------------------------------------------------------
05.19 周5    丁总 测试 邮件
已经发邮件并和东俊初步讨论, 好像公司现在trace和测试不完整.
继续系统资源监控的问题
--------------------------------------------------------------------------------
05.18 周4  盛大花园小学家长会, 小朋友报到.
--------------------------------------------------------------------------------
05.17 周3  今天希望完成cpu性能测试代码, 主要进程部分.
--------------------------------------------------------------------------------
05.16 周2  cpu性能测试代码 下午会议
--------------------------------------------------------------------------------
05.15 周1  cpu性能测试
--------------------------------------------------------------------------------
05.14 周7 linux中断子系统.
--------------------------------------------------------------------------------
05.13 周6 上午舞蹈课, 下午乐高
--------------------------------------------------------------------------------
05.12 周5  apollo3音频测试 和 编译服务器的问题
关键字:  apollo3音频测试  audio测试 ip2906.c ldo 3.3v
编译apollo3_evb_ipc出问题, 换apollo3_evb
录制的voice.wav 头部特殊的信息, 需要去掉之后才能在pc上播放.
3段耳机插口, 用4段耳机,需要拔出来一段.
麦克风在板子上,不能通过耳机录音.
录音导出, 启动audacity程序,选择file->import->raw data, 格式为32bit 16000hz 双声道
使用audacity程序,保存以便其他软件播放
vim编辑二进制     %!xxd
--------------------------------------------------------------------------------
05.11 周4
上午,中断子系统
下午联系一下王辉, 然后看看源码中簇号为0可能对应什么情况,最好能够拿到出事的卡做重现的测试. 分析trace和相关代码.
int fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)
    fat_bmap_cluster
        fat_bmap
            fat__get_entry
            __fat_get_block
    fat_free
        fat_truncate_blocks
            fat_setattr
            fat_write_failed
            fat_evict_inode
    fat_calc_dir_size
        fat_fill_inode
        fat_read_root
    fat_chain_add
        fat_add_entries
        fat_add_cluster
/testing/configure.ac 中出现错误, watchdog/Makefile mmc/Makefile, 已经在最新的commit中修复. mmc_test 在 q3evb 工作异常, 因为胡乱mount的缘故. 大概2个小时才修复这个问题.
--------------------------------------------------------------------------------
05.10 周3
上午,完成fs-writeback文档的格式修改和上传
下午,完成述职报告(居然花了两个小时才完成,保存下来以后瞻仰): 然后查阅cpu资源统计方式.
自2017年2月20日加入盈方微平台软件部, 不知不觉试用期就到了尾声, 回顾过去的3个月, 感觉非常充实和紧凑, 个人知识结构和技能上都有很大的提升. 感谢盈方微这个平台,
感谢各位领导和同事予以我的方方面面的支持和帮助.

首先回顾一下期间主要工作内容吧.

进公司之后, 最初的工作任务是完成applo3项目几个模块的验证, 工作内容很简单, 最主要的收获是在过程中不断查阅相关信息和代码, 逐步的熟悉buildroot开发环境和公司软
件开发工具与流程.之后, 是解决了FAT32多个视频流文件同时写入SD卡速度慢的问题. 过程中深入学习了fat32/内存回写/块设备驱动/mmc驱动等几个重要内核和驱动模块, 对存
储系统基本的结构和流程有了清晰的理解, 最后采用延时分配簇的方法完成初步的性能优化. 与此同时, 对内存回写策略做了详细的测试和分析, 并针对tf360产品给出了优化建议.
这个过程中, 另一个重要的收获就是逐步总结和掌握内核学习分析的方法.　

我非常喜欢当前的工作内容和方向, 并愿意为之付出不懈的努力. 之前的工作经历中, 我个人尤其重视产品性能优化和提高产品稳定性, 并积极寻求改进. 现在的岗位进一步拓宽了
我的视野, 我愿意以饱满的工作热情投入工作中去.从工作素养方面讲, 我一直自觉遵守公司各项规章制度, 遵守员工守则. 有高度的责任感和良好的团队合作精神, 努力学习掌握
熟练应用岗位相关业务知识, 积极主动认真完成工作要求.

以上是我3个月试用期的总结，期待能予以转正融入盈方微这个大家庭, 与大家共同努力和进步.

新的任务:  system api接口 文档.
上传的回写参数帮助文档,需要重新格式化.
文档管理问题:  新API文件放在： \psdocs\qsdk\api_zh_dev
API：
1.     添加API或者数据类型请参照模板api.md & datatype.md，git路径psdocs\qsdk\api_zh\template
2.     除了【描述】，【相关主题】结束时需要有标点符号；其它，如表格内描述，列表等最后不需要标点符号
3.     新增API需要添加到SUMMARY.md中，再执行genlist.sh，此时会生成apilist.md。apilist.md不要手动修改。
4.     【依赖】项中，如果有多个.h或者库，需用空格分开。
文档添加头：
1.     请参照模板head_en.md，head_cn.md
2.     版本都从V0.1开始
3.     改结构，做删减，添加需要将版本增加0.1, 采用十进制。
4.     只针对提供给BU的guide文档，内部文档不做此要求。

psdocs/qsdk/api_zh_dev下的genlist.sh工具已经更新，用法是：
 ./genlist.sh SUMMARY.md apilist.md
注意：
     所有未更新的或者格式有错误的列表，都会在对应的条目标红；
     无法识别或者格式问题，程序会退出并显示错误行，请观察对应文件排查错误．

--------------------------------------------------------------------------------
05.09 周2
完成调整并上传 mmc_test 程序, 实现sd卡的速度测试.
测试发现, usleep的精度,只有3.3ms. 而且cmn-timer视乎不支持one-shot模式,会否因此而不能支持高精度timer呢?
--------------------------------------------------------------------------------
05.08 周1
cat /proc/loadavg可以看到当前系统的load
$ cat /proc/loadavg
0.01 0.02 0.05 2/317 26207
前面三个值分别对应系统当前1分钟、5分钟、15分钟内的平均load。load用于反映当前系统的负载情况，对于16核的系统，如果每个核上cpu利用率为30%，则在不存在uninterruptible进程的情况下，系统load应该维持在4.8左右。对16核系统，如果load维持在16左右，在不存在uninterrptible进程的情况下，意味着系统CPU几乎不存在空闲状态，利用率接近于100%。结合iowait、vmstat和loadavg可以分析出系统当前的整体负载，各部分负载分布情况。

--------------------------------------------------------------------------------
05.07 周7
cmn1_timer_test_case1()函数传递了1us参数,出现各种奇怪问题,调整到1ms.浪费了1个上午.
下午修补代码,上传,然后大概总结一下吧:
request_irq 对应 free_irq;  setup_irq 对应 remove_irq. 弄错了之后出现crash
由于内核中float类型的支持的问题, 使用了printk(KERN_ERR "delta:(%5d~%5d us) %6d, above_all:%2ld.%02ld %%\n", pctrl->delta_us[i], pctrl->delta_us[i+1],
            pctrl->cmn1_delta_counter[i], tmp_percent/100, tmp_percent%100); 来打印 tmp_percent, %02ld前面的0是必须的,否则看起来0.02%就成了 0.2%;
%% 用来打印 '%'
格式上,保持对齐很重要,不然看起来一团糟
还有就是内核编译器对long long的乘法不支持.浪费时间.
命名上,统一的命名视觉效果好. 全局变量多的话,用结构体.
ko的编译还没有搞清楚; 另外就是,
--------------------------------------------------------------------------------
05.06 周6 上午带儿子跳舞,下午盛大花园小学幼升小面试,下午2点进场,3点出来.
--------------------------------------------------------------------------------
05.05 周5
新的任务:  system api接口 文档.
git clean -f 清除掉 不需要的 untracked files

如何增加新的cmn timer 1文件:
1. cat /kernel/driver/infotm/common/watchdog/Kconfig
     menuconfig INFOTM_WDT
     //INFOTM_WDT用来确定是否包含本文件夹. 使能则/common/Makefile中CONFIG_INFOTM_WDT有效,watchdog文件夹就会被包含.
             bool "Infotm watchdog driver support"
             default n
          select WATCHDOG
             help
                  Infotm watchdog timer driver support. say yes ifneed
     if INFOTM_WDT
     config WDT_IMAPX   //确定本文件夹Makefile的编译选项,可以定义多个,配置选中不同的文件.
             tristate "iMAPx wdt driver"
             default n
          help
               wdt driver for iMAPx
     endif

2. cat /kernel/driver/infotm/common/watchdog/Makefile
     obj-$(CONFIG_WDT_IMAPX)  += imapx_wdt.o //条件选择编译文件
3. cat /kernel/driver/infotm/common/Kconfig
     menuconfig INFOTM_DRV_COMMON //普通的菜单目录层次
           tristate  "Infotm common drivers support"
               depends on INFOTM_SPECIAL
           help
                    Infotm common drivers  support
     if INFOTM_DRV_COMMON
     ...
     source "drivers/infotm/common/watchdog/Kconfig"
     source "drivers/infotm/common/timer/Kconfig"
     endif
4. cat /kernel/driver/infotm/common/Makefile
     ... //条件包含目录
     obj-$(CONFIG_INFOTM_WDT) += watchdog/
     obj-$(CONFIG_INFOTM_CMN1_TIMER) += timer/
     obj-y += pr_detect/      //无条件包含pr_detect目录
5. cat /kernel/driver/infotm/Kconfig
     menuconfig INFOTM_SPECIAL
          bool "InfoTM special files and drivers"
          default y
          select GENERIC_ALLOCATOR
          help
            InfoTM special files and drivers support

     if INFOTM_SPECIAL
     ...
     source "drivers/infotm/q3f/Kconfig"
     source "drivers/infotm/common/Kconfig"
     endif
6. cat /kernel/driver/infotm/Makefile
     ...
     obj-$(CONFIG_ARCH_Q3F)  += q3f/  //根据平台和产品配置
     obj-y     += common/   //无条件包含
--------------------------------------------------------------------------------
05.04 周4
测试结果:
定时1ms, 测试10分钟,注意到结束时间有5s偏差,估计是有很多tasklet没来得及处理
~~~~ cmn1_statistic show #0 Total:(600000) end at(1483258205, 497537)~~~~
delta:(50000~   -1 us)      2, above_all: 0.00 %
delta:(30000~50000 us)      0, above_all: 0.00 %
delta:(20000~30000 us)      0, above_all: 0.00 %
delta:(10000~20000 us)      0, above_all: 0.00 %
delta:( 5000~10000 us)      0, above_all: 0.00 %
delta:( 2000~ 5000 us)      1, above_all: 0.00 %
delta:( 1000~ 2000 us)      0, above_all: 0.00 %
delta:(  600~ 1000 us)      0, above_all: 0.00 %
delta:(  400~  600 us)      0, above_all: 0.00 %
delta:(  200~  400 us)      3, above_all: 0.00 %
delta:(  150~  200 us)    222, above_all: 0.03 %
delta:(  100~  150 us)   2730, above_all: 0.49 %
delta:(   80~  100 us)   2162, above_all: 0.85 %
delta:(   40~   80 us)  11032, above_all: 2.69 %
delta:(   20~   40 us)  17502, above_all: 5.60 %
~~~~ cmn1_statistic show #1 Total:(600000) end at(1483258210, 350597)~~~~
delta:(50000~   -1 us)      2, above_all: 0.00 %
delta:(30000~50000 us)      0, above_all: 0.00 %
delta:(20000~30000 us)      0, above_all: 0.00 %
delta:(10000~20000 us)      0, above_all: 0.00 %
delta:( 5000~10000 us)      0, above_all: 0.00 %
delta:( 2000~ 5000 us)    104, above_all: 0.01 %
delta:( 1000~ 2000 us)   3448, above_all: 0.59 %
delta:(  600~ 1000 us)   7563, above_all: 1.85 %
delta:(  400~  600 us)   4991, above_all: 2.68 %
delta:(  200~  400 us)   7783, above_all: 3.98 %
delta:(  150~  200 us)   2975, above_all: 4.47 %
delta:(  100~  150 us)   5333, above_all: 5.36 %
delta:(   80~  100 us)   2574, above_all: 5.79 %
delta:(   40~   80 us)  16854, above_all: 8.60 %
delta:(   20~   40 us)  73567, above_all:20.86 %

定时10ms, 测试10分钟
~~~~ cmn1_statistic show #0  Expect:(60000) Real:(60002) latest:(1483258201, 325844)~~~~
delta:(50000~   -1 us)      2, above_all: 0.00 %
delta:(30000~50000 us)      0, above_all: 0.00 %
delta:(20000~30000 us)      0, above_all: 0.00 %
delta:(10000~20000 us)      0, above_all: 0.00 %
delta:( 5000~10000 us)      1, above_all: 0.00 %
delta:( 2000~ 5000 us)      6, above_all: 0.01 %
delta:( 1000~ 2000 us)      9, above_all: 0.03 %
delta:(  600~ 1000 us)      0, above_all: 0.03 %
delta:(  400~  600 us)      0, above_all: 0.03 %
delta:(  200~  400 us)      0, above_all: 0.03 %
delta:(  150~  200 us)     23, above_all: 0.06 %
delta:(  100~  150 us)    174, above_all: 0.35 %
delta:(   80~  100 us)    235, above_all: 0.75 %
delta:(   40~   80 us)   1000, above_all: 2.41 %
delta:(   20~   40 us)   2283, above_all: 6.22 %
~~~~ cmn1_statistic show #1  Expect:(60000) Real:(60001) latest:(1483258201, 335863)~~~~
delta:(50000~   -1 us)      2, above_all: 0.00 %
delta:(30000~50000 us)      0, above_all: 0.00 %
delta:(20000~30000 us)      0, above_all: 0.00 %
delta:(10000~20000 us)      0, above_all: 0.00 %
delta:( 5000~10000 us)      3, above_all: 0.00 %
delta:( 2000~ 5000 us)    991, above_all: 1.66 %
delta:( 1000~ 2000 us)    728, above_all: 2.87 %
delta:(  600~ 1000 us)    611, above_all: 3.89 %
delta:(  400~  600 us)    419, above_all: 4.59 %
delta:(  200~  400 us)    603, above_all: 5.59 %
delta:(  150~  200 us)    269, above_all: 6.04 %
delta:(  100~  150 us)    324, above_all: 6.58 %
delta:(   80~  100 us)    229, above_all: 6.96 %
delta:(   40~   80 us)   2181, above_all:10.60 %
delta:(   20~   40 us)  18093, above_all:40.75 %

static void cmn1_tasklet_func0(unsigned long para)
{
    static int  cmn1_int_counter = 0;
    static struct timeval *cmn1_time_history = NULL;

    if(cmn1_int_counter == 0){
        cmn1_time_history = (struct timeval *)kzalloc(1024*sizeof(struct timeval), GFP_KERNEL);
        if(cmn1_time_history == NULL){
            writel(0, cmn1_timer_base + TIMER_CTRL);
            return;
        }
    }

    do_gettimeofday(&cmn1_time_history[cmn1_int_counter]);
    if(cmn1_int_counter >= 1000){
        cmn1_disable_counter();

        int i;
        printk(KERN_DEBUG "~~~~cmn1_timer_reload:%ld~~~~\n",
            cmn1_timer_reload);
        for(i=0;i<1000;i++){
            printk(KERN_DEBUG "seq:%4d :%3ld, %6ld\n", i,
                cmn1_time_history[i].tv_sec%1000, cmn1_time_history[i].tv_usec);
        }

        kfree(cmn1_time_history);
    }
    cmn1_int_counter++;
}
--------------------------------------------------------------------------------
05.03 周3
需求和功能定义:
1. 客户注册tasklet函数方式实现功能;
2. 客户可以注册多个周期性的timer
3. 支持多个单次timer吗,暂时不考虑
cortex-a5不支持 long long 类型的除法.
--------------------------------------------------------------------------------
05.02 周2

假期后第一天了,时间子系统,结束,然后开始客户任务.
cmn1-timer中断功能, 在用户空间和驱动层接口; 明天,开启一个内核线程,延时5s, 等启动流程结束之后再开始测试, 并完成其他相关测试 !!!!
--------------------------------------------------------------------------------
05.01 周1 加班,时间子系统
--------------------------------------------------------------------------------
04.30 周7 加班,时间子系统,心烦,效率很低
--------------------------------------------------------------------------------
04.29 周6 上午带小熊跳舞,中午睡觉2小时,然后带小熊去乐高
--------------------------------------------------------------------------------
04.28 周5
上午整理之前的一些信息,提交fat32双文件写结果. 并思考进程调度的任务如何完成.
下午了解时间管理的内容.
--------------------------------------------------------------------------------
04.27 周4
上午请假看牙,预约了8.14上午,需要保证1万资金,保证身体状况良好;
下午,解决了fat32延时分配策略的问题,在不同的sd卡上通过性能测试.
--------------------------------------------------------------------------------
04.26 周3
预分配的方式看起来遥遥无期, 有些机制性的困惑,暂时放弃;
开始延时分配策略的调试,
--------------------------------------------------------------------------------
04.25 周2
尝试追踪回写的流程,期望通过不同文件的数据在回写队列中重新排序来提高效率,但付老师提醒实际机制可能不是想象的那样,而且这部分确实太不熟悉,trace打印不知道如何才能得到足够的信息,最后只能放弃.
--------------------------------------------------------------------------------
04.24 周1
sum:10014,null:378,err:9,dma:1035,cnt(0,0,8973,1035,0,0)
cmd(0,3) cmd(2,1) cmd(3,2) cmd(5,6) cmd(6,3) cmd(7,2) cmd(8,3) cmd(9,1)
cmd(13,6802)   SD_APP_SD_STATUS 读取SD卡状态寄存器
cmd(17,3)      读取扇区命令
cmd(18,633)    读取多个扇区直到发送停止命令
cmd(24,4)
cmd(25,391)    写多个扇区命令
cmd(41,4) cmd(51,1) cmd(52,83)      cmd(55,7)
1. 我关注的应该是,连续写入4m,总共花了多少时间.
2. 把小的数据块也计算进去., 计算和打印差值, 这样可以保存更多的中间数据.
3. 24和25命令, 可能也需要关心夹杂的命令, 每个数据请求的开始时间, 查询状态时间, 数据dma传送完毕, 数据长度, 一次连续4m数据的时间,等等.
--------------------------------------------------------------------------------
04.20 周4/5/6
通过增加sleep减少cmd 13的调用次数,从而减少sdio中断的方法是可行的,但是需要付出代价,128k的包发送时间从8ms增加到9ms,速度降低10%. 但是中断个数降低到原有的1/3,以后继续尝试更有效的机制.
mmc模块,增加打印信息,跟踪request发送的过程,了解发送流程,理解代码实现.
--------------------------------------------------------------------------------
04.19 周三
Q3F_EVB回写时间配置影响测试
目标：测试不同(dirty_writeback_centisecs,dirty_expire_centisecs)配置对sdio中断次数的影响。
系统缺省为(500, 3000), 对应回写时间(5s,30s)；分支dev_qsdk_dv为(50,50)，对应(0.5s,0.5s)
测试方式： 不同参数配置下，基于Q3f_evb，测试程序控制写入文件速度在1mbyte/s左右，写入文件１２８ｍ
表格：
配置　       write()块大小  写入速度　　文件总长度　　  中断次数
(500,3000)   32k             1024k/s    128m     53000
(500,3000)   64k             1024k/s    128m     48000
(50,50)      32k             1024k/s    128m     183000
(50,50)      1024k           1024k/s    128m     153000
可以看到，回写时间越小，中断次数越多。当前dev_qsdk_dv应该用的是(50,50)的参数，即使使用了1M缓冲也比(500,3000)下32k缓冲中断次数多1倍。
强制0.5s回写大幅度增加中断次数，也导致回写优化机制基本失效。
上面的测试，可以在tf360上运行一下，看看结果如何。
--------------------------------------------------------------------------------
04.18 周二
打印了每次超时和阈值回写写入sd卡多少page，再把bdi的worklist也打印出来，
Writeback机制的好处总结起来主要是两点：
    加快write()的响应速度。因为media的读写相对于内存访问是较慢的。如果每个write()都访问media，势必很慢。将较慢的media访问交给writeback thread，而write()本身的thread里只在内存里操作数据，将数据交到writeback queue即返回。
    便于合并和排序 (merge and sort) 多个write，merge是将多个少量数据的write合并成几个大量数据的write，减少访问media的次数；sort是将无序的write按照其访问media上的block的顺序排序，减少磁头在media上的移动距离。
--------------------------------------------------------------------------------
04.17 周一
--------------------------------------------------------------------------------
04.16 周日 把worklist也打印出来
--------------------------------------------------------------------------------
04.15 周六 需要搞清楚回写的优先级
回写线程应该不会有很高的优先级。
--------------------------------------------------------------------------------
一些杂乱的想法
停止录像的时候差不多需要4s回写完毕，wifi预览10秒以上才会看到一次图像变更(应该是收到了一个完整的i帧吧)；改成(500,3000)和1024k，明显改善很多。
怎么感觉1024k的buffer是在帮忙抢占资源啊。500ms的回写，也是在帮忙抢占
ｗｉｆｉ，ＳＤ卡，音视频等等，竞争ＣＰＵ，内存，ＩＯ，ＤＭＡ，中断本身。dma现在有几个，彼此是分开的吗？
需要结合几个问题一起研究１.大图片短时写入ｓｄ卡问题，２.缩小回写缓存问题，３.１ｍ缓存非Ｏ_ＤＩＲＥＣＴ写入问题，４.多文件写入慢
提高isp线程和H1 thread优先级，之前导致几个问题:1.audio丢帧（raw数据处理不及时ｂｕｇ） 2. videobox阻塞卡死（同样提高优先级）
３．recorder做mux的时候，会来不及，导致前面buffer堵住。来不及的原因是因为写SD卡，只做mux不写SD卡没有问题。准备对mux写SD卡的行为做优化
总资源有限时，每个线程不能直接抢一部分自己用，这回恶化整个环境。所以，图片的写入和视频流的写入，需要码率均衡实现。完全优先图片的话，导致。。同样，如果优先ｗｉｆｉ的，那么
wifi中断是165 dw_mci
--------------------------------------------------------------------------------
倪高鹏　ranson.ni@infotm.com 设备密码 admin888 还是admin88
提高vplay优先级	http://gerrit.in.infotm.com/#/c/9619/
问题背景源于RM#1471	上code记录为 http://gerrit.in.infotm.com/#/c/9455/
永滨回件:
./app-launcher/sysserver/hwlib/camera_spv.c
int take_picture_interpolate(char *filename, int width, int height)

老分支获取方法：
repo init -u ssh://user.name@gerrit.in.infotm.com:29418/manifest/buildroot -b dev_Q3_carDv_mc
repo sync -c
repo start --all dev_Q3_carDv_mc
实验平台的代码获取：
repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b dev_qsdk_dv
repo sync -c
repo start --all dev_qsdk_dv
--------------------------------------------------------------------------------
evb测试命令
echo 50 > /proc/sys/vm/dirty_expire_centisecs
echo 50 > /proc/sys/vm/dirty_writeback_centisecs
echo 500 > /proc/sys/vm/dirty_writeback_centisecs
echo 3000 > /proc/sys/vm/dirty_expire_centisecs
cat /proc/sys/vm/dirty_writeback_centisecs
cat /proc/sys/vm/dirty_expire_centisecs
/usr/bin/wdt_test frame -o /mnt/multi -b 32 -g 0 -t 128 -n 1
/usr/bin/wdt_test frame -o /mnt/multi -b 1024 -g 0 -t 128 -n 1
--------------------------------------------------------------------------------
04.14 周五 tf360设备使用
wifi预览可以使用低码率或者低分辨率吗？
链接TF360,需要设备开启wifi，手机下载 dev_qsdk/system/app-launcher/app/DV/bin/DV.apk，通过软件链接设备的wifi失败，然后改用手机设置链接wifi成功，看到视频流。
开启wifi预览，即使不打开录像功能，wifi预览卡顿也很严重。
设备按键：1.拍照模式下拍照，预览模式下打开关闭录像; 2.长按关机，切换预览拍照设置模式; 3.开启wifi,菜单模式上键4.菜单模式下键
帧率测试过程：1. 设备运行中 2.切换到预览模式 3.多等几秒后关机 4. 检查然后删除sd卡上所有录像 5.重新插卡上电开机，等wifi预览有视频6.切换录像6分钟7.切换到预览。
配置参数在初始化的时候才能改变，大量写入测试之后改变配置，结果很不稳定。所以每次更换配置需要重启
链接不上，重启wifi链接，不行重启应用程序，再不行重启设备和重启手机。
--------------------------------------------------------------------------------
04.13 周四
修改代码减小buffer到4k，编译车载工程，录像然后安装mediainfo解析，没有发现丢帧问题。
明天打开wifi尝试重现问题，然后再改。
--------------------------------------------------------------------------------
04.12 周三
--------------------------------------------------------------------------------
04.11 周二 计划整理完mmc下层代码，理清数据结构和函数，尤其是queue相关的部分

--------------------------------------------------------------------------------
04.10 周一 本周计划：阅读整理完毕内存映射之外的所有代码。
今天测试,　多个线程，线程中创建文件，写入数据，同步然后关闭文件，所有write()进入临界区.
型号 单路１２８ 异步双路１２８ 同步双路１２８ 异步８路６４ 同步８路６４
Sandisk class4
Sandisk class10 8.5 7.0 5.4
OV 6
kingston 10
PNY 10 9.8
Netac 6
transcend 10
maxell 4
结果和想象有偏差，多线程临界区没有影响，最有效的优化就是６４ｋ对齐写入。应该增加单线程写入多文件的测试项目，这样可以知道元数据优化是否有作用。但是这之前应该增加足够的trace信息支持，mmc层和fat32层。
--------------------------------------------------------------------------------
04.09 周日 笔记本ubuntu双系统安装完毕
部分文件导出到有道云 增加sublime中文输入支持和evernote支持 查阅适合自己的笔记方式
--------------------------------------------------------------------------------
04.08 周六　带孩子，上午跳街舞，下午长风公园　
--------------------------------------------------------------------------------
04.07 周五
几个之前问题：
     evb无法检测到部分sd卡，因为卡槽被sandisk撑大了
     evb大批量写入ｓｄ卡内存ｐａｇｅ问题ｃｒａｓｈ，估计是因为apollo3板子ddr问题。
     /proc/sys/vm/dirty_*文件，回写机制。
     测试，创建一个很大的文件，然后直接写入，因为不需要改变大小和床架簇，速度应该和正常的设备访问差不都，可以避开fs的影响。
--------------------------------------------------------------------------------
04.06 周四  ｍｍｃ部分驱动，最后应该把主要数据结构弄清楚
--------------------------------------------------------------------------------
04.05 周三  上午，继续阅读代码。 下午周会时间比较长
根据当前write的大小，确定分配多少个簇，这种方式，在有目标的测试的情况下，应该可以做到性能最优化吧?哪怕没有实际内存，簇已经分配好了。另外，分配连续簇也需要考虑到内存ｃａｃｈｅ有限情况下，回写可能很多。　修改策略，在多种情况下分析
脚本　　./q3fevb_va_ipc/system/root/.videobox/path.json　　
ｉｓｐ的应用情况，需要了解一下如何搭建，如何修改和使用。
一种场景：连续抓拍多张图片，要求拍完１ｓ内可以拔卡，这时候回写参数需要配置：永久或者临时改为１ｓ回写，分析和测试对系统的影响。
回写策略，可以参考媒体组代码增加场景测试用例
--------------------------------------------------------------------------------
04.02 周日
内存测试已经测试完毕，请确认测试结果。

测试方法：
echo x > /proc/sys/vm/dirty_background_ratio
echo 2x > /proc/sys/vm/dirty_ratio
尝试了x=1,2,3,4,6,8,9,10这几种配置。

每种配置下６４次创建文件写入１２８ｍ数据再删除文件，总数据量８Ｇ。单个数据块保持６４ｋ。记录中断次数和时间信息。

测试结果(写入８Ｇ数据)：
配置 持续时间(s)　中断次数 平均速度(M/s)
(1,2) 1402 12841863 5.84
(2,4) 1193 7130090 6.87
(3,6) 1189 6646450 6.89
(4,8) 1169 6554162 7.01
(6,12) 1184 6169589 6.92
(7,14) 1173 5927927 6.98
(8,16) 1155 5358070 7.09
(9,18) 1121 6391066 7.31
(10,20) 1113 6529605 7.36

(1,2)配置中断次数过多，且写速度大幅降低，绝对不可取。(3,6)或者(4,8)配置性价比比较高，节省内存，性能也比较客观。

--------------------------------------------------------------------------------
04.01 周六
dw_mci_write_data_pio 函数中 sg_miter_next(sg_miter)　传递的什么数据，应该是连续的数据，长度估计没有什么特别的限制吧
是否应该在mmc层驱动打印命令，参数，数据长度信息 struct mmc_request *mrq;struct mmc_command *cmd;struct mmc_data *data;
注册到存储系统的是　struct mmc_host，上层看到的是mmc card, 交互是通过LBA和数据。
static const struct mmc_host_ops dw_mci_ops = {　//对象struct mmc_host *mmc作为主要句柄参数
     .request = dw_mci_request,
     .pre_req = dw_mci_pre_req,
     .post_req = dw_mci_post_req,
     .set_ios = dw_mci_set_ios,
     .get_ro = dw_mci_get_ro,
     .get_cd = dw_mci_get_cd,
     .enable_sdio_irq = dw_mci_enable_sdio_irq,
};
struct platform_device *pdev和host实际是一体的吧；slot和mmc好像也是一体的，mmc有实际的ops。
platform_dev host slot mmc_host 这4层架构
mci_send_cmd(slot,SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);　命令被抽象在slot层次，这是面对mmc层的
host层应该只是管理内存中断寄存器等资源而已。
--------------------------------------------------------------------------------
03.31  周五
内存ｍａｌｌｏｃ失败的问题，因为文件系统的ｃａｃｈｅ过多
     echo 1 > /proc/sys/vm/dirty_background_ratio
     echo 2 > /proc/sys/vm/dirty_ratio

undefined reference to `pthread_create` 错误:
     gcc wdt_test.c -o thread -lpthread


中断发生个数统计　 /proc/interrupts
164: 285356 GIC dw-mci
165: 87 GIC dw-mci

struct msdos_sb_info {
struct inode *fat_inode;
     MSDOS_I(fat_inode)->i_pos = 0;
struct inode *fsinfo_inode;
     fsinfo_inode->i_ino = MSDOS_FSINFO_INO;
sb->s_root
     root_inode = new_inode(sb);
     root_inode->i_ino = MSDOS_ROOT_INO;
     error = fat_read_root(root_inode);
          MSDOS_I(inode)->i_pos = MSDOS_ROOT_INO;
     fat_attach(root_inode, 0);
          MSDOS_I(inode)->i_pos = 0;

--------------------------------------------------------------------------------
03.30  周四
回写算法中，单个文件可能无法享受到最好待遇，分摊到两个文件中，反而性能提升。
写入整体速度突然降低了一半，是否是写满了，现在有额外的擦除动作？　插拔了一次ｓｄ卡，好了。

--------------------------------------------------------------------------------
03.29  周三
继续测试：仍然避开文件系统的影响，今天首先测试读取性能，然后测试双线程写入，然后

int remove(char * filename);     删除指定文件
--------------------------------------------------------------------------------
03.28  周二
两级分配策略：不实际占用，而是预留大量簇，其他文件优先分配其他未预留簇。需要回写算法保证按照擦除块刷新才能保证效率。
     预留大量簇比如５１２ｋ，分配６４ｋ
     如果是一堆小文件慢速同步写入，这么处理的效率完全无法保证，需要交叉保存，那我们就应该分开数据和元数据的同步。
考虑碎片问题，时间次序和物理扇区地址最好保持线性管理。老的锁定文件，应该集中在一起管理。这，应该是上层的逻辑。
考虑覆盖和碎片问题，如果一个擦除块被两个文件使用，那么必然导致碎片越来越多。
下午做了大量测试：
几个之后看看的函数：
     write_dirty_buffer(bhs[i], WRITE);
     wait_on_buffer(bhs[i]);
--------------------------------------------------------------------------------
03.27  周一
上午ｒｅｖｉｅｗ之前ｆａｔ３２相关笔记，整理思路。
下午ｔｅａｍ周会，讨论ｆａｔ３２优化，两个半小时。发现自己对ＳＤ卡ｆｔｌ的理解是错误的。继续看看代码。
peter说lseek会导致大量中间数据内容的写入
延后分配方式，可以自动决定分配多少cluster,缺点是，如果不是区对齐的写入会导致碎片。
--------------------------------------------------------------------------------
03.25/26  周六 周日 全天阅读fat32源码
--------------------------------------------------------------------------------
03.24  周五 菊花茶 耳机
上午：查阅NAND基本工作机制，也看了一些SSD相关的内容；cache.c文件
下午：填写职级申请大半小时，继续学习fat32源码
--------------------------------------------------------------------------------
03.23  周四　菊花茶 耳机
上午新员工培训，学习fat32源码
--------------------------------------------------------------------------------
03.22  周三　内核学习文件系统
--------------------------------------------------------------------------------
03.21  周二　文件系统
--------------------------------------------------------------------------------
03.20  周一  块设备驱动　文件系统 页高速缓存
--------------------------------------------------------------------------------
03.19   周日  复习ＭＭＣ底层驱动部分　块设备驱动程序
--------------------------------------------------------------------------------
03.18   周六  复习ＭＭＣ底层驱动部　
--------------------------------------------------------------------------------
03.17   周五
完善ｓｄ卡测试程序；读写测试８个型号的tf卡
        写入速度    读取速度
sandisk 4    3.937 M        16.786 M
sandisk 10    8.462 M        17.355 M
OV 6         5.85 M        17.066 M
kingston 10    8.462 M        16.254 M
PNY 10        9.752 M        16.254 M
Netac 6        5.5 M        8.827 M
transcend 10    7.313 M        16.254 M
maxell 4    4.413 M        8.752 M
没有成功实现auto_delayline : yes 0x20 0x10 all,　之前不能mount TF卡，会出错
--------------------------------------------------------------------------------
03.16   周四
上午ｄｏｎｇｊｕｎ确认IP2906没有上电，修改驱动之后，录音和播放ｏｋ。下午，使用ｄｄ测试ｓｄ卡读写速度；烧录版本经常烧录不上，
test_qsdk 编译va版本 dev_qsdk编译va_ipc版本
SD卡速度测试几个问题：
１．写入大量数据的时候出现错误: Unable to handle kernel paging request at virtual address cf63200，难道是因为ｐａｇｅ内存用尽的缘故，需要增加流量控制的代码。　items.itm 中dram增加到１２８Ｍ看能否解决问题。
２．写３２Ｍ数据，４ｋ的buffer需要４０ｓ，１Ｍ的buffer第一次９ｓ之后４ｓ，创建文件不需要什么时间，应该是因为ｆａｔ表影响很大。时间精度需要提高，或者提高容量。上午ｄｄ测试的时候，４００Ｍ需要４５ｓ，这是不用文件系统的情况。
--------------------------------------------------------------------------------
03.15   周三
apllo3验证wdt/cmntimer/uart/蓝牙
上午看ＤＷ ＭＭＣ部分的驱动和验证板子，下午和晚上验证ａｂｃｔｒｌ占用了大量时间
--------------------------------------------------------------------------------
03.14   周二 文件系统文档学习
编译运行q3fevb_va_ipc工程，d304main &    d304bt   手机检测到QiwoIpc蓝牙和Ａ８,但是配对失败。需要获取相关支持。
继续学习文件系统
--------------------------------------------------------------------------------
03.1３   周一 MMC驱动中止 文件系统文档学习
尝试，能否先重现要追踪的问题。
--------------------------------------------------------------------------------
03.12   周日 加班
本周学习周报：
     １. watchdog验证，之前的实现过于死板，模仿ａｂｃｔｒｌ程序改写，支持参数列表
     ２． ＧＩＴ学习，因为担心一知半解导致破坏性操作，比较系统的学习了ＧＩＴ，并基于自己建立的本地和远程仓库做了练习
     ３． wdt,uart,rtc驱动整理
--------------------------------------------------------------------------------
03.11   周六 国际象棋考级 3.5分了，不肯和棋，输掉
--------------------------------------------------------------------------------
03.10  周五 uart驱动
ｕａｒｔ驱动，我们好像使用的是ｃｏｎｓｏｌｅ模式？相关的代码基本瞄了一遍。
差不多也需要了解一下电路图了。
--------------------------------------------------------------------------------
03.09 周四 uart 　下午儿子参加星河湾面试
上午继续了解gerrit repo git, 新建立wdt_test branch, 然后ｍｅｒｇｅ到dev_qsdk ｂｒａｎch(git pull), 结果出现额外的merge ｃｏｍｍｉｔ, 继续，git checkout xxxx, 然后git cherry-pick <commit id>, 现在一切正常了，使用repo upload system上传代码；　
下午，开始学习uart驱动，基本上
--------------------------------------------------------------------------------
03.08 周三 继续学习ＧＩＴ
上午，继续学习ＧＩＴ，主要是远程库相关，下午继续。下午３：３０～４：４５　ＥＶＭ培训
--------------------------------------------------------------------------------
03.07 周二 蓝牙
上午完成ｗａｔｃｈｄｏｇ验证程序，下午学习ＧＩＴ准备提交代码。
--------------------------------------------------------------------------------
03.06 周一 本周计划： 提高驱动基础熟悉程度
建伟提到蓝牙模块使用蓝牙耳机测试；　
上午,周会，更新代码后编译出现问题，QSDK camera在使用上与之前有比较大的变化，下载最新代码后运行./tools/setproduct.sh 选择product 后，还要选择product使用的sensor配置,尝试选择了0，EVB能正常工作。 http://platsoft.in.infotm.com/#!qsdk/docs/isp/sensor/new_sensor.md
下午,Tｅａｍ例会, watchdog增加设置超时时间参数
--------------------------------------------------------------------------------
03.05 周日 停止代码 读书
linux驱动开发入门与实战书中Linux设备模型章节。
--------------------------------------------------------------------------------
03.04 周六 领卡
--------------------------------------------------------------------------------
03.03 周五 REPO GIT GERRIT 上传代码
Linux驱动模型学习，不知道今天能否正常结束；请教一下下一步工作安排；
报告： 1. 基本计划，学习思路 2. 当前进度情况
本周，watchdog验证程序完成之后，先学习和timer_cmn和相关的linux基础内容，然后watchdog驱动几个相关文件，然后开始uart相关的几个文件，结果遇到一些。。的东西，所以开始看linux设备模型和基本的io mem irq 同步 char设备等，
避开块设备驱动 USB 网络驱动 PCI等。
!!!!!!!!watchdog驱动，涉及到platform/misc/class/cdev， 有些步骤感觉没有什么用处，搞清楚模型？
     可以尝试删除cdev相关的定义，看watchdog能否正常工作。
--------------------------------------------------------------------------------
03.02 timer_cmn驱动 timer_gtm
暂停uart部分，阅读timer文档和3个timer的代码。本周应该结束
irq回调函数    typedef irqreturn_t (*irq_handler_t)(int, void *);

--------------------------------------------------------------------------------
03.01 已经完成wdt测试代码
阅读手册uart部分;涉及到tty模块，感觉比较复杂，推进比较慢。
--------------------------------------------------------------------------------
02.28 基本完成wdt驱动阅读
很多模块都好使用 平台设备模型 ， device.c文件中定义struct platform_device : gpio mmc pmu sensor cam spi mac memalloc pwm crypto iic rtc wtd adc bat wifi lcd backlight emif leds ids bcm6212

需要优先学习的模块：     UART 同步串口 蓝牙 CMN_TIMER WATCHDOG SPI EMMC/SD/SDIO 中断 DMA基本了解 ADC(有汇编代码) RTC
wdt主要文件：  imapx_wdt_chip.c watchdog_core.c watchdog_dev.c
建立工程文件，包含下列内容:
     kernel/drivers/infotm/common/*
     kernel/drivers/infotm/q3f/*
     kernel/arch/arm/mach_q3f/*
     kernel/drivers/watchdog/watchdog_core.c
     kernel/drivers/watchdog/watchdog_dev.c
     kernel/include/linux/*.h，暂时不需要包含子目录下的头文件。
     串口驱动文件： drivers/tty/serial/amba-pl011.c， drivers/tty/serial/serial_core.c
             uapi/asm-generic/termios.h uapi/asm-generic/termbits.h
     还有头文件      linux/amba/serial.h  kernel/arch/arm/include/asm/hardware/arm_timer.h
遍历开发包部分目录，更清楚代码构造
     增加　q3fevb_va/system/etc/init.d/S904verifyc　自动启动wdt_test程序
--------------------------------------------------------------------------------
02.27 低效率
编译，config，低效率
--------------------------------------------------------------------------------
02.24 周五 需要大概去定季度和月度工作计划了
     今天需要提交周报:      ftp://192.168.0.5/     格式为ownCloud/Shared/Templates/平台软件部周报_XXX_20160527.xlsx
当日计划： 建立makefile编译模块， 阅读watchdog cmntimer uart 部分的文档和代码，确认电路设计，请教一下buildroot下app如何集成到rootfs中，然后在EVB上测试验证程序。
基于hello.c生成了基本的makefile

！ 分配的appolo3 任务：
     cmntimer     完成驱动，在Linux框架下提供软件接口，使其功能为系统正常使用
         /arch/arm/.../timer-cmn.c
     uart               完成控制器驱动，调通DEBUG，至少调通一款UART蓝牙设备
     watchdog    完成驱动，在Linux框架下提供软件接口，实现CPU软重启功能
         /kernel/drivers/watchdog/wdt.c

watchdog验证任务
/work/dev_qsdk/system/qlibsys文件夹，system.c文件中有watchdog相关的内容，使用q3fevb_va工程在当前evb上测试验证通过，然后appolo3验证应该在apollo3_fpga工程的基础上完成
如何配置添加这个程序么？或者需要别的方式。

--------------------------------------------------------------------------------
02.23 周四 岳父今天到上海，要早点到家
今天计划： 启动 烧录，调试，重要开发方式的演练，source insight配置好准备代码阅读。
昨天烧录再次失败，因为setproduct.sh应该是q3fevb_va或者q3fevb_va_ipc，而不是q3evb_v1.1，make clean, make, ./tools/setproduct.sh q3fevb_va, ./mkburn.sh /dev/sdb, 然后第一次烧录居然失败了，不知道什么原因，再次使用启动卡OK，然后再次使用烧录卡，成功。很奇怪，但是不知道中间犯了什么错误。
但是仍然有一个问题： mkburn.sh 产生的烧录卡，烧录之后重启，打印Rebooting in 5 seconds..，然后停止，因为找不到rootfs分区
调试方式： 基本不会用到NFS方式，似乎也没分配多余的网口给我们调试。
生成Makefile: 以前总是使用现成的，汗！
湿疹问题： 开空调需要注意空气湿度，但是使用加湿器又要小心湿度过高。 我家儿子去三亚一个星期，没有任何问题，去北方城市，立刻发作。   比较有判断的几篇文章http://health.sohu.com/s2011/piyan/    http://health.sohu.com/20110416/n305916902_9.shtml
--------------------------------------------------------------------------------
02.22 发现很需要咖啡提神 继续阅读文档
编译qsdk问题： 终于解决了。重新安装了git repo等，编译成功，不确定之前到底是什么情况，anyway，可以继续下一步的工作了。
配置minicom保存log文件;
编译并烧录TF卡，出现 Card did not respond to voltage select! 实际上是自己弄错了，使用gendisk.sh产生的是启动卡，mkburn.sh产生的才是烧录卡。重新产生烧录卡，烧录失败，卡在--显示上，光标闪烁了几下之后，停止闪烁。
环境搭建过程中的问题：
由于在 repo init -u ssh://eric.yun@gerrit.in.infotm.com:29418/manifest/buildroot -b dev_qsdk 前错误的添加sudo，导致之后的repo sync出现permission的错误，删除掉相关的信息和文件之后，问题解决;
编译过程出现messed up permission问题，不清楚问题，删除所有repo信息后重新安装并编译，问题没有解决;第二天过来之后原有问题消失！不知道是否是过程中有sudo或者其他因素的影响. 接着编译出现 fatal error: curses.h: 没有那个文件或目录，网上搜索，按照推荐 sudo apt-get install libncurses5-dev，没有效果; 重启PC，repo sync, 重新设置项目(不确定之前项目是那个了)，make clean, make, OK!不知道是什么环节出现的问题并且如何消失的。
下面过程也许会有帮助
sudo apt-get install bison flex texinfo autoconf automake wget dos2unix libtool
gettext make automake autoconf gcc g++ python curl lzop perl build-essential
libncurses5 libssl-dev lib32ncurses5 lib32z1 zlib1g-dev u-boot-tools
2. sudo dpkg --add-architecture i386   (32bit support)
sudo apt-get install lib32stdc++6
sudo apt-get install lib32z1
sudo apt-get install lib32ncurses5
sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386
3. sudo apt-get install p7zip-full p7zip-rar squashfs-tools micro-httpd
subversion zip unzip git tree libncurses5-dev bzip2 lib32z1 lib32gcc1

编译时间大约11分钟.
./tools/release.sh 产生一个新的qsdk_170222文件夹，平台软件部门不需要使用。
--------------------------------------------------------------------------------
02.21
编译qsdk问题： 编译失败，还是会有permission问题，以为是sshkey的问题，后来证明不是，网上搜索错误提示，尝试了几个办法都失败了; 继续阅读文档。
和之前工作的开发环境变化比较大，之前习惯与window环境开发，现在git gerrit repo redmine 还有vim代替之前习惯了的source insight，都感觉很不适。 感觉疲惫不堪，工作内容的变更还是蛮剧烈的，整理一下需要掌握的基本东西，不能闭着眼睛向前冲了。
今天拿到evb，接上电源和串口，正常启动，串口线坏掉换了一根，不过minicom也不熟悉，需要先了解一些基本的控制;
--------------------------------------------------------------------------------
02.20 新公司上班了， 继续努力！
新公司第一天，上午处理一些手续，等待电脑就绪，下午尝试邮箱，gerrit redmine owncloud testlink等帐号，获取代码时候，因为错误的使用sudo，一直出现permission问题，处理问题过程中，看平台软件部门的相关介绍文档。
18：30左右，jimmy帮我修正了dev-qsdk代码库的获取问题。
