## 多媒体独立内存设计

###  修订记录
| 修订说明 | 日期 | 作者 |
| --- | --- | --- |
| 初版 | 2018/08/01 | 员清观 |

---
## 1 优化需求
videobox和客户应用共享使用CMA内存,客户应用占用大量内存的情况下,会使CMA出现大量碎片,从而导致videobox分配大块连续内存失败.已知场景至少包括:
- 多个客户程序和videobox进程同步后台启动,可参考`RM#6667 videobox 启动出现几率性失败`
- videobox大分辨率拍照场景,可参考`RM#5771 拍照切换分辨率压力测试`

本文将主要涵盖两个方面的改进:
- 为fr驱动模块提供独立内存池和分配算法(带诊断机制),以避免应用影响videobox和audiobox的连续内存分配
- 解决现有CMA机制下产生大量不可回收碎片的BUG

本文档基于`RM#6797 QSDK:[Allchip][BSP]独立内存管理模块开发`完成

---
## 2 独立内存池设计
为fr驱动模块提供可选的独立mempool,如使能此功能,multimedia应用将从此fr mempool中分配内存,而不再直接从CMA中分配,从而避开与其他应用和驱动的潜在冲突

### 2.1 配置选项
在QSDK源码目录下执行命令`make linux-menuconfig`进入配置界面，如下配置
```
Device Drivers  --->
  |-  [*] InfoTM special files and drivers  --->
  |   |   |--- InfoTM special files and drivers
  |   |   |-<*>   Infotm common drivers support  --->
  |   |   |   | --- Infotm common drivers support
  |   |   |   |-<*>   Frame Ring
  |   |   |   | ... ...
  |   |   |   |  *** Reserve fr mempool for MM(Multimedia app) from CMA: ***
  |   |   |   |-[*]     Reserve fr mempool
  |   |   |   |-(96)      percentage of total CMA (NEW)
```

缺省情况,取消选中`Reserve fr mempool`,multimedia应用与其竞争对手共享全部CMA内存;选中`Reserve fr mempool`将使能fr mempool,并缺省为其申请96%的CMA空闲内存,multimedia应用独享这个mempool,不会被其他应用和驱动侵占

### 2.2 设计实现
实现方式: 保留原CMA机制,在CMA初始化完成之后,fr驱动模块调用`dma_alloc_coherent()`直接分配大块空间(比如96%的CMA内存)作为fr mempool,其他应用或驱动可以继续共享CMA尚未被分配的剩余空间

基于fr mempool,将采用bitmap算法实现内存管理,为multimedia引用提供新的alloc和free函数

**fr mempool实现框架**<br>
```cpp
void *fr_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle, gfp_t gfp)
  pageno = bitmap_find_next_zero_area(frpool->bitmap, frpool->count, start, count, mask);//在bitmap中找到第一个满足要求的连续块
  bitmap_set(frpool->bitmap, pageno, count); //设置bitmap中对应内存位域
  pfn = frpool->base_pfn + pageno;
  *handle = pfn_to_dma(dev, pfn); //返回dma线性地址
  addr = frpool->vaddr + PAGE_SIZE * pageno;//返回虚拟地址
  return addr;

void fr_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t handle)
  bitmap_clear(frpool->bitmap, pfn - mempool->base_pfn, count);

static int __init fr_init_coherent_pool(void)
  free_cma_pages = global_page_state(NR_FREE_CMA_PAGES);
  fr_size = (CONFIG_MM_SIZE_PERCENTAGE * free_cma_pages / 100) << PAGE_SHIFT;
  vaddr = dma_alloc_coherent(NULL, fr_size, &fr_handle, GFP_KERNEL|__GFP_NOWARN);
  count = fr_size >> PAGE_SHIFT;
  bitmap_size = BITS_TO_LONGS(count) * sizeof(long);
  frpool = kzalloc(sizeof(struct fr_mempool) + 2*bitmap_size + BITMAP_PRINT_BUF_LEN, GFP_KERNEL);

postcore_initcall_sync(fr_init_coherent_pool);
```

高优先级的`postcore_initcall_sync`可以保证fr驱动模块成功申请到CMA内存

## 2.3 诊断调试
为了方便内存管理机制开发和调试,增加bitmap算法诊断信息打印.每次内存分配,无论成功失败,都会打印相关的bitmap信息.但如果每次内存分配都打印完整的bitmmap位图信息,一方面显示内容过多,另一方面不方便从中找出有用的信息,因而显示位图信息时过滤掉了一些冗余信息

### 2.3.1 bitmap trace信息控制
添加`/proc/fr_bitmap`来实现bitmap算法诊断机制控制;诊断信息为`KERN_DEBUG`级别,如需实时打印请调整printk显示级别如: `echo 8 4 1 7 > /proc/sys/kernel/printk`

**使能trace打印**<br>
echo 1 > /proc/fr_bitmap

**禁止trace打印**<br>
echo 0 > /proc/fr_bitmap

**打印当前完整bitmap**<br>
cat /proc/fr_bitmap

### 2.3.2 显示bitmap完整mapping
当前在下面场景下,会显示完整的mapping信息:
- 本次内存分配和上次分配来自不用的pid时,一般来说,对应于切换到新进程,比如videobox或audiobox启动后第一次分配内存时
- 本次内存分配失败,打印完整mapping帮助分析
- `cat /proc/fr_bitmap`

打印完整位图信息时,每个映射字段对应一个32bit的mapping信息,含义:
- `00000000,` 对应的32个页全部空闲
- `________,` 相当于`ffffffff,` 对应的32个页全部被占用,对比分析时视觉效果比后者更为直观
- 非全0非全f,如`00f7ffff`,对应9个页空闲,23个页被占用

`free page: `域显示当前bitmap行空闲page的个数

**cat /proc/fr_bitmap主动打印**
```
~~~~~~~~~~~~ show fr bitmap mapping ~~~~~~~~~~~~
0000:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
0512:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
1024:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
1536:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
2048:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
2560:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
3072:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
3584:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
4096:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
4608:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
5120:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
5632:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
6144:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
6656:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
7168:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
7680:bitmap->________,________,________,________,________,________,________,________,________,________,________,________,________,________,________,________, free page: 0
8192:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000fff,________,________,________, free page: 404
8704:bitmap->        ,        ,        ,        ,        ,        ,        ,        ,        ,        ,        ,        ,        ,00000000,00000000,00000000, free page: 96
~~~~~~~~~~~~ Total 485 free pages, 1M and 916k bytes ~~~~~~~~~~~~
```

**videobox启动时首次alloc显示完整的bitmap free mapping**
```
~~~~~~~~~~~~~~~~~~~~~~~~Switch to new thread, print all(and only) free mapping information~~~~~~~~~~~~~~~~~~~~~~~~
0000:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,0007ffff,________,________,000000f7,________,________, free page: 358
0512:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
1024:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
1536:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
2048:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
2560:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
3072:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
3584:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
4096:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
4608:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
5120:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
5632:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
6144:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
6656:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
7168:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
7680:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
8192:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
8704:bitmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000, free page: 512
~~~~~~~~~~~~~~~~~~~~~~~~Total 9062 free pages, 35M and 408k bytes~~~~~~~~~~~~~~~~~~~~~~~~
```
映射第一行非0字段,对应与videobox之前内核已经分配的部分约600k内存

### 2.3.3 单次内存分配trace
打印单次分配相关位图信息时,如果某行对应的页不相关,行首会显示`xxxx:bitmap->`并且后面映射信息不打印;否则,会同时打印分配前后的映射信息,分配前映射以`xxxx:oldmap->`开始,分配后映射以`xxxx:newmap->`开始

打印单次内存分配相关位图信息时,每个映射字段对应一个32bit的mapping信息,含义和上面打印完整映射稍有不同:
- `00000000,` 对应的32个页全部空闲
- `ffffffff,` 对应的32个页全部占用
- 非全0非全f,如`00f7ffff`,对应9个页空闲,23个页被占用
- `********,` 只会出现在`xxxx:newmap->`行中,表示对应的映射没有变化

**videobox分配内存**
```
[  671.349999] fr_alloc_coherent ok, pageno 4051, count 765, handle:42813000 vaddr:c2813000
[  671.353333] bitmap updated(pid:553, command:videoboxd)->
[  671.356666] 3584:oldmap->00000000,0007ffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff
[  671.359999] 3584:newmap->ffffffff,ffffffff,********,********,********,********,********,********,********,********,********,********,********,********,********,********
[  671.363333] 4096:oldmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000
[  671.366666] 4096:newmap->ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff
[  671.369999] 4608:oldmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000
[  671.373333] 4608:newmap->********,********,********,********,********,********,********,********,********,0000ffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff
[  671.376666] ~~~~~~~~~~~~ Total 3969 free pages, 15M and 516k bytes ~~~~~~~~~~~~
```

**videobox释放内存**
```
[  681.406666] fr_free_coherent(pfn 272403, count:765)
[  681.409999] bitmap updated(pid:553, command:videoboxd)->
[  681.413333] 3584:oldmap->ffffffff,fff80000,00000000,00000000,00000000,06000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000
[  681.416666] 3584:newmap->00000000,00000000,********,********,********,********,********,********,********,********,********,********,********,********,********,********
[  681.419999] 4096:oldmap->ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff
[  681.423333] 4096:newmap->00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000
[  681.426666] 4608:oldmap->ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff
[  681.429999] 4608:newmap->********,********,********,********,********,********,********,********,********,ffff0000,00000000,00000000,00000000,00000000,00000000,00000000
[  681.433333] ~~~~~~~~~~~~ Total 7244 free pages, 28M and 304k bytes ~~~~~~~~~~~~
```

---
## 3 修正CMA机制Bug
`RM#6667 videobox 启动出现几率性失败`问题中,多个客户应用和videobox以及audiobox后台同步启动,导致低概率出现videobox申请大块连续内存时失败的情况;失败场景下`cat /proc/pagetypeinfo`的显示结果如下:
```
Free pages count per migrate type at order       0      1      2      3      4      5      6      7      8      9     10
Node    0, zone   Normal, type    Unmovable      0      1      2      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type  Reclaimable     70     92     52      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Movable      0      0      0      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Reserve      0      0      0      1      0      0      1      1      1      1      0
Node    0, zone   Normal, type          CMA   2161   2160    356      0      0      0      0      0      0      0      0
Node    0, zone   Normal, type      Isolate      0      0      0      0      0      0      0      0      0      0      0

Number of blocks type     Unmovable  Reclaimable      Movable      Reserve          CMA      Isolate
Node 0, zone   Normal            1            1            3            1           10            0
```

上述场景中,用户的应用程序大量抢占CMA的内存后产生过多内存碎片,导致videobox无法申请到足够长的连续内存. 基于此,有两个疑点:
- 碎片太过琐碎,基本上都是1或2或4个page,完全不存在8个page或更多page的块,严重怀疑当前使用的CMA内存算法是否合理
- 伙伴系统中CMA碎片迁移的的机制看起来没有生效

比较系统的跟踪测试内核相关逻辑之后,发现上述两个问题确实存在,而根本原因都在于迁移算法bug

### 3.1 CMA迁移算法bug
跟踪应用层`malloc()`函数调用流程到`__alloc_pages_nodemask()`:
```cpp
__alloc_pages_nodemask()
  |--> get_page_from_freelist()
    |--> buffered_rmqueue()
      |--> __rmqueue()
        page = __rmqueue_smallest(zone, order, migratetype);
        if (unlikely(!page) && migratetype != MIGRATE_RESERVE)
          |--> page = __rmqueue_fallback(zone, order, migratetype);
            for (current_order = MAX_ORDER-1; current_order >= order; --current_order) {
  		        for (i = 0;; i++) {
                migratetype = fallbacks[start_migratetype][i];
                ...
              }
            }
```

应用层调用`__rmqueue_smallest()`申请不到非CMA内存时,就会调用`__rmqueue_fallback()`从CMA申请内存. 阅读代码至此发现逻辑上存在严重问题,检查分配的循环每次从`current_order = MAX_ORDER-1`开始,也就是说每次优先分配最大的内存块,这种逻辑简直就是个内存粉碎器. 比如我们有10个4M大小的CMA块,10次调用分配之后,哪怕每次只分配4k小内存,我们也只剩下10个2M大小的块和大量小碎片;继续反复大量调用后,最后只会剩下4k/8k碎片

如下修改`__rmqueue_fallback()`进行测试,当确定需要迁移到CMA时,调用__rmqueue_smallest()函数,优先分配小的CMA内存块,这样就不会再出现大量碎片:
```cpp
  static inline struct page *__rmqueue_fallback(struct zone *zone, int order, int start_migratetype)
    ...
    area = &(zone->free_area[current_order]);
		if (list_empty(&area->free_list[migratetype]))
			continue;
++  if (migratetype == MIGRATE_CMA) {
++		return __rmqueue_smallest(zone, order, migratetype);
++  }
    ...
```

### 3.2 碎片整理问题
在QIWO门铃上改进压力测试脚本,保证3分钟内稳定重现问题之后进一步跟踪分析,确认分配大块连续内存失败的根本原因是存在大量无法被迁移的碎片page,而且所有这些碎片page都来自于同一个inode的文件缓存.由于对文件缓存部分机制不够熟悉,暂时只能怀疑这个inode就是当前运行的videoboxd及其库,故而缓存page被锁定无法迁移.修正迁移算法bug之后,此inode的文件缓存在CMA中集中分配,就不再会出现因为大量碎片page存在导致分配大块连续内存失败的情况.

**分配大块连续内存失败的软件流程:**
```cpp
struct page *dma_alloc_from_contiguous(struct device *dev, int count,unsigned int align)
  --> ret = alloc_contig_range(pfn, pfn + count, MIGRATE_CMA);
    --> ret = __alloc_contig_migrate_range(&cc, start, end);
      --> nr_reclaimed = reclaim_clean_pages_from_list(cc->zone,&cc->migratepages);
        --> ret = shrink_page_list(&clean_pages, zone, &sc,TTU_UNMAP|TTU_IGNORE_ACCESS,&dummy1, &dummy2, true);
          --> if (page_has_private(page))
            if (!try_to_release_page(page, sc->gfp_mask))
              --> return try_to_free_buffers(page);//page被锁定,无法迁移
```
最后`try_to_free_buffers()`函数返回错误,表示对应的page无法迁移.

---
## 4 验证测试

### 4.1 基本功能测试
基于`dev_qsdk`分支2018-07-31的版本,使用`q3fevb_va_ipc`工程,配置为"ar330mipi"和"ipc.json"

`videoboxd``audiobox``wifi``d304main`启动测试,确认没有错误之后重启,再次测试; 通过检查fr总分配大小来判断multimedia应用是否正常启动,通过`ps`检查`wifi`和`d304main`启动是否正常;检查到异常之后,测试停止

测试结果: 经过40小时以上压力测试,没有出现内存分配失败的问题

**测试脚本如下**
```cpp
		videoboxd > /dev/null
		audiobox > /dev/null &
		wifi > /dev/null &
		d304main > /dev/null &

		echo "sleep 20s ..."
		sleep 20
		frinfo_ok=`cat /proc/fr_info | grep -c '32.46M'`
		process_ok=`ps | grep -c -e 'videoboxd$' -e 'audiobox$' -e 'wifi$' -e 'd304main$'`;
		echo ""
		echo "Show frinfo_ok : [ $frinfo_ok ] ... process_ok : [ $process_ok ]";
		echo ""
		cat /proc/meminfo > /dev/null
		echo 3 > /proc/sys/vm/drop_caches
		cat /proc/meminfo
		echo ""

		if [ "$frinfo_ok" == "1" ]; then
			if [ "$process_ok" == "4" ]; then
				reboot
			fi
		fi
```

### 4.2 内存申请与释放压力测试
基于`dev_qsdk`分支2018-07-31的版本,使用`q3fevb_va_ipc`工程,配置为"ar330mipi"和"ipc.json"

启动`videoboxd`,1秒后后`killall videoboxd`,不断重复此测试;通过检查fr总分配大小来判断videoboxd启动是否正常;检查到异常之后,测试停止

测试结果: 经过40小时以上压力测试,没有出现内存分配失败的问题

**测试脚本如下**
```cpp
    while true; do
			videoboxd > /dev/null
			frinfo_ok=`cat /proc/fr_info | grep -c '32.38M'`;echo $frinfo_ok
			echo "Show frinfo_ok : [ $frinfo_ok ]";
			if [ "$frinfo_ok" == "0" ]; then
				echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~videoboxd test failed~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
				break;
			fi
			sleep 1;
			killall videoboxd
			sleep 1;
			cat /proc/meminfo > /dev/null;echo 3 > /proc/sys/vm/drop_caches;cat /proc/meminfo | grep "MemFree"
		done
```

### 4.3 QIWO门铃项目上验证
QIWO门铃项目`qipc_qiwo_doorbell_dev`基于2018-05-14的版本,使用客户提供的测试脚本压力测试验证

测试结果: 使能fr mempool或修正CMA迁移算法这两种方案,都经过40小时压力测试没有出现内存分配失败的问题

可以通过下面几项修改提高重现几率:
- CMA内存从30M减小到25M
- 压缩公用内存,比如直接在fr模块初始化时调用kzalloc()申请10M内存
- `ulimit -s 1024`,保证videoboxd在剩余内存不到8M的时候仍然能够启动

**判定测试结果的脚本如下**
```cpp
  frinfo_ok=`cat /proc/fr_info | grep -c 'Total: 23.64M'`;echo $frinfo_ok
	process_ok=`ps | grep -c -e 'videoboxd$' -e 'audiobox$' -e 'd318$'`;echo $process_ok
	echo ""
	echo "Show frinfo_ok : [ $frinfo_ok ] ... process_ok : [ $process_ok ]";
	echo ""
	if [ "$frinfo_ok" == "1" ]; then
		if [ "$process_ok" == "3" ]; then
			echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~initiate videobox ok~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
			reboot
      sleep 20
		fi
	fi
  echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~videoboxd test failed~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
```
