##

###  修订记录
| 修订说明 | 日期 | 作者 | 额外说明 |
| --- |
| 初版 | 2018/06/28 | 员清观 |  |


## 1 alsa应用层编程
ALSA是Advanced Linux Sound Architecture 的缩写，目前已经成为了linux的主流音频体系结构。在内核设备驱动层，ALSA提供了alsa-driver，同时在应用层，ALSA为我们提供了alsa-lib，应用程序只要调用alsa-lib提供的API，即可以完成对底层音频硬件的控制。内核空间中，alsa-soc其实是对alsa-driver的进一步封装，他针对嵌入式设备提供了一些列增强的功能

目前alsa内核提供给用户空间的接口有：
1) information interface(/proc/asound)
2) control interface(/dev/snd/controlCx)
3) Mixer interfacce(/dev/snd/mixerCxDx)
4) PCM interface(/dev/snd/pcmCxDx)
5) Raw MIDI interface(/dev/snd/midiCxDx)
6) Sequencer interface(/dev/snd/seq)
7) Timer interface(/dev/snd/timer)

/dev/snd目录下有效设备文件：
- controlC0 用于声卡的控制，例如通道选择，混音，麦克风的控制等
- pcmC0D0c 用于录音的pcm设备，C0D0代表的是声卡0中的设备0
- pcmC0D0p 用于播放的pcm设备
- timer 定时器

/kernel/sound目录下待学习文件夹:
- core 该目录包含了ALSA驱动的中间层，它是整个ALSA驱动的核心部分
- soc  针对system-on-chip体系的中间层代码
- soc/codecs  针对soc体系的各种codec的代码，与平台无关

重要需要走读文件：
- /sound/core/init.c
-

### 1.1 配置conf
配置文件解析： /usr/share/alsa/alsa.conf /usr/share/alsa/pcm/default.conf /etc/

从正常逻辑考虑，一个PCM设备应该包含录音和放音两个部分，包含两个方向的substream吧？`snd_pcm_new()`应该包含一个录音一个放音

```cpp
int snd_pcm_open(snd_pcm_t **pcmp, const char *name, snd_pcm_stream_t stream, int mode)
	int err = snd_config_update();//刷新/system/usr/share/alsa/alsa.conf文件内容到snd_config_t结构中，构建配置树
	|--> return snd_pcm_open_noupdate(pcmp, snd_config, name, stream, mode, 0);//真正执行树创建的例程:构建配置树，创建PCM流
		snd_pcm_open_conf(pcmp, name, root, pcm_conf, stream, mode);
			err = snd_config_get_string(conf, &str);
			open_name = buf;	sprintf(buf, "_snd_pcm_%s_open", str);//根据conf找到str,然后生成回调函数名称
			open_func = snd_dlobj_cache_get(lib, open_name,	SND_DLSYM_VERSION(SND_PCM_DLSYM_VERSION), 1);
			open_func(pcmp, name, pcm_root, pcm_conf, stream, mode); // _snd_pcm_hw_open()

```


### 1.2 状态查询

```cpp
//每个period发送sig给pid
int snd_pcm_async(snd_pcm_t *pcm, int sig, pid_t pid)

struct sndrv_pcm_status {
	int state;			/* stream state */
	struct timespec trigger_tstamp;	/* time when stream was started/stopped/paused */
	struct timespec tstamp;		/* reference timestamp */
	sndrv_pcm_uframes_t appl_ptr;	/* appl ptr */
	sndrv_pcm_uframes_t hw_ptr;	/* hw ptr */
	sndrv_pcm_sframes_t delay;	/* current delay in frames */
	sndrv_pcm_uframes_t avail;	/* number of frames available */
	sndrv_pcm_uframes_t avail_max;	/* max frames available on hw since last status */
	sndrv_pcm_uframes_t overrange;	/* count of ADC (capture) overrange detections from last status */
	int suspended_state;		/* suspended stream state */
	unsigned char reserved[60];	/* must be filled with zero */
};
//这个结构体中包含的有意思信息很多啊。
snd_pcm_status_t *status;
snd_pcm_t *handle;
snd_pcm_status_alloca(&status);
snd_pcm_status(handle, status);

int snd_pcm_status(snd_pcm_t *pcm, snd_pcm_status_t *status)
void snd_pcm_status_get_tstamp(const snd_pcm_status_t *obj, snd_timestamp_t *ptr)
//可以用来判断硬件是否就绪
snd_pcm_state_t snd_pcm_state(snd_pcm_t *pcm);

//驱动层的一些信息
struct sndrv_pcm_info {
	unsigned int device;		/* RO/WR (control): device number */
	unsigned int subdevice;		/* RO/WR (control): subdevice number */
	int stream;			/* RO/WR (control): stream direction */
	int card;			/* R: card number */
	unsigned char id[64];		/* ID (user selectable) */
	unsigned char name[80];		/* name of this device */
	unsigned char subname[32];	/* subdevice name */
	int dev_class;			/* SNDRV_PCM_CLASS_* */
	int dev_subclass;		/* SNDRV_PCM_SUBCLASS_* */
	unsigned int subdevices_count;
	unsigned int subdevices_avail;
	union sndrv_pcm_sync_id sync;	/* hardware synchronization ID */
	unsigned char reserved[64];	/* reserved for future... */
};
int snd_pcm_info(snd_pcm_t *pcm, snd_pcm_info_t *info)

	snd_pcm_info_t *info = NULL;
	snd_pcm_info_alloca(&info);
	snd_pcm_info(dev->handle, info);
	snd_pcm_info_free(info);


//就绪的帧个数
snd_pcm_sframes_t snd_pcm_avail(snd_pcm_t *pcm)
int snd_pcm_delay(snd_pcm_t *pcm, snd_pcm_sframes_t *delayp)
int snd_pcm_avail_delay(snd_pcm_t *pcm,	snd_pcm_sframes_t *availp,　snd_pcm_sframes_t *delayp)
int snd_pcm_htimestamp(snd_pcm_t *pcm, snd_pcm_uframes_t *avail, snd_htimestamp_t *tstamp)
```

```cpp
//两个pcm同步开始和停止
int snd_pcm_link(snd_pcm_t *pcm1, snd_pcm_t *pcm2)
int snd_pcm_unlink(snd_pcm_t *pcm)
//audiobox部分，最好不要基于fr，或者，也应该基于float fr
```

## 2 soc解析

![声卡pcm结构](pic_dir/声卡pcm结构.png)

在嵌入式系统中，通常不会像上图中这么复杂，大多数情况下是一个声卡，一个pcm实例，pcm下面有一个playback和capture stream，playback和capture下面各自有一个substream。 下面一张图列出了pcm中间层几个重要的结构，他可以让我们从uml的角度看一看这列结构的关系，理清他们之间的关系，对我们理解pcm中间层的实现方式

![pcm中间层结构体关系图](pic_dir/pcm中间层结构体关系图.png)

snd_pcm是挂在snd_card下面的一个snd_device；snd_pcm中的字段：streams[2]，该数组中的两个元素指向两个snd_pcm_str结构，分别代表playback stream和capture stream；snd_pcm_str中的substream字段，指向snd_pcm_substream结构；snd_pcm_substream是pcm中间层的核心，绝大部分任务都是在substream中处理，尤其是他的ops（snd_pcm_ops）字段，许多user空间的应用程序通过alsa-lib对驱动程序的请求都是由该结构中的函数处理。它的runtime字段则指向snd_pcm_runtime结构，snd_pcm_runtime记录这substream的一些重要的软件和硬件运行环境和参数。

![新建pcm的序列图](pic_dir/新建pcm的序列图.png)

### 2.1 soc结构

![ASoC数据结构](pic_dir/aSoC数据结构.png)

个人理解
- imapx-fr1023.c属于machine，文件中`snd_soc_card`定义了所有的`snd_soc_dai_link`，`snd_soc_dai_link`负责连接Platform和Codec
- fr1023.c应该属于codec，定义了`snd_soc_codec_driver`和`snd_soc_dai_driver`
- imapx-i2s.c应该属于platform，定义了`snd_soc_platform_driver`和`snd_soc_dai_driver`


### 2.2 代码解析

```cpp
struct snd_card {
	int number;			/* number of soundcard (index to snd_cards) */

	char id[16];			/* id string of this card */
	char driver[16];		/* driver name */
	char shortname[32];		/* short name of this soundcard */
	char longname[80];		/* name of this soundcard */
	char mixername[80];		/* mixer name */
	char components[128];		/* card components delimited with	space */
	//struct module *module;		/* top-level module 注释掉是为了atom显示问题 */

	void *private_data;
	//void (*private_free) (struct snd_card *card); /* callback for freeing of private data,注释掉是为了atom显示问题 */

	unsigned int last_numid;	/* last used numeric ID */
	struct rw_semaphore controls_rwsem;	/* controls list lock */
	rwlock_t ctl_files_rwlock;	/* ctl_files list lock */
	int controls_count;		/* count of all controls */
	int user_ctl_count;		/* count of all user controls */

	struct snd_info_entry *proc_root;	/* root for soundcard specific files */
	struct snd_info_entry *proc_id;	/* the card id */
	struct proc_dir_entry *proc_root_link;	/* number link to real id */

	struct snd_shutdown_f_ops *s_f_ops; /* file operations in the shutdown state */
	spinlock_t files_lock;		/* lock the files for this card */
	int shutdown;			/* this card is going down */
	int free_on_last_close;		/* free in context of file_release */
	wait_queue_head_t shutdown_sleep;
	atomic_t refcount;		/* refcount for disconnection */
	struct device *dev;		/* device assigned to this card */
	struct device *card_dev;	/* cardX object for sysfs */

	struct list_head devices;	/* 记录该声卡下所有逻辑设备的链表 */
	struct list_head controls;	/* all controls for this card //记录该声卡下所有的控制单元的链表 */
	struct list_head ctl_files;	/* active control files */
	struct list_head files_list;	/* all files associated to this card */
};
struct snd_soc_card {
	const char *name,*long_name,*driver_name;
	struct device *dev;	struct snd_card *snd_card;	struct module *owner;
	struct mutex mutex, dapm_mutex;		bool instantiated;

	int (*probe)(struct snd_soc_card *card);
	int (*late_probe)(struct snd_soc_card *card);
	int (*remove)(struct snd_soc_card *card);

	/* the pre and post PM functions are used to do any PM work before and after the codec and DAI's do any PM work. */
	int (*suspend_pre)(struct snd_soc_card *card);	int (*suspend_post)(struct snd_soc_card *card);
	int (*resume_pre)(struct snd_soc_card *card);	  int (*resume_post)(struct snd_soc_card *card);
	int (*set_bias_level)(struct snd_soc_card *,struct snd_soc_dapm_context *dapm,enum snd_soc_bias_level level);
	int (*set_bias_level_post)(struct snd_soc_card *,struct snd_soc_dapm_context *dapm,enum snd_soc_bias_level level);

	long pmdown_time;

	struct snd_soc_dai_link *dai_link; /* CPU <--> Codec DAI links  */
	struct snd_soc_pcm_runtime *rtd;		int num_links, num_rtd;

	struct snd_soc_codec_conf *codec_conf;/* optional codec specific configuration */
	int num_configs;

	struct snd_soc_aux_dev *aux_dev;/* optional auxiliary devices such as amplifiers or codecs with DAI link unused */
	struct snd_soc_pcm_runtime *rtd_aux;		int num_aux_devs, num_aux_rtd;

	const struct snd_kcontrol_new *controls;
	const struct snd_soc_dapm_widget *dapm_widgets; /* Card-specific routes and widgets */
	const struct snd_soc_dapm_route *dapm_routes;
	int num_controls, num_dapm_routes, num_dapm_widgets;		bool fully_routed;
	struct work_struct deferred_resume_work;
	struct list_head list,codec_dev_list,platform_dev_list,dai_dev_list,widgets,paths,dapm_list,dapm_dirty;
	struct snd_soc_dapm_context dapm; /* Generic DAPM context for the card */
	struct snd_soc_dapm_stats dapm_stats;
	u32 pop_time;			void *drvdata;
};

struct snd_card *snd_cards[SNDRV_CARDS]; //

int snd_pcm_dev_register(struct snd_device *device)
	struct snd_pcm *pcm = device->device_data; struct device *dev = pcm->dev;
	|--> snd_pcm_add(pcm);
		list_add_tail(&newpcm->list, &snd_pcm_devices);
	devtype = SNDRV_DEVICE_TYPE_PCM_PLAYBACK; //或者 devtype = SNDRV_DEVICE_TYPE_PCM_CAPTURE;
	|--> snd_register_device_for_dev(devtype, pcm->card, pcm->device, &snd_pcm_f_ops[cidx], pcm, str, dev);
		//创建设备并绑定snd_pcm结构和snd_pcm_f_ops[]操作函数集，保存到snd_minor结构体HASH。一个card可以包含多个snd_pcm,一个snd_pcm可以包含两个substream，但当前用法，一个snd_pcm包含一个substream.
		struct snd_minor *preg = kmalloc(sizeof *preg, GFP_KERNEL);
		preg->type = type;	preg->card = card ? card->number : -1;	preg->device = dev;	preg->f_ops = f_ops;
		preg->private_data = private_data;	preg->card_ptr = card;
		minor = snd_kernel_minor(type, card, dev);	snd_minors[minor] = preg; //snd_minors每个单元对应一个substream
		preg->dev = device_create(sound_class, device, MKDEV(major, minor), private_data, "%s", name);
	snd_add_device_sysfs_file(devtype, pcm->card, pcm->device, &pcm_attrs);

int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)//初始化rtd，为之绑定pcm和ops
	struct snd_soc_platform *platform = rtd->platform;
	struct snd_soc_dai *codec_dai = rtd->codec_dai;
	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
	|--> ret = _snd_pcm_new(rtd->card->snd_card, new_name, num, playback,	capture, false, &pcm);//int _snd_pcm_new(struct snd_card *card, const char *id, int device,int playback_count, int capture_count, bool internal,struct snd_pcm **rpcm)
		//申请并初始化一个stream，它包含若干substreams
		static struct snd_device_ops ops = {	...	.dev_register =	snd_pcm_dev_register, ...};
		struct snd_pcm *pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
		pcm->card = card;	pcm->device = device;	pcm->internal = internal;
		strlcpy(pcm->id, id, sizeof(pcm->id));
		|--> snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK, playback_count);//申请并初始化一个substream
			struct snd_pcm_str *pstr = &pcm->streams[stream];
			pstr->stream = stream;pstr->pcm = pcm;pstr->substream_count = substream_count; snd_pcm_stream_proc_init(pstr);
			pstr->substream = substream = kzalloc(sizeof(*substream), GFP_KERNEL);
			substream->pcm = pcm;		substream->pstr = pstr;	substream->number = idx;	substream->stream = stream;
			sprintf(substream->name, "subdevice #%i", idx); substream->buffer_bytes_max = UINT_MAX;
			err = snd_pcm_substream_proc_init(substream); substream->group = &substream->self_group;
			list_add_tail(&substream->link_list, &substream->self_group.substreams);
		snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_CAPTURE, capture_count);
		|--> snd_device_new(card, SNDRV_DEV_PCM, pcm, &ops); //申请并初始化，然后添加到声卡设备链表中
			struct snd_device *dev = kzalloc(sizeof(*dev), GFP_KERNEL);
			dev->card = card;	dev->type = type; dev->state = SNDRV_DEV_BUILD; dev->device_data = device_data;
			dev->ops = ops; list_add(&dev->list, &card->devices);
	rtd->pcm = pcm;	pcm->private_data = rtd;
	rtd->ops.open		= soc_pcm_open;		rtd->ops.hw_params	= soc_pcm_hw_params;		rtd->ops.prepare	= soc_pcm_prepare;
	rtd->ops.trigger	= soc_pcm_trigger;		rtd->ops.hw_free	= soc_pcm_hw_free;		rtd->ops.close		= soc_pcm_close;
	rtd->ops.pointer	= soc_pcm_pointer;		rtd->ops.ioctl		= soc_pcm_ioctl;
	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &rtd->ops);
	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &rtd->ops);
	ret = platform->driver->pcm_new(rtd); //imapx-dma.c中imapx_pcm_new()
	pcm->private_free = platform->driver->pcm_free;//imapx_pcm_free_dma_buffers()

int snd_soc_instantiate_card(struct snd_soc_card *card)
	for (i = 0; i < card->num_links; i++)	ret = soc_bind_dai_link(card, i);
	//not active :for (i = 0; i < card->num_aux_devs; i++)	ret = soc_check_aux_dev(card, i);
	|--> ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,	card->owner, 0, &card->snd_card);//↑↑↑↑↑
		struct snd_card *card = kzalloc(sizeof(*card) + extra_size, GFP_KERNEL);
		strlcpy(card->id, xid, sizeof(card->id));
		card->number = idx;card->module = module;INIT_LIST_HEAD(&card->****);//初始化snd_card结构中必要的字段
		err = snd_ctl_create(card);	//建立逻辑设备：Control
		err = snd_info_card_create(card);//建立proc文件中的info节点：通常就是/proc/asound/card0
		card->private_data = (char *)card + sizeof(struct snd_card);//把第一步分配的内存指针放入private_data字段中
	card->snd_card->dev = card->dev;
	card->dapm.bias_level = SND_SOC_BIAS_OFF;	card->dapm.dev = card->dev;	card->dapm.card = card;
	list_add(&card->dapm.list, &card->dapm_list);
	ret = card->probe(card);
	|--> ret = soc_probe_link_components(card, i, order);
		ret = soc_probe_codec(card, cpu_dai->codec);
			const struct snd_soc_codec_driver *driver = codec->driver;
			ret = driver->probe(codec);codec->probed = 1;list_add(&codec->card_list, &card->codec_dev_list);
		ret = soc_probe_codec(card, codec_dai->codec);
		ret = soc_probe_platform(card, platform);
			const struct snd_soc_platform_driver *driver = platform->driver;
			ret = driver->probe(platform);platform->probed = 1;list_add(&platform->card_list, &card->platform_dev_list);
	|--> ret = soc_probe_link_dais(card, i, order);//int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
		cpu_dai->platform = platform;	codec_dai->card = card;	cpu_dai->card = card;
		cpu_dai->probed = 1; list_add(&cpu_dai->card_list, &card->dai_dev_list);
		codec_dai->probed = 1; list_add(&codec_dai->card_list, &card->dai_dev_list);
		ret = soc_post_component_init(card, codec, num, 0);
		ret = device_create_file(rtd->dev, &dev_attr_pmdown_time);
		ret = soc_new_pcm(rtd, num);//↑↑↑↑↑
	ret = snd_soc_dai_set_fmt(card->rtd[i].codec_dai, dai_fmt);
	ret = snd_soc_dai_set_fmt(card->rtd[i].cpu_dai, dai_fmt);
	|--> ret = snd_card_register(card->snd_card);
		//声卡的class出现在文件系统的/sys/class/sound/下面
		card->card_dev = device_create(sound_class, card->dev, MKDEV(0, 0), card, "card%i", card->number);//创建sysfs下的设备
		|--> snd_device_register_all(card));//注册所有挂在该声卡下的逻辑设备
			list_for_each_entry(dev, &card->devices, list)	dev->ops->dev_register(dev) //为每个设备调用 snd_pcm_dev_register()
		snd_cards[card->number] = card;
		init_info_for_card(card);
		err = device_create_file(card->card_dev, &card_id_attrs);
		err = device_create_file(card->card_dev, &card_number_attrs);
	card->instantiated = 1;

int soc_probe(struct platform_device *pdev)
	struct snd_soc_card *card = platform_get_drvdata(pdev);//得到 fr1023 (--struct snd_soc_card--)
	card->dev = &pdev->dev;
	|--> return snd_soc_register_card(card);//int snd_soc_register_card(struct snd_soc_card *card)
		dev_set_drvdata(card->dev, card); soc_init_card_debugfs(card);
		card->rtd = devm_kzalloc(card->dev, sizeof(struct snd_soc_pcm_runtime)*(card->num_links+card->num_aux_devs), GFP_KERNEL);
		card->num_rtd = 0;	card->instantiated = 0;	  card->rtd_aux = &card->rtd[card->num_links];
		for (i = 0; i < card->num_links; i++)		card->rtd[i].dai_link = &card->dai_link[i];
		|--> snd_soc_initialize_card_lists(card); //void snd_soc_initialize_card_lists(struct snd_soc_card *card)
			INIT_LIST_HEAD(&card->dai_dev_list);			INIT_LIST_HEAD(&card->codec_dev_list);
			INIT_LIST_HEAD(&card->platform_dev_list);			INIT_LIST_HEAD(&card->widgets);
			INIT_LIST_HEAD(&card->paths);			INIT_LIST_HEAD(&card->dapm_list);
		INIT_LIST_HEAD(&card->list); INIT_LIST_HEAD(&card->dapm_dirty);
		ret = snd_soc_instantiate_card(card);//↑↑↑↑↑

static struct platform_driver soc_driver = {
	.driver		= { 		.name		= "soc-audio", 		.owner		= THIS_MODULE, 		.pm		= &snd_soc_pm_ops, 	},
	.probe		= soc_probe,  	.remove		= soc_remove,
};
int __init snd_soc_init(void) //soc platform driver register
	return platform_driver_register(&soc_driver);

//machine层，添加device，这边定义了snd_soc_card结构
struct snd_soc_dai_link imapx_fr1023_dai[] = {
    [0] = { /* Hifi Playback - for similatious use with voice below */
        .name = "IMAPX FR1023", .stream_name = "soc-audio FR1023 HiFi", .codec_dai_name = "fr1023_dai",
        .ops = &imapx_hifi_ops,}, };
struct snd_soc_card fr1023 = {
	.name		= "fr1023",	.owner		= THIS_MODULE,	.dai_link	= imapx_fr1023_dai,	.num_links	= ARRAY_SIZE(imapx_fr1023_dai),};
struct platform_device imap_iis_device0 = {
	.name = "imapx-i2s",	.id = 0,	.num_resources = ARRAY_SIZE(imap_iis_resource0),	.resource = imap_iis_resource0,};
struct platform_driver imapx_iis_driver = {
	.probe = imapx_iis_dev_probe,	.remove = imapx_iis_dev_remove,	.driver = {		.name = "imapx-i2s",.owner = THIS_MODULE,},
};

//devices.c文件中
void imapx_audio_ctrl_register(struct audio_register *ctrl, int id)
	struct codec_cfg *subdata = imapx_audio_cfg[id].codec;
	sprintf(ctrl->codec_name, "%s.%d-00%x", imapx_audio_cfg[id].name, imapx_audio_cfg[id].ctrl_busnum, ctrl->info->addr);
	ctrl->info->platform_data = subdata;
	i2c_register_board_info(imapx_audio_cfg[id].ctrl_busnum,ctrl->info, 1);
	sprintf("%s.%d-00%x", imapx_audio_cfg[id].name, imapx_audio_cfg[id].ctrl_busnum, ctrl->info->addr);
void imapx_audio_data_register(struct audio_register *data, int id)
	sprintf(data->cpu_dai_name, "imapx-%s.%d", imapx_audio_cfg[id].data_bus, imapx_audio_cfg[id].data_busnum);
	data->cpu_dai_device = &imap_iis_device0;
	|--> platform_device_register(data->cpu_dai_device);//注册"imapx-i2s"
		device_initialize(&pdev->dev);arch_setup_pdev_archdata(pdev);	return platform_device_add(pdev);
	|--> data->imapx_audio_cfg_init(data->codec_name, data->cpu_dai_name, subdata->i2s_mode, imapx_audio_cfg[id].spdif_en, id);//.codec_name = "fr1023" //int imapx_fr1023_init(char *codec_name, char *cpu_dai_name, enum data_mode data, int enable, int id)//soc platform device register
		|--> struct platform_device *imapx_fr1023_device = platform_device_alloc("soc-audio", -1);
  		struct platform_object *pa = kzalloc(sizeof(struct platform_object) + strlen(name), GFP_KERNEL);
			strcpy(pa->name, name);	pa->pdev.name = pa->name;	pa->pdev.id = id;	device_initialize(&pa->pdev.dev);	pa->pdev.dev.release = platform_device_release;		arch_setup_pdev_archdata(&pa->pdev);
		imapx_fr1023_dai[0].codec_name = codec_name; imapx_fr1023_dai[0].cpu_dai_name = cpu_dai_name;     imapx_fr1023_dai[0].platform_name = cpu_dai_name;
		platform_set_drvdata(imapx_fr1023_device, &fr1023);
		platform_device_add(imapx_fr1023_device);//匹配，然后会调用 soc_probe()
//platform_device_register()和platform_device_alloc()+platform_device_add()的区别，前者自己定义了结构体

```
## 3 内核pcm文件

![hwbuffer示意图](pic_dir/hwbuffer示意图.png)

## 3.1 pcm_native.c

```cpp
struct file_operations snd_pcm_f_ops[2] = {
	{
		.owner =		THIS_MODULE,
		.write =		snd_pcm_write,
		.aio_write =		snd_pcm_aio_write,
		.open =			snd_pcm_playback_open,
		.release =		snd_pcm_release,
		.llseek =		no_llseek,
		.poll =			snd_pcm_playback_poll,
		.unlocked_ioctl =	snd_pcm_playback_ioctl,
		.compat_ioctl = 	snd_pcm_ioctl_compat,
		.mmap =			snd_pcm_mmap,
		.fasync =		snd_pcm_fasync,
		.get_unmapped_area =	snd_pcm_get_unmapped_area,
	},
	{
		.owner =		THIS_MODULE,
		.read =			snd_pcm_read,
		.aio_read =		snd_pcm_aio_read,
		.open =			snd_pcm_capture_open,
		.release =		snd_pcm_release,
		.llseek =		no_llseek,
		.poll =			snd_pcm_capture_poll,
		.unlocked_ioctl =	snd_pcm_capture_ioctl,
		.compat_ioctl = 	snd_pcm_ioctl_compat,
		.mmap =			snd_pcm_mmap,
		.fasync =		snd_pcm_fasync,
		.get_unmapped_area =	snd_pcm_get_unmapped_area,
	}
};
```

**pcm file创建和销毁**
```cpp
int snd_pcm_open(struct file *file, struct snd_pcm *pcm, int stream)
	err = snd_card_file_add(pcm->card, file);
	|--> err = snd_pcm_open_file(file, pcm, stream);
		struct snd_pcm_substream *substream;
		struct snd_pcm_file *pcm_file = kzalloc(sizeof(*pcm_file), GFP_KERNEL);
		|--> snd_pcm_open_substream(pcm, stream, file, &substream);
			|--> err = snd_pcm_attach_substream(pcm, stream, file, &substream);//为substream申请和初始化runtime
				struct snd_pcm_runtime *runtime = kzalloc(sizeof(*runtime), GFP_KERNEL);
				runtime->status = snd_malloc_pages(size, GFP_KERNEL); memset((void*)runtime->status, 0, size);
				runtime->control = snd_malloc_pages(size, GFP_KERNEL); memset((void*)runtime->control, 0, size);
				runtime->status->state = SNDRV_PCM_STATE_OPEN;
				substream->runtime = runtime;	substream->private_data = pcm->private_data;	substream->ref_count = 1;
				substream->f_flags = file->f_flags;	substream->pid = get_pid(task_pid(current));	pstr->substream_opened++;
				*rsubstream = substream;
			err = snd_pcm_hw_constraints_init(substream);
			|--> substream->ops->open(substream); //int imapx_pcm_open(struct snd_pcm_substream *substream)
				struct snd_pcm_runtime *runtime = substream->runtime;
				snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
				snd_soc_set_runtime_hwparams(substream, &imapx_pcm_hardware);
				struct imapx_runtime_data *prtd = kzalloc(sizeof(struct imapx_runtime_data), GFP_KERNEL);
				runtime->private_data = prtd;
			substream->hw_opened = 1;
			snd_pcm_hw_constraints_complete(substream);
			*rsubstream = substream;
		pcm_file->substream = substream;	substream->file = pcm_file;
		substream->pcm_release = pcm_release_private;	file->private_data = pcm_file;
int snd_pcm_release(struct inode *inode, struct file *file)
	struct snd_pcm_file *pcm_file = file->private_data;
	struct snd_pcm_substream *substream = pcm_file->substream;
	struct snd_pcm *pcm = substream->pcm;
	|--> snd_pcm_release_substream(substream);
		snd_pcm_drop(substream);
		|--> substream->ops->hw_free(substream); //int imapx_pcm_hw_free(struct snd_pcm_substream *substream)
			struct imapx_runtime_data *prtd = substream->runtime->private_data;
			snd_pcm_set_runtime_buffer(substream, NULL);
			prtd->params->ops->flush(prtd->params->ch);prtd->params->ops->release(prtd->params->ch,prtd->params->client);
		|--> substream->ops->close(substream);//int imapx_pcm_close(struct snd_pcm_substream *substream)
			struct snd_pcm_runtime *runtime = substream->runtime;
			struct imapx_runtime_data *prtd = runtime->private_data;
			runtime->private_data = NULL; kfree(prtd);
		substream->pcm_release(substream);//void pcm_release_private(struct snd_pcm_substream *substream)
		|--> snd_pcm_detach_substream(substream);//为sublstream释放runtime和其他资源
			struct snd_pcm_runtime *runtime = substream->runtime;
			snd_free_pages((void*)runtime->status,...):	snd_free_pages((void*)runtime->control,...):
			kfree(runtime->hw_constraints.rules);	kfree(runtime);	substream->runtime = NULL;
			put_pid(substream->pid);	substream->pid = NULL;	substream->pstr->substream_opened--;
	kfree(pcm_file);  snd_card_file_remove(pcm->card, file);
int snd_pcm_playback_open(struct inode *inode, struct file *file)
	struct snd_pcm *pcm = snd_lookup_minor_data(iminor(inode), SNDRV_DEVICE_TYPE_PCM_CAPTURE);
	err = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_CAPTURE);	snd_card_unref(pcm->card);
int snd_pcm_capture_open(struct inode *inode, struct file *file)
	struct snd_pcm *pcm = snd_lookup_minor_data(iminor(inode), SNDRV_DEVICE_TYPE_PCM_PLAYBACK);
	err = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);	snd_card_unref(pcm->card);
```


## 3.2 pcm_lib.c

```cpp
int snd_pcm_lib_read_transfer(struct snd_pcm_substream *substream, unsigned int hwoff, unsigned long data, unsigned int off, snd_pcm_uframes_t frames)
	struct snd_pcm_runtime *runtime = substream->runtime;
	char __user *buf = (char __user *) data + frames_to_bytes(runtime, off);
	char *hwbuf = runtime->dma_area + frames_to_bytes(runtime, hwoff);
	copy_to_user(buf, hwbuf, frames_to_bytes(runtime, frames));//从ring buffer中hwoff位置拷贝frames个帧到上层off位置

snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream, unsigned long data, snd_pcm_uframes_t size, int nonblock, transfer_f transfer)
	struct snd_pcm_runtime *runtime = substream->runtime;
	snd_pcm_uframes_t xfer = 0， offset = 0， avail;
	snd_pcm_update_hw_ptr0(substream, 0);
	while (size > 0)
		appl_ptr = runtime->control->appl_ptr; appl_ofs = appl_ptr % runtime->buffer_size;
		err = transfer(substream, appl_ofs, data, offset, frames);//等待数据就绪，读取合适长度的数据
		appl_ptr += frames;	if (appl_ptr >= runtime->boundary) appl_ptr -= runtime->boundary;
		runtime->control->appl_ptr = appl_ptr;
		size -= frames;

ssize_t snd_pcm_read(struct file *file, char __user *buf, size_t count, loff_t * offset)
	struct snd_pcm_file *pcm_file = file->private_data;
	struct snd_pcm_substream *substream = pcm_file->substream;
	struct snd_pcm_runtime *runtime = substream->runtime;
	count = bytes_to_frames(runtime, count);
	|--> result = snd_pcm_lib_read(substream, buf, count);//snd_pcm_sframes_t snd_pcm_lib_read(struct snd_pcm_substream *substream, void __user *buf, snd_pcm_uframes_t size)
		struct snd_pcm_runtime *runtime = substream->runtime;
		nonblock = !!(substream->f_flags & O_NONBLOCK);
		return snd_pcm_lib_read1(substream, (unsigned long)buf, size, nonblock, snd_pcm_lib_read_transfer);
	return frames_to_bytes(runtime, result);
```

### 3.3 sound.c

```cpp
int snd_open(struct inode *inode, struct file *file)
	unsigned int minor = iminor(inode);
	struct snd_minor *mptr = snd_minors[minor];		file->f_op = fops_get(mptr->f_ops);
	file->f_op->open(inode, file); //snd_pcm_playback_open() 或者 snd_pcm_capture_open()

void *snd_lookup_minor_data(unsigned int minor, int type)
	struct snd_minor *mreg = snd_minors[minor];
	if (mreg && mreg->type == type)		private_data = mreg->private_data;
	return private_data;

int __init alsa_sound_init(void)
	static int major = CONFIG_SND_MAJOR; //116
	snd_major = major;
	snd_ecards_limit = cards_limit;
	register_chrdev(major, "alsa", &snd_fops); //.open =		snd_open,
	snd_info_init();  snd_info_minor_register();
subsys_initcall(alsa_sound_init);
```

### 3.4 异步工作方式
音视频同步，需要两者保持相同的设备帧率么？

```cpp
//异步机制
int snd_pcm_open(snd_pcm_t **pcmp, const char *name, snd_pcm_stream_t stream, int mode)
//mode: SND_PCM_NONBLOCK, #SND_PCM_ASYNC
int snd_pcm_async(snd_pcm_t *pcm, int sig, pid_t pid)
//但是，这个period是设备的，通道参数如果不同，需要换算
int snd_async_add_pcm_handler(snd_async_handler_t **handler, snd_pcm_t *pcm, snd_async_callback_t callback, void *private_data)
//限制必须在pcm所在的进程中调用。
int snd_pcm_delay(snd_pcm_t *pcm, snd_pcm_sframes_t *delayp) //了解dma中剩余缓冲大小
或者imapx_dma.c文件中，devicefile中记录当前播放帧个数
或者，通过netlink通知
```
### 3.5 regmap机制
内核3.1引入一套新的API regmap，目的是提取出关于I2C SPI irq等相关注册、使能以及读写的公共部分，以提高代码的可重用性，并且使得在使用如上内核基础组件时变得更为简单易用。

```cpp
int hw_write(struct snd_soc_codec *codec, unsigned int reg, unsigned int value)
	return regmap_write(codec->control_data, reg, value);
unsigned int hw_read(struct snd_soc_codec *codec, unsigned int reg)
	ret = regmap_read(codec->control_data, reg, &val);	return value;

int snd_soc_codec_set_cache_io(struct snd_soc_codec *codec,int addr_bits, int data_bits, enum snd_soc_control_type control)
	struct regmap_config config;
	codec->write = hw_write;	codec->read = hw_read;	codec->bulk_write_raw = snd_soc_hw_bulk_write_raw;
	config.reg_bits = addr_bits;	config.val_bits = data_bits;
	if(SND_SOC_I2C == control) codec->control_data = regmap_init_i2c(to_i2c_client(codec->dev), &config);
	if(SND_SOC_SPI == control) codec->control_data = regmap_init_spi(to_spi_device(codec->dev), &config);
	if(SND_SOC_REGMAP == control)
		codec->using_regmap = true;
		if (!codec->control_data)			codec->control_data = dev_get_regmap(codec->dev, NULL);
		if (codec->control_data)	ret = regmap_get_val_bytes(codec->control_data);
```

```cpp
struct regmap_config {
	const char *name;
	int reg_bits;   // 寄存器地址的位数，必须配置，例如I2C寄存器地址位数为 8
	int reg_stride;
	int pad_bits; 	//寄存器和值之间的填充位数
	int val_bits;   //寄存器值的位数，必须配置

	bool (*writeable_reg)(struct device *dev, unsigned int reg);
	bool (*readable_reg)(struct device *dev, unsigned int reg);
	bool (*volatile_reg)(struct device *dev, unsigned int reg);
	bool (*precious_reg)(struct device *dev, unsigned int reg);
	int (*reg_read)(void *context, unsigned int reg, unsigned int *val);
	int (*reg_write)(void *context, unsigned int reg, unsigned int val);

	regmap_lock lock; 	regmap_unlock unlock; 	void *lock_arg;
	bool fast_io; unsigned int max_register;
	const struct regmap_access_table *wr_table, *rd_table, *volatile_table, *precious_table;
	const struct reg_default *reg_defaults;
	unsigned int num_reg_defaults;
	enum regcache_type cache_type;
	const void *reg_defaults_raw;
	unsigned int num_reg_defaults_raw;
	u8 read_flag_mask, write_flag_mask;
	bool use_single_rw;
	enum regmap_endian reg_format_endian, val_format_endian;
	const struct regmap_range_cfg *ranges;
	unsigned int num_ranges;
};
```

**初始化和释放regmap**
```cpp
struct regmap *regmap_init_spi(struct spi_device *spi, strcut regmap_config *config);
struct regmap *regmap_init_i2c(struct i2c_client *i2c, struct regmap_config *config);

int regmap_write(struct regmap *map, unsigned int reg, unsigned int val);
int regmap_raw_write(struct regmap *map, unsigned int reg, const void *val, size_t val_len);
int regmap_bulk_write(struct regmap *map, unsigned int reg, const void *val, size_t val_count);
int regmap_raw_write_async(struct regmap *map, unsigned int reg, const void *val, size_t val_len);
int regmap_read(struct regmap *map, unsigned int reg, unsigned int *val);
int regmap_raw_read(struct regmap *map, unsigned int reg, void *val, size_t val_len);
int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val, size_t val_count);
int regmap_update_bits(struct regmap *map, unsigned int reg, unsigned int mask, unsigned int val);

void regmap_exit(struct regmap *map);
```

**i2c-spi regmap机制**
`regmap_add_irq_chip()`好像没有被使用过，不再跟踪了
```cpp
int regmap_add_irq_chip(struct regmap *map, int irq, int irq_flags,	int irq_base, const struct regmap_irq_chip *chip,	struct regmap_irq_chip_data **data);
void regmap_del_irq_chip(int irq, struct regmap_irq_chip_data *data);
```

```cpp
int regmap_i2c_write(void *context, const void *data, size_t count)
	struct device *dev = context;
	struct i2c_client *i2c = to_i2c_client(dev);
	ret = i2c_master_send(i2c, data, count);
int regmap_i2c_read(void *context, const void *reg, size_t reg_size, void *val, size_t val_size)
	struct device *dev = context;
	struct i2c_client *i2c = to_i2c_client(dev);
	struct i2c_msg xfer[2];
	xfer[0].addr = i2c->addr;xfer[0].flags = 0;	xfer[0].len = reg_size;	xfer[0].buf = (void *)reg;
	xfer[1].addr = i2c->addr; xfer[1].flags = I2C_M_RD;	xfer[1].len = val_size;	xfer[1].buf = val;
	ret = i2c_transfer(i2c->adapter, xfer, 2);
struct regmap_bus regmap_i2c = {	.write = regmap_i2c_write,	.gather_write = regmap_i2c_gather_write,.read = regmap_i2c_read,};

struct regmap *regmap_init_i2c(struct i2c_client *i2c, const struct regmap_config *config)
	return regmap_init(&i2c->dev, &regmap_i2c, &i2c->dev, config);
struct regmap *devm_regmap_init_i2c(struct i2c_client *i2c, const struct regmap_config *config)
	return devm_regmap_init(&i2c->dev, &regmap_i2c, &i2c->dev, config);
```

```cpp
int regmap_spi_write(void *context, const void *data, size_t count)
	struct device *dev = context;
	struct spi_device *spi = to_spi_device(dev);
	return spi_write(spi, data, count);
int regmap_spi_read(void *context, const void *reg, size_t reg_size, void *val, size_t val_size)
	struct device *dev = context;		struct spi_device *spi = to_spi_device(dev);
	return spi_write_then_read(spi, reg, reg_size, val, val_size);
struct regmap_bus regmap_spi = {	.write = regmap_spi_write,	.read = regmap_spi_read, };

struct regmap *regmap_init_spi(struct spi_device *spi, const struct regmap_config *config)
	return regmap_init(&spi->dev, &regmap_spi, &spi->dev, config);
struct regmap *devm_regmap_init_spi(struct spi_device *spi, const struct regmap_config *config)
	return devm_regmap_init(&spi->dev, &regmap_spi, &spi->dev, config);

```

## 4 infotm驱动
### 4.1

## 5


## 6 wav文件格式解析
```cpp
```

```cpp
 private byte[] getWaveFileHeader(int sampleRate, int channels, int bitsPerSample, int bytePerSecond, long fileLenIncludeHeader)
 {
    byte[] wavHeader = new byte[44];
    long totalDataLen = fileLenIncludeHeader - 8;
    long audioDataLen = totalDataLen - 36;

    //ckid：4字节 RIFF 标志，大写
    wavHeader[0] = 'R'; wavHeader[1] = 'I'; wavHeader[2] = 'F'; wavHeader[3] = 'F';

    //cksize：4字节文件长度，这个长度不包括"RIFF"标志(4字节)和文件长度本身所占字节(4字节),即该长度等于整个文件长度 - 8
    wavHeader[4] = (byte)(totalDataLen & 0xff); wavHeader[5] = (byte)((totalDataLen >> 8) & 0xff); wavHeader[6] = (byte)((totalDataLen >> 16) & 0xff); wavHeader[7] = (byte)((totalDataLen >> 24) & 0xff);

    //fcc type：4字节 "WAVE" 类型块标识, 大写
    wavHeader[8] = 'W'; wavHeader[9] = 'A'; wavHeader[10] = 'V'; wavHeader[11] = 'E';

    //ckid：4字节 表示"fmt" chunk的开始,此块中包括文件内部格式信息，小写, 最后一个字符是空格
    wavHeader[12] = 'f'; wavHeader[13] = 'm'; wavHeader[14] = 't'; wavHeader[15] = ' ';

    //cksize：4字节，文件内部格式信息数据的大小，过滤字节（一般为00000010H）
    wavHeader[16] = 0x10; wavHeader[17] = 0; wavHeader[18] = 0; wavHeader[19] = 0;

    //FormatTag：2字节，音频数据的编码方式，1：表示是PCM 编码
    wavHeader[20] = 1; wavHeader[21] = 0;

    //Channels：2字节，声道数，单声道为1，双声道为2
    wavHeader[22] = (byte) channels; wavHeader[23] = 0;

    //SamplesPerSec：4字节，采样率，如44100
    wavHeader[24] = (byte)(sampleRate & 0xff); wavHeader[25] = (byte)((sampleRate >> 8) & 0xff); wavHeader[26] = (byte)((sampleRate >> 16) & 0xff); wavHeader[27] = (byte)((sampleRate >> 24) & 0xff);

    //BytesPerSec：4字节，音频数据传送速率, 单位是字节。其值为采样率×每次采样大小。播放软件利用此值可以估计缓冲区的大小；
    wavHeader[28] = (byte)(bytePerSecond & 0xff); wavHeader[29] = (byte)((bytePerSecond >> 8) & 0xff); wavHeader[30] = (byte)((bytePerSecond >> 16) & 0xff); wavHeader[31] = (byte)((bytePerSecond >> 24) & 0xff);

    //BlockAlign：2字节，每次采样的大小 = 采样精度*声道数/8(单位是字节); 这也是字节对齐的最小单位, 譬如 16bit 立体声在这里的值是 4 字节
    wavHeader[32] = (byte)(bitsPerSample * channels / 8); wavHeader[33] = 0;

    //BitsPerSample：2字节，每个声道的采样精度; 譬如 16bit 在这里的值就是16。如果有多个声道，则每个声道的采样精度大小都一样的；
    wavHeader[34] = (byte) bitsPerSample; wavHeader[35] = 0;

    //ckid：4字节，数据标志符（data），表示 "data" chunk的开始。此块中包含音频数据，小写；
    wavHeader[36] = 'd'; wavHeader[37] = 'a'; wavHeader[38] = 't'; wavHeader[39] = 'a';

    //cksize：音频数据的长度，4字节，audioDataLen = totalDataLen - 36 = fileLenIncludeHeader - 44
    wavHeader[40] = (byte)(audioDataLen & 0xff); wavHeader[41] = (byte)((audioDataLen >> 8) & 0xff); wavHeader[42] = (byte)((audioDataLen >> 16) & 0xff); wavHeader[43] = (byte)((audioDataLen >> 24) & 0xff); return wavHeader;
}
```
