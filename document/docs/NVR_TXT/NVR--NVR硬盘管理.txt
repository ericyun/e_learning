NVR硬盘管理
使用/dev/sda设备号直接打开文件写录像文件，写了一段时间后，IO很高，感觉不靠谱。所以，还是需要文件系统，或者至少也要用裸设备之类的机制作为缓冲。至于文件，有可能越大的文件越有同步的压力。

FAT32文件最大2G，而且不能使用超过64k的簇。看来必须定制文件系统了。

TrueFFS JFFS yaffs

热插拔机制下文件列表管理

FLAG_ALLIGNED_FAT 不能轻易打开，以前格式化过但是没有写满的硬盘，会出现致命的问题。
每个文件结尾是管理信息，其中每个扇区512字节中，256字节标记256个64k块的通道号，另外256字节标记其他信息；或者，每10s作为一个小段，记录管理信息。好像不大合适，如果某个通道码流小，I帧大量累积在缓冲区中，这个时间就不准确了。
可以考虑管理信息从后向前存储，这样，管理信息的大小就是无限的。

ctrl+c结束程序，重新启动程序后段的映射INDEX文件仍然存在影响
umount_user:umount failed2,errno=16,error=Device or resource busy： 有未正常关闭的文件。
     保证stoprecord，这样会close所有的录像文件；保证close预录文件；保证关闭INDEX0/INDEX1文件，并且UNMAP.
     Umount调用的时候，保证硬盘状态为正常连接。
     fuser -m /disk/disk0/p0/PRE00 可以用来查看文件是否未关闭。
     现有格式化函数，没有做到上列要求，所以，有时候会失败。

物联网海量碎片化数据云存储技术研究及实现
随着互联网、移动互联网和物联网的飞速发展，数据呈爆炸式增长，数据量之大、种类之多给传统的分布式存储技术带来了全新的挑战。特别是在物联网技术的发展和普及下，大量的传感器每时每刻都在产生着不同类型的传感数据。这些传感数据不仅具有时空、流式、碎片化和尺寸小的特性，而且有结构化和非结构化之分。面对如此庞大且种类繁多的小数据，目前的分布式存储系统很难对其进行集中式存储管理。所以，迫切需要研发一款物联网环境下的分布式存储系统，支持物联网海量碎片化数据的高效存储，且同时支持结构化和非结构化数据的统一存储。
  面对上述技术难题，本文通过借鉴主流分布式文件系统的优势，并结合物联网数据的特性，设计并实现了一款高效存储物联网海量碎片化数据的分布式文件系统，以小文件为载体存储物联网结构化和非结构化的碎片数据，并且能够利用物联网时空数据的特性实现物联网海量时空数据的高效检索。具体内容包括:
1)论文对国内外的分布式文件系统进行了比较和分析，总结了当前主流分布式文件系统对于物联网数据的存储缺陷，提出了设计一款支持物联网海量碎片化数据高效存储的分布式文件系统的目标，以解决物联网结构化和非结构化碎片数据的统一存储。
2)由于FastDFS在物联网环境下存在诸多不足，论文分析了物联网数据所具有的特点，设计并实现了以小文件为载体支持物联网结构化和非结构化碎片数据存储的分布式文件系统，采用了文件名索引策略和块文件分槽机制，小文件的检索效率稳定而高效，磁盘空间利用率相比FastDFS提高大约50％。
3)针对物联网时空数据，论文提出了时空信息分离索引的检索架构，提高了物联网时空数据的检索效率，填补了传统分布式文件系统的空缺
4)整合Sqlite数据库技术，以小文件的形式存储物联网结构化碎片数据，从而实现了该分布式文件系统对结构化数据和非结构化碎片数据的统一存储

新的录像文件机制
一个硬盘文件可以分成若干个小块，小块的大小和我们内存能够提供多大的缓冲区有关，如果每个通道可以有1M的缓冲区，就可以分成1M的块，mempool无法应用于这个机制，因为可能某些通道码流很低，mempool中所有数据累计都不到1M。所以64K一个小块是可以考虑的，为了进一步节省内存，可能需要8k的分块。

测试代码： 4个硬盘，写入其中1个，不断唤醒休眠其他3个硬盘

增加函数判断是否所有通道同时没有录像，这是一种严重的硬盘写故障。
可以考虑，格式化硬盘的时候，只分区；用到一个分区，就建立一个分区的FAT32文件系统。可以考虑一次建立若干个文件而不是一次性全部创建。一个文件在目录中占据32个byte，16个文件一个扇区，可以每次创建通道数个或者64个文件，大概也就百ms级别的开销。
df命令：
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/root                65536     50192     15344  77% /
tmpfs                   159140         4    159136   0% /dev
/dev/mtdblock6           40960     31312      9648  76% /opt
/dev/mtdblock7            4096      1432      2664  35% /para

现在的唤醒机制，是当前文件还剩16M空间的时候，检查下一个文件所在硬盘是否正在休眠，如果是，就唤醒它。那么可能会出现这样的情况：
     1. 硬盘唤醒之后需要热身时间，这时候写硬盘会影响稳定，那么我们应该增大预先唤醒时间，修改 MINUS_LIMIT_PRE_WAKE
     2. 如果当前硬盘已经没有空文件，突然增加若干路IPC就会调用ide_wakeup是否有问题，我看到io突然升高了50%,是否应该增加额外的保护，sleep上一段时间呢？
     3. 是否可以做一个测试，连接32IPC8个硬盘，每20s时间休眠唤醒空闲的7块硬盘。rebootcnt 设定10s就写日志。
     4. 预留几个录像文件是应该的。还是，突然增加的IPC暂时不要录像呢？
     5. StartWakeupThread 启动wakeup过程，未完成之前调用SearchRecFile，导致直接open未唤醒的硬盘上的文件，会否有不好的结果

多个线程同时执行硬盘分区操作会失败，函数非线程安全的，初始化时候或者热插拔时候都是如此，我们可以放在一个独立的线程中完成。格式化可以多硬盘并行执行。
不调用 CheckIsFormat 函数已经导致多次录像分配后因为文件长度仍然为初始化的0而立刻切换文件的问题了，改变函数结构。
ctrl+c终端程序之后调用ide_new_partition出错，估计是因为partition的mmap没有被unmap，INDEX文件仍然被使用。
     ERROR： Partition(s) 1 on /dev/sda have been written, but we have been unable to inform the kernel of the change,probably because it/they are in use.  As a result, the old partition(s) will remain in use.  You should reboot

80G的硬盘，如果容易重现问题，那么就单独做测试；测试版本改成每1分钟一个录像段；正式版本的程序，保留好测试接口，可以通过外部的
     工具打开测试选项。
16*4T, 每个文件 2460*4K = 9M*16 = 144M     rec_buf应该动态分配，现在是不对齐操作；而且REC_BUF_SIZE减小到8K，可以节省4/8M内存
硬盘命名，sda-sdz 然后 sdaa-sdzz, 然后。。。

作为录像方式，
     休眠之前调用sync()，好像未必能够保证文件写入啊。而且如果休眠后再次写入，会出现异常的吧。
     而且， 我们使用INDEX文件来管理文件，两者之间必须保证一致性，也就是说两个文件需要同步更新，这是fwrite做不到的。
     mempool的存在，对硬盘是必须的。
     文件的修改时间等，我们不应该更新，所以，不能使用普通的文件系统。
     fopen打开文件，用fileno(fd)获取对应的 file descriptor，然后调用fsync
     mmap msync管理INDEX
     fsync 函数可以强制把文件同步到硬盘上，但数据还是需要保证对齐，同样需要自己管理数据缓冲区，对我们来说不如使用open/read/write。
增加新的处理过程，持续5s以上没有硬盘写入，切换硬盘；如果没有硬盘。文件结束的时候，填充0对齐64k。读取
        int fill_size = (rec_info[attr][ch].rec_buf_pos+0xfff)&0xfffff000; //强制4k对齐
        memset(rec_info[attr][ch].rec_buf+rec_info[attr][ch].rec_buf_pos, 0, (fill_size - rec_info[attr][ch].rec_buf_pos));
        WriteDate(rec_info[attr][ch].file, rec_info[attr][ch].rec_buf, fill_size, NULL);
        s_info->data_end_offset += rec_info[attr][ch].rec_buf_pos;
        rec_info[attr][ch].rec_buf_pos = 0;
问问看，有没有命令可以触发硬盘重新协商连接。

ChangeFile ChangeSengment 函数中合并操作：
     if(rec_info[attr][ch].rec_buf_pos>0)
     {
          rec_info[attr][ch].error_flag = WriteDate(rec_info[attr][ch].file, rec_info[attr][ch].rec_buf, rec_info[attr][ch].rec_buf_pos, &s_info->data_end_offset);
          rec_info[attr][ch].rec_buf_pos = 0;
     }

     if (i_pos > 0)          rec_info[attr][ch].error_flag = WriteDate(rec_info[attr][ch].file, buf, i_pos, &s_info->data_end_offset);
记得，写完之后，rec_info[attr][ch].rec_buf_pos 清0，否则重复写入。
CopyDateToPreBuf 函数中不需要修改。

500G硬盘快速插拔正常，慢速插拔mount故障：新的mount之前，需要DestroyPartition，UnMountUser不能调用，估计因为设备号已经不存在。
     U盘部分是否需要改变呢？

自动快速格式化硬盘：格式化时间过长，是因为写FAT表时间太长。可以尝试先简单格式化，使用到文件的时候再整体格式化。只要不打开文件，FAT表应该是可以在文件系统外修改的。

writen() 函数持续写，直到写入为止，这是脑残的操作。readn()函数同样。
常理，write函数如果写硬盘有问题，一定能够返回的，否则上层代码根本无法设计。所以，我们不需要考虑它会永远阻塞在里面，做好应有的错误处理就好。

eSATA接口有什么特别的地方？硬盘的NCQ功能什么意思？

硬盘热插拔，需要重构存储模块，实际上就是每个存储设备都可以动态的添加删除和修改。

过滤所有的writen函数。所有的存储设备，重新研究一下写入的问题。writen_1 and writen 两个函数，需要重新定义，flash和硬盘和socket和U盘的写入应该分开。U盘和硬盘都定义新的函数，flash使用老的函数； socket可能有问题，小心。

U盘管理：
插入U盘：
usb 1-1: new high-speed USB device number 2 using hiusb-ehci
usb-storage 1-1:1.0: USB Mass Storage device detected
scsi4 : usb-storage 1-1:1.0
<MainCtrl.c(3205)>: @!<6>usb-storage 1-1:1.0: USB Mass Storage device detected!@
ls: /sys/bus/scsi/devices/4:0:0:0/block: No such file or directory
<TRACE:BackupGetDevices, line 329>: can''t find udisk device node
scsi 4:0:0:0: Direct-Access     Kingston DataTraveler 2.0 PMAP PQ: 0 ANSI: 6
sd 4:0:0:0: Attached scsi generic sg1 type 0
sd 4:0:0:0: [sdb] 30240768 512-byte logical blocks: (15.4 GB/14.4 GiB)
sd 4:0:0:0: [sdb] Write Protect is off
sd 4:0:0:0: [sdb] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA
<TRACE:BackupGetDevices, line 350>: can't find udisk device node
sdb: sdb1
sd 4:0:0:0: [sdb] Attached SCSI removable disk
udisk1110 -> /dev/sdb
udisk1110p1 -> /dev/sdb1
dev_name: /dev/sdb1, dir: /disk/test/sdb1
Execute cmd--mkdir -p /disk/test/sdb1 successed!

拔掉U盘：
usb 1-1: USB disconnect, device number 2
<MainCtrl.c(3202)>: @!<6>usb 1-1: USB disconnect, device number 2!@

重要相关内容：
cat /proc/scsi/scsi     SMART源代码     Disk Utility     和其他重要linux命令

硬盘不存在时执行DestroyPartition 和 UnMountUser会crash，所以硬盘插入时才可执行。
ata2: EH complete 代表硬盘已经出现过严重错误，所以，应该在收到消息之后比较长的时间内没有出现hard resetting link，才可以进一步的读写。

SATA接口重要trace：
ata1.00: hard resetting link ~ ata1.03     ata1.15               sd 0:0:0:0: [sda] Attached SCSI disk          ~~           sd 0:3:0:0: [sda] Stopping disk
ata2.00: hard resetting link ~ ata2.03     ata2.15               sd 1:0:0:0: [sda] Attached SCSI disk          ~~           sd 1:3:0:0:
ata3.00: hard resetting link ~ ata3.03     ata3.15               sd 2:0:0:0: [sda] Attached SCSI disk          ~~           sd 2:3:0:0:
ata4.00: hard resetting link ~ ata4.03     ata4.15               sd 3:0:0:0: [sda] Attached SCSI disk          ~~           sd 3:3:0:0:

ata2: EH complete          代表硬盘从严重错误中恢复，在收到消息之后较长时间内没有出现hard resetting link，方可进一步的读写。
ata2.01: disabled
ata2.02: configured for UDMA/133
sd 1:1:0:0: [sdb] Stopping disk
sd 1:1:0:0: [sdd] Attached SCSI disk

ata2.02: model number mismatch 'WDC WD30PURX-64P6ZY0' != 'ST3320620SV'
ata2.02: revalidation failed (errno=-19)
ata2.02: serial number mismatch '     WD-WMC4N0L6AM2Z' != '     WD-WMC4N0L9XU5A'
ata2.02: revalidation failed (errno=-19)
ata2.02: disabled

U盘插拔：
<MainCtrl.c(3205)>: @!<6>usb-storage 1-1:1.0: USB Mass Storage device detected!@
<MainCtrl.c(3202)>: @!<6>usb 1-1: USB disconnect, device number 2!@

<MainCtrl.c(3219)>: <6>ata2.02: hard resetting link!@
<MainCtrl.c(3258)>: <4>ata2.02: disabled!@
<MainCtrl.c(3230)>: <6>ata2: EH complete!@
<MainCtrl.c(3241)>: <5>sd 1:2:0:0: [sdc] Stopping disk!@

<MainCtrl.c(3219)>: <6>ata2.02: hard resetting link!@
<MainCtrl.c(3256)>: <6>ata2.02: configured for UDMA/133!@
<MainCtrl.c(3230)>: <6>ata2: EH complete!@
<MainCtrl.c(3254)>: <5>sd 1:2:0:0: [sdc] Attached SCSI disk!@

硬盘读取障碍：
ata2.02: failed to read log page 10h (errno=-5)
ata2.15: exception Emask 0x10 SAct 0x0 SErr 0x680100 action 0x7
ata2.15: irq_stat 0x08000000, interface fatal error
ata2.15: SError: { UnrecovData 10B8B BadCRC Handshk }
ata2.02: exception Emask 0x1 SAct 0x1 SErr 0x0 action 0x0
ata2.02: failed command: READ FPDMA QUEUED
ata2.02: cmd 60/01:00:4d:c9:d2/00:00:12:00:00/40 tag 0 ncq 512 in
         res 40/00:04:4d:c9:d2/00:00:12:00:00/40 Emask 0x1 (device error)
ata2.02: status: { DRDY }
ata2.15: hard resetting link

硬盘拔掉：
ata2.01: exception Emask 0x10 SAct 0x0 SErr 0x10002 action 0xf
ata2.01: SError: { RecovComm PHYRdyChg }
ata2.01: hard resetting link
ata2.01: SATA link down (SStatus 0 SControl 320)
ata2.01: hard resetting link
ata2.01: SATA link down (SStatus 0 SControl 320)
ata2.01: limiting SATA link speed to 1.5 Gbps
ata2.01: hard resetting link
ata2.01: SATA link down (SStatus 0 SControl 310)
ata2.01: disabled
ata2: EH complete
ata2.01: detaching (SCSI 1:1:0:0)
d 1:1:0:0: [sdb] Synchronizing SCSI cache
Result: hostbyte=0x04 driverbyte=0x00
sd 1:1:0:0: [sdb] Stopping disk
sd 1:1:0:0: [sdb] START_STOP FAILED
sd 1:1:0:0: [sdb]
Result: hostbyte=0x04 driverbyte=0x00

插上硬盘：
ata2.01: exception Emask 0x10 SAct 0x0 SErr 0x4050002 action 0xf
ata2.01: SError: { RecovComm PHYRdyChg CommWake DevExch }
ata2.01: hard resetting link
ata2.01: link is slow to respond, please be patient (ready=0)
ata2.01: softreset failed (device not ready)
ata2.15: qc timeout (cmd 0xe4)
ata2.01: failed to read SCR 0 (Emask=0x4)
ata2.01: reset failed, giving up
ata2.15: hard resetting link
ata2.15: SATA link up 3.0 Gbps (SStatus 123 SControl 300)
ata2.00: hard resetting link
ata2.00: SATA link down (SStatus 0 SControl 320)
ata2.01: hard resetting link
ata2.01: SATA link up 3.0 Gbps (SStatus 123 SControl 320)
ata2.02: hard resetting link
ata2.02: SATA link up 3.0 Gbps (SStatus 123 SControl 320)
ata2.03: hard resetting link
ata2.03: SATA link down (SStatus 0 SControl 320)
ata2.01: ATA-8: WDC WD20EARX-00PASB0, 51.0AB51, max UDMA/133
ata2.01: 3907029168 sectors, multi 0: LBA48 NCQ (depth 31/32)
ata2.01: configured for UDMA/133
ata2.02: configured for UDMA/133
ata2: EH complete
scsi 1:1:0:0: Direct-Access     ATA      WDC WD20EARX-00P 51.0 PQ: 0 ANSI: 5
sd 1:1:0:0: [sdd] 3907029168 512-byte logical blocks: (2.00 TB/1.81 TiB)
sd 1:1:0:0: [sdd] 4096-byte physical blocks
sd 1:1:0:0: Attached scsi generic sg0 type 0
sd 1:1:0:0: [sdd] Write Protect is off
sd 1:1:0:0: [sdd] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
sdd: sdd1 sdd2 sdd3 sdd4
sd 1:1:0:0: [sdd] Attached SCSI disk
udisk -> /dev/sdd
udiskp1 -> /dev/sdd1
udiskp2 -> /dev/sdd2
udiskp3 -> /dev/sdd3
udiskp4 -> /dev/sdd4

硬盘管理状态机
0： 初始化状态
     收到Attached SCSI disk消息后切换到状态2；其他消息不处理
     收到hard resetting link之后停止硬盘工作，设置硬盘故障；
状态1： SATA连接即将正常状态
     收到hard resetting link或Stopping disk切到状态0; 再次收到EH complete更新时间；收到Attached SCSI disk或超过2s没有新的消息切状态2
状态2： SATA连接正常状态。
     从别的状态切换到状态2的时候启动一个线程来处理单个硬盘加载的过程(oldstate)
     收到hard resetting link和Stopping disk切状态3; 收到EH complete消息后切换到状态1；收到Attached SCSI disk保持状态2.
状态3： 出错处理状态
     StopRecord(); 根据sata mask，确定disk_no，设置 d_info[p->disk_no].disk_error = DISK_DETECT_ERR；StartRecord(); 然后切状态2
状态间， sleep(1) 这对于硬盘的处理，足够了。

上述单个硬盘加载线程：
     1.  umount，释放mmap内存，分区，格式化，mount，mmap，initfilelist，开始录像。处理完毕，退出线程。
          ThreadMountDisk函数修改一下，不使用
     2.  发现硬盘状态变化，直接退出过程。
     涉及到d_info状态的变化，是否应该在别的地方处理呢》

如果加载失败，保持在状态2，但是存在硬盘故障的错误。

代码硬盘错误类型：
1. 判断未格式化条件：ThreadMountDisk 函数中加载文件系统失败，或者 CheckIsFormat 返回1(没有检测到Visking的tag)
     然后写入Visking_0的tag执行需要重启的格式化，重启后CheckIsFormat函数会返回2

typedef enum     _disk_state
{
     DISK_STATE_IDLE = 0,          //硬盘空闲
     DISK_STATE_RW = 1,               //硬盘正在读写
     DISK_STATE_DETECT_ERR = 2,     //硬盘检测出错
     DISK_STATE_NOT_FORMATED = 3,     //硬盘未格式化
     DISK_STATE_FILERW_ERR = 4,     //文件读写错误，应该是文件系统出错导致，或者扇区问题。
     DISK_STATE_FILEOPEN_ERR = 5,     //文件无法打开
     DISK_STATE_PARTITION_ERR = 6,     //文件系统加载错误
     DISK_STATE_NEED_REBOOT = 7,     //格式化等之后，需要重新启动。
     DISK_STATE_SLOW_WRITE_ERR = 8, //硬盘错误8，硬盘写入速度太慢
}DISK_STATE;

消息队列等进程间通信有时不稳定
ftok(DISK_MESQUEUE_TOKEN, 0) 改为 IPC_PRIVATE，否则有莫名其妙的crash：
(!) [  NO NAME        431.606,521] ( 2790) Direct/Signals:                --> Caught signal 11 (at 0x2, invalid address) <--
(!!!)  *** WARNING [still objects in 'Window Pool'] *** [object.c:239 in fusion_object_pool_destroy()]
(!!!)  *** WARNING [still objects in 'Layer Region Pool'] *** [object.c:239 in fusion_object_pool_destroy()]
(!!!)  *** WARNING [still objects in 'Layer Context Pool'] *** [object.c:239 in fusion_object_pool_destroy()]
(!!!)  *** WARNING [still objects in 'GraphicsState Pool'] *** [object.c:239 in fusion_object_pool_destroy()]
(!!!)  *** WARNING [still objects in 'Surface Pool'] *** [object.c:239 in fusion_object_pool_destroy()]
(!) DirectFB/core/vt: Unable to disallocate VT!
    --> Device or resource busy
(-) [  NO NAME        431.676,746] ( 2790) Direct/Trap:               Raising signal 1MMB LEAK(pid=2510): 0x60217000, 65536 bytes, 'AO(0,1) CirBuf'
1 from SigHandler...
(-) [  NO NAME    mmz_userdev_release: mmb<0x60217000> mapped to userspace 0x9f050000 will be force unmaped!
    431.676,816] ( 2790) Direct/Trap:   MMB LEAK(pid=2510): 0x67881000, 65536 bytes, 'AO(1,1) CirBuf'
            ...tgkill(11) on ourself retmmz_userdev_release: mmb<0x67881000> mapped to userspace 0x9f040000 will be force unmaped!
urned, maybe blocked, calling exit_group()!
Segmentation fault

