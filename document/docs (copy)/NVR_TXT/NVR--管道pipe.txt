管道PIPE
应用过程中，遇到多次fopen and open之间的区分，比如dup2对应的是open，不要弄错了。

有名管道 暂时用不上

#include <sys/types.h>
#include <sys/stat.h>

重定向stdout并且写设置为非阻塞之后的问题：写满后又输出到串口，这是无法接受的。
int mkfifo(const char * pathname, mode_t mode)
该函数的第一个参数是一个普通的路径名，也就是创建后FIFO的名字。第二个参数与打开普通文件的open()函数中的mode 参数相同。如果mkfifo的第一个参数是一个已经存在的路径名时，会返回EEXIST错误，所以一般典型的调用代码首先会检查是否返回该错误，如果确实返回该错误，那么只要调用打开FIFO的函数就可以了。一般文件的I/O函数都可以用于FIFO，如close、read、write等等。

有名管道的打开规则
有名管道比管道多了一个打开操作：open。FIFO的打开规则：
如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。
如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。

匿名管道
现在最担心的是，缓冲区太小，写阻塞会导致程序运行受到影响。另外就是read会不会不小心不阻塞导致死循环
     经过测试，没有read的话，写入64k数据之后阻塞；
     如果写入U盘硬盘卡住，那么就倒霉了。如果能够关闭写阻塞，那么完全好用。
     所以，需要单独的线程读取pipe，并且把数据发送到mempool中，然后在录像线程和U盘线程中另外写入。
     U盘线程，record线程，串口线程，网络trace线程，FLASH文件线程等多个线程。实际上，64k的buffer也够了，因为如果卡死，多大的buffer都不会
          够用的。由于这些trace是互斥的，可以在一个线程中switch判断。
管道是Linux支持的最初Unix IPC形式之一，具有以下特点：
     管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；
     只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；
     单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
     数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。
管道的主要局限性正体现在它的特点上：
        只支持单向数据流；
        只能用于具有亲缘关系的进程之间；
        没有名字；
        管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
        管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；
#include <unistd.h>
int pipe(int fd[2])
管道两端可分别用描述字fd[0]以及fd[1]来描述，需要注意的是，管道的两端是固定了任务的。即一端只能用于读，由描述字fd[0]表示，称其为管道读端；另一端则只能用于写，由描述字fd[1]来表示，称其为管道写端。如果试图从管道写端读取数据，或者向管道读端写入数据都将导致错误发生。一般文件的I/O函数都可以用于管道，如close、read、write等等

管道的缓冲区
ulimit -a查看， HISI3536为3998
pipe()创建管道、采用默认方式的方式，即默认阻塞模式。
缓冲区大小：4K， <4K的数据立即发送，以页为单位;>4K的数据，将会分成多个页的数据，分批发送。
函数 write要么阻塞，要么成功（copy全部数据到内核缓冲区，不存在只copy部分数据的情况），异常换回-1

定义两根
如何加大管道的缓冲区呢？

最近在做一个线程池写磁盘文件的任务。主线程通过管道向线程池写任务，线程池从管道的读端读任务。
按UNIX环境高级编程说的，我在主线程中关闭了管道的读端，在线程池的初始化时关闭了写端。
但是，在这种情况下，没法正常工作，只有在不关闭管道的读和写端的时候才能正常工作。
原来书上讲的是在进程的情况下，而不是我所用的线程，子线程是和创建它的进程共享fd的，任何一方关闭管道的读或写都会影响到另一方。

还有一个问题需要说明的是，管道（阻塞的读和写）写满之后，会阻塞到写端；
只有读端把管道读空（我的机器上的管道长度是4K）之后才能继续写管道，我以前以为是，只要读端读了一个字节，写端就可以继续写。
还有是：我一开始疯狂的写管道，可以写64K而不是机器上的标识（我用ulimit -p查看到是4K）4K。这个我也不知道是怎么回事儿。
代码如下：

#include    "my.h"

void * listen_thread(void *arg);
static void sig_usr(int signo);
static void sig_pipe(int signo);
int pipe_fd_work[2];

int main(int argc, char** argv)
{
    if (pipe(pipe_fd_work) < 0)
    {
        cerr<<"open pipe_fd_work error:"<<strerror(errno)<<endl;
        return -1;
    }
    else
    {
        //if i close this read of pipe ,thread can't read it
        //because they share the same fd
        //close(pipe_fd_work[0]);
    }

    signal(SIGINT, sig_usr);
    pthread_t listen_pid;
    pthread_create(&listen_pid, NULL, listen_thread, NULL);

    int nwrited;
    char *writebuf = new char[1024];
    setnonblock(pipe_fd_work[1]);
    while(1)
    {
        cout<<"before write\n"<<endl;

        nwrited = write(pipe_fd_work[1], writebuf, 1024);
        cout<<"after write\n"<<endl;
        if (nwrited == -1)
        {
            cerr<<"write pipe error:"<<strerror(errno)<<endl;
        }
        else
        {
            cout<<"writen:"<<nwrited<<endl;
        }
    }

    pthread_join(listen_pid, NULL);

    return 0;
}

void * listen_thread(void *arg)
{
    char *buf = new char[2048];
    int nreaded;
    while(1)
    {
        nreaded = read(pipe_fd_work[0], buf, 2048);
        if (nreaded == -1)
            break;
        else
        {
            cout<<"readed:"<<nreaded<<endl;
        }
        sleep(10);
    }
    delete [] buf;
    buf = NULL;
    signal(SIGPIPE, sig_pipe);
}

static void sig_pipe(int signo)
{
    if (signo == SIGPIPE)
    {
        cout<<"progrom exit"<<endl;
        exit(1);
    }
}

static void sig_usr(int signo)
{
    if (signo == SIGINT)
    {
        cout<<"progrom exit"<<endl;
        exit(1);
    }
}

